{"version":3,"sources":["../src/flow/StateMachine.ts"],"sourcesContent":["// âœ” UNIT TESTED\n\nimport {SimpleEventEmitter} from \"../Events.js\";\nimport { isStringArray } from \"../Guards.js\";\n\nexport interface Options {\n  readonly debug?: boolean\n}\n\nexport interface StateChangeEvent {\n  readonly newState: string,\n  readonly priorState: string\n}\n\nexport interface StopEvent {\n  readonly state: string;\n}\n\nexport type StateMachineEventMap = {\n  readonly change: StateChangeEvent\n  readonly stop: StopEvent\n};\n\nexport type StateEvent = (args: unknown, sender: StateMachine) => void;\nexport type StateHandler = string | StateEvent | null;\n\nexport interface State {\n  readonly [event: string]: StateHandler;\n}\n\nexport interface MachineDescription {\n  readonly [key: string]: string | readonly string[] | null;\n}\n\n/**\n * Returns a machine description based on a list of strings. The final string is the final\n * state.\n * \n * ```js\n * const states = [`one`, `two`, `three`];\n * const sm = StateMachine.create(states[0], descriptionFromList(states));\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const descriptionFromList = (...states:readonly string[]):MachineDescription => {\n  const t = {};\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\n  for (let i=0;i<states.length; i++) {\n    if (i === states.length - 1) {\n      /** @ts-ignore */\n      // eslint-disable-next-line functional/immutable-data \n      t[states[i]] = null;\n    } else {\n      /** @ts-ignore */\n      // eslint-disable-next-line functional/immutable-data\n      t[states[i]] = states[i+1];\n    }\n  }\n  return t;\n};\n\n/**\n * Returns a state machine based on a list of strings. The first string is used as the initial state,\n * the last string is considered the final. To just generate a description, use {@link descriptionFromList}.\n * \n * ```js\n * const states = [`one`, `two`, `three`];\n * const sm = StateMachine.fromList(states);\n * ```\n */\nexport const fromList = (...states:readonly string[]):StateMachine => new StateMachine(states[0], descriptionFromList(...states));\n\n/**\n * Creates a new state machine\n * @param initial Initial state\n * @param m Machine description\n * @param opts Options\n * @returns State machine instance\n */\nexport const create = (initial: string, m: MachineDescription, opts: Options = {debug: false}):StateMachine =>  new StateMachine(initial, m, opts);\n\n/**\n * State machine\n *\n * Machine description is a simple object of possible state names to allowed state(s). Eg. the following\n * has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `Sleep` can only transition to the `wakeup`\n * state, while `wakeup` can transition to either `coffee` or `breakfast`. \n * \n * Use `null` to signify the final state. Multiple states can terminate the machine if desired.\n * ```\n * const description = { \n *  sleep: 'wakeup',\n *  wakeup: ['coffee', 'breakfast'],\n *  coffee: `bike`,\n *  breakfast: `bike`,\n *  bike: null\n * }\n * ```\n * Create the machine with the starting state (`sleep`)\n * ```\n * const machine = StateMachine.create(`sleep`, description);\n * ```\n * \n * Change the state by name:\n * ```\n * machine.state = `wakeup`\n * ```\n * \n * Or request an automatic transition (will use first state if there are several options)\n * ```\n * machine.next();\n * ```\n * \n * Check status\n * ```\n * if (machine.state === `coffee`) ...;\n * if (machine.isDone()) ...\n * ```\n * \n * Listen for state changes\n * ```\n * machine.addEventListener(`change`, (evt) => {\n *  const {priorState, newState} = evt;\n *  console.log(`State change from ${priorState} -> ${newState}`);\n * });\n * ```\n * @export\n * @class StateMachine\n * @extends {SimpleEventEmitter<StateMachineEventMap>}\n */\nexport class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #state: string;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #debug: boolean;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #m: MachineDescription;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #isDone: boolean;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #initial: string;\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param string initial Initial state\n   * @param MachineDescription m Machine description\n   * @param Options Options for machine (defaults to `{debug:false}`)\n   * @memberof StateMachine\n   */\n  constructor(initial: string, m: MachineDescription, opts: Options = {debug: false}) {\n    super();\n    const [isValid, errorMsg] = StateMachine.validate(initial, m);\n    if (!isValid) throw new Error(errorMsg);\n\n    this.#initial = initial;\n    this.#m = m;\n    this.#debug = opts.debug ?? false;\n    this.#state = initial;\n    this.#isDone = false;\n  }\n\n  get states():readonly string[] {\n    return Object.keys(this.#m);\n  }\n\n  static validate(initial:string, m:MachineDescription):readonly [boolean, string]  {\n    // Check that object is structured properly\n    const keys = Object.keys(m);\n    // eslint-disable-next-line functional/prefer-readonly-type\n    const finalStates:string[] = [];\n    const seenKeys = new Set();\n    const seenVals = new Set();\n\n    // eslint-disable-next-line functional/no-loop-statement, functional/no-let\n    for (let i=0;i<keys.length;i++) {\n      const key = keys[i];\n      if (seenKeys.has(key)) return [false, `Key ${key} is already used`];\n      seenKeys.add(key);\n\n      if (typeof keys[i] !== `string`) return [false, `Key[${i}] is not a string`];\n      const val = m[key];\n      if (val === undefined) return [false, `Key ${key} value is undefined`];\n      if (typeof val === `string`) {\n        seenVals.add(val);\n        if (val === key) return [false, `Loop present for ${key}`];\n      } else if (Array.isArray(val)) {\n        if (!isStringArray(val)) return [false, `Key ${key} value is not an array of strings`];\n        val.forEach(v => seenVals.add(v));\n        if (val.find(v => v === key)) return [false, `Loop present for ${key}`];\n      } else if (val === null) {\n        // eslint-disable-next-line functional/immutable-data\n        finalStates.push(key);\n      } else {\n        return [false, `Key ${key} has a value that is neither null, string or array`];\n      }\n    }\n\n    // Check that all values have a top-level state\n    const seenValsArray = Array.from(seenVals);\n    const missing = seenValsArray.find(v => !seenKeys.has(v));\n    if (missing) return [false, `Potential state '${missing}' does not exist as a top-level state`];\n\n    // Check machine contains intial state\n    if (m[initial] === undefined) return [false, `Initial state ${initial} not present`];\n    return [true, ``];\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   * \n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   * @memberof StateMachine\n   */\n  next(): string | null {\n    // Get possible transitions for current state\n    const r = this.#m[this.#state];\n    if (r === null) return null; // At the end\n\n    // If there are multiple options, use the first\n    if (Array.isArray(r)) {\n      // eslint-disable-next-line functional/immutable-data\n      if (typeof r[0] === `string`) this.state = r[0];\n      else throw new Error(`Error in machine description. Potential state array does not contain strings`);\n    } else if (typeof r === `string`) {\n      // eslint-disable-next-line functional/immutable-data\n      this.state = r; // Just one option\n    } else throw new Error(`Error in machine description. Potential state is neither array nor string`);\n    return this.state;\n  }\n\n  /**\n   * Returns true if state machine is in its final state\n   *\n   * @returns\n   * @memberof StateMachine\n   */\n  get isDone():boolean {\n    return this.#isDone;\n  }\n\n  /**\n   * Resets machine to initial state\n   *\n   * @memberof StateMachine\n   */\n  reset() {\n    // eslint-disable-next-line functional/immutable-data\n    this.#isDone = false;\n    // eslint-disable-next-line functional/immutable-data\n    this.#state = this.#initial;\n  }\n\n  /**\n   * Checks whether a state change is valid.\n   *\n   * @static\n   * @param priorState From state\n   * @param newState To state\n   * @param description Machine description\n   * @returns If valid: [true,''], if invalid: [false, 'Error msg here']\n   * @memberof StateMachine\n   */\n  static isValid(priorState:string, newState:string, description:MachineDescription):readonly [boolean, string] {\n    // Does state exist?\n    if (description[newState] === undefined) return [false, `Machine cannot change to non-existent state ${newState}`];\n\n    // Is transition allowed?\n    const rules = description[priorState];\n    if (Array.isArray(rules)) {\n      if (!rules.includes(newState)) return [false, `Machine cannot change '${priorState} -> ${newState}'. Allowed transitions: ${rules.join(`, `)}`];\n    } else {\n      if (newState !== rules && rules !== `*`) return [false, `Machine cannot '${priorState} -> ${newState}'. Allowed transition: ${rules}`];\n    }\n    return [true, `ok`];\n  }\n\n  isValid(newState:string):readonly [boolean, string] {\n    return StateMachine.isValid(this.state, newState, this.#m);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `StateMachine.isValid` to check validity without changing.\n   *\n   * @memberof StateMachine\n   */\n  set state(newState: string) {\n    const priorState = this.#state;\n\n    const [isValid, errorMsg] = StateMachine.isValid(priorState, newState, this.#m);\n\n    if (!isValid) throw new Error(errorMsg);\n\n    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);\n\n    // eslint-disable-next-line functional/immutable-data\n    this.#state = newState;\n\n    const rules = this.#m[newState];\n    if (rules === null) {\n      // eslint-disable-next-line functional/immutable-data\n      this.#isDone = true;\n    }\n    setTimeout(() => {\n      this.fireEvent(`change`, {newState: newState, priorState: priorState});\n      if (this.isDone) this.fireEvent(`stop`, {state: newState });\n    }, 1);\n  }\n\n  get state(): string {\n    return this.#state;\n  }\n}"],"mappings":"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","names":[]}