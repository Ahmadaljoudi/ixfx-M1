{"version":3,"sources":["../src/Generators.ts","../src/modulation/PingPong.ts","../src/IterableSync.ts"],"sourcesContent":["import {number as guardNumber, integer as guardInteger} from \"./Guards.js\";\r\nexport {pingPong, pingPongPercent} from './modulation/PingPong.js';\r\nexport * as Async from './IterableAsync.js';\r\nexport * as Sync from './IterableSync.js';\r\n\r\nexport {interval} from './flow/Interval.js';\r\nexport {delayLoop} from './flow/Delay.js';\r\n\r\n/**\r\n * Generates a range of numbers, starting from `start` and counting by `interval`.\r\n * If `end` is provided, generator stops when reached.\r\n * \r\n * Unlike {@link numericRange}, numbers might contain rounding errors\r\n * \r\n * ```js\r\n * for (const c of numericRangeRaw(10, 100)) {\r\n *  // 100, 110, 120 ...\r\n * }\r\n * ```\r\n * @param interval Interval between numbers\r\n * @param start Start\r\n * @param end End (if undefined, range never ends)\r\n */\r\nexport const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = start;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n *\r\n * @example For-loop\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * \r\n * @example If you want more control over when/where incrementing happens...\r\n * ```js\r\n * let percent = numericRange(0.1, 0, 1);\r\n * \r\n * let percentResult = percent.next().value;\r\n * ```\r\n * \r\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\r\n * number.\r\n * \r\n * @param interval Interval between numbers\r\n * @param start Start. Defaults to 0\r\n * @param end End (if undefined, range never ends)\r\n * @param repeating Range loops from start indefinately. Default _false_\r\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  guardNumber(interval,  `nonZero`);\r\n  \r\n  const negativeInterval = interval < 0;\r\n  if (end === undefined) {\r\n    /* no op */\r\n  } else {\r\n    if (negativeInterval && start < end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\r\n    if (!negativeInterval && start > end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\r\n  }\r\n\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    //eslint-disable-next-line functional/no-let\r\n    let v = start * rounding;\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\r\n * count decreases. If `offset` is provided, this is added to the return result.\r\n * @example\r\n * ```js\r\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\r\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\r\n * for (const v of count(5, 5)) {\r\n *  // Yields: 5, 6, 7, 8, 9\r\n * }\r\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\r\n * ```\r\n * \r\n * @example Used with forEach\r\n * ```js\r\n * // Prints `Hi` 5x\r\n * forEach(count(5), () => console.log(`Hi`));\r\n * ```\r\n * \r\n * If you want to accumulate return values, consider using\r\n * {@link Flow.repeat}.\r\n * @param amount Number of integers to yield \r\n * @param offset Added to result\r\n */\r\nexport const count = function* (amount:number, offset:number = 0) {\r\n  // Unit tested.\r\n  guardInteger(amount, ``, `amount`);\r\n  guardInteger(offset, ``, `offset`);\r\n\r\n  if (amount === 0) return;\r\n  \r\n  //eslint-disable-next-line functional/no-let\r\n  let i = 0;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    if (amount < 0) yield -i + offset;\r\n    else yield i + offset;\r\n  } while (i++ < Math.abs(amount) - 1);\r\n};\r\n\r\n/**\r\n * Returns a number range between 0.0-1.0. \r\n * \r\n * ```\r\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\r\n * const a = [...numericPercent(0.2)];\r\n * \r\n * // Repeating flag set to true:\r\n * for (const v of numericPercent(0.2, true)) {\r\n *  // Infinite loop. V loops back to 0 after hitting 1\r\n * }\r\n * ```\r\n * \r\n * If `repeating` is true, it loops back to 0 after reaching 1\r\n * @param interval Interval (default: 0.01, ie. 1%)\r\n * @param repeating Whether generator should loop (default: false)\r\n * @param start Start (default: 0)\r\n * @param end End (default: 1)\r\n * @returns \r\n */\r\nexport const numericPercent = function (interval:number = 0.01, repeating:boolean = false, start:number = 0, end = 1) {\r\n  guardNumber(interval, `percentage`, `interval`);\r\n  guardNumber(start, `percentage`, `start`);\r\n  guardNumber(end, `percentage`, `end`);\r\n  return numericRange(interval, start, end, repeating);\r\n};","import {number as guardNumber} from \"../Guards.js\";\r\n\r\n/**\r\n * Continually loops up and down between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * @example Usage\r\n * ```js\r\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\r\n * for (const v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * @example Alternative:\r\n * ```js\r\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\r\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\r\n * ```\r\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\r\n * ```\r\n * @param interval Amount to increment by. Defaults to 10%\r\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, lower?: number, upper?: number, start?: number, rounding?: number) {\r\n  if (lower === undefined) lower = 0;\r\n  if (upper === undefined) upper = 1;\r\n  if (start === undefined) start = lower;\r\n\r\n  guardNumber(interval, `bipolar`, `interval`);\r\n  guardNumber(upper, `bipolar`, `end`);\r\n  guardNumber(start, `bipolar`, `offset`);\r\n  guardNumber(lower, `bipolar`, `start`);\r\n  return pingPong(interval, lower, upper, start, rounding);\r\n};\r\n\r\n/**\r\n * Ping-pongs continually back and forth `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * In a loop:\r\n * ```\r\n * for (const c of pingPong(10, 0, 100)) {\r\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\r\n * }\r\n * ```\r\n * \r\n * Manual:\r\n * ```\r\n * const pp = pingPong(10, 0, 100);\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * @param interval Amount to increment by. Use negative numbers to start counting down\r\n * @param lower Lower bound (inclusive)\r\n * @param upper Upper bound (inclusive, must be greater than start)\r\n * @param start Starting point within bounds (defaults to `lower`)\r\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, start?: number, rounding?: number) {\r\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\r\n  if (interval === undefined) throw new Error(`Parameter 'interval' is undefined`);\r\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\r\n\r\n  if (rounding === undefined && (interval <=1 && interval >= 0)) rounding = 10 / interval;\r\n  else if (rounding === undefined) rounding = 1234;\r\n\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (interval === 0) throw new Error(`Interval is zero (rounding: ${rounding})`);\r\n  if (start === undefined) start = lower;\r\n  else start = Math.floor(start * rounding);\r\n  if (start > upper || start < lower) throw new Error(`Start (${start/rounding}) must be within lower (${lower/rounding}) and upper (${upper/rounding})`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = start;\r\n  yield v / rounding;\r\n  //eslint-disable-next-line functional/no-let\r\n  let firstLoop = true;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    //console.log(`v: ${v} incrementing: ${incrementing} interval: ${interval}`);\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n","/**\r\n * Return `it` broken up into chunks of `size`\r\n * \r\n * ```js\r\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\r\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\r\n * ```\r\n * @param it \r\n * @param size \r\n * @returns \r\n */\r\n\r\nimport {IsEqual} from \"./Util\";\r\n\r\n/**\r\n * Breaks an iterable into array chunks\r\n * ```js\r\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\r\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\r\n * ```\r\n * @param it \r\n * @param size \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* chunks<V>(it:Iterable<V>, size:number) {\r\n  //eslint-disable-next-line functional/no-let\r\n  let buffer = [];\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    //eslint-disable-next-line functional/immutable-data\r\n    buffer.push(v);\r\n    if (buffer.length === size) {\r\n      yield buffer;\r\n      buffer = [];\r\n    }\r\n  }\r\n  if (buffer.length > 0) yield buffer;\r\n}\r\n\r\n/**\r\n * Return concatenation of iterators\r\n * @param its \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* concat<V>(...its:readonly Iterable<V>[]) {\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const it of its) yield* it;\r\n}\r\n\r\n/**\r\n * Drops elements that do not meet the predicate `f`.\r\n * ```js\r\n * dropWhile([1, 2, 3, 4], e => e < 3);\r\n * returns [3, 4]\r\n * ```\r\n * @param it \r\n * @param f \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* dropWhile<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) { \r\n    if (!f(v)) {\r\n      yield v;\r\n      break;\r\n    }\r\n  }\r\n  yield* it;\r\n}\r\n\r\n/**\r\n * Returns true if items in two iterables are equal, as\r\n * determined by the `equality` function.\r\n * @param it1 \r\n * @param it2 \r\n * @param equality \r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function equals<V>(it1:IterableIterator<V>, it2:IterableIterator<V>, equality?:IsEqual<V>) {\r\n  //it1 = it1[Symbol.iterator]();\r\n  //it2 = it2[Symbol.iterator]();\r\n  //eslint-disable-next-line functional/no-loop-statement,no-constant-condition\r\n  while (true) {\r\n    const i1 = it1.next(), i2 = it2.next();\r\n    if (equality !== undefined) {\r\n      if (!equality(i1.value, i2.value)) return false;\r\n    } else if (i1.value !== i2.value) return false;\r\n    if (i1.done || i2.done) return i1.done && i2.done;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if `f` returns true for \r\n * every item in iterable\r\n * @param it \r\n * @param f \r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function every<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-let\r\n  let ok = true;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) ok = ok && f(v);\r\n  return ok;\r\n}\r\n\r\n/**\r\n * Yields `v` for each item within `it`.\r\n * \r\n * ```js\r\n * fill([1, 2, 3], 0);\r\n * // Yields: [0, 0, 0]\r\n * ```\r\n * @param it \r\n * @param v \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* fill<V>(it:Iterable<V>, v:V) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const _ of it) yield v;\r\n}\r\n\r\n/**\r\n * Execute function `f` for each item in iterable\r\n * @param it \r\n * @param f \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function forEach<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) f(v);\r\n}\r\n\r\n/**\r\n * ```js\r\n * filter([1, 2, 3, 4], e => e % 2 == 0);\r\n * returns [2, 4]\r\n * ```\r\n * @param it \r\n * @param f \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* filter<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    if (!f(v)) continue;\r\n    yield v;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns first item from iterable `it` that matches predicate `f`\r\n * ```js\r\n * find([1, 2, 3, 4], e => e > 2);\r\n * // Yields: 3\r\n * ```\r\n * @param it \r\n * @param f \r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport  function find<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) { \r\n    if (f(v)) return v;\r\n  } \r\n}\r\n\r\n/**\r\n * Returns a 'flattened' copy of array, un-nesting arrays one level\r\n * ```js\r\n * flatten([1, [2, 3], [[4]]]);\r\n * // Yields: [1, 2, 3, [4]];\r\n * ```\r\n * @param it \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* flatten<V>(it:Iterable<V>) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    if (Symbol.iterator in v) { \r\n      // @ts-ignore\r\n      yield* v;\r\n    } else {\r\n      yield v;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Maps an iterable of type `V` to type `X`.\r\n * ```js\r\n * map([1, 2, 3], e => e*e)\r\n * returns [1, 4, 9]\r\n * ```\r\n * @param it \r\n * @param f \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* map<V, X>(it:Iterable<V>, f:(v:V) => X) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) { \r\n    yield f(v);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the maximum seen of an iterable\r\n * ```js\r\n * min([\r\n *  {i:0,v:1},\r\n *  {i:1,v:9},\r\n *  {i:2,v:-2}\r\n * ], (a, b) => a.v > b.v);\r\n * // Yields: {i:1, v:-9}\r\n * ```\r\n * @param it Iterable\r\n * @param gt Should return _true_ if `a` is greater than `b`.\r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function max<V>(it:Iterable<V>, gt = (a:V, b:V) => a > b) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-let\r\n  let max;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    if(!max) {\r\n      max = v;\r\n      continue;\r\n    }\r\n    max = gt(max, v)?max:v;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * Returns the minimum seen of an iterable\r\n * ```js\r\n * min([\r\n *  {i:0,v:1},\r\n *  {i:1,v:9},\r\n *  {i:2,v:-2}\r\n * ], (a, b) => a.v > b.v);\r\n * // Yields: {i:2, v:-2}\r\n * ```\r\n * @param it Iterable\r\n * @param gt Should return _true_ if `a` is greater than `b`.\r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function min<V>(it:Iterable<V>, gt = (a:V, b:V) => a > b) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-let\r\n  let min;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    if(!min) {\r\n      min = v;\r\n      continue;\r\n    }\r\n    min = gt(min, v)?v:min;\r\n  }\r\n  return min;\r\n}\r\n\r\n/**\r\n * Returns count from `start` for a given length\r\n * ```js\r\n * range(-5, 10);\r\n * // Yields: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\r\n * ```\r\n * @param start \r\n * @param len \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* range(start:number, len:number) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i=0;i<len;i++) {\r\n    yield start++;\r\n  }\r\n  //for (let i=len;len > 0; len--) yield start++;\r\n}\r\n\r\n/**\r\n * Reduce for iterables\r\n * ```js\r\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\r\n * // Yields: 6\r\n * ```\r\n * @param it Iterable\r\n * @param f Function\r\n * @param start Start value\r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function reduce<V>(it:Iterable<V>, f:(acc:V, current:V) => V, start:V) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) start = f(start, v);\r\n  return start;\r\n}\r\n\r\n/**\r\n * Returns a section from an iterable\r\n * @param it Iterable\r\n * @param start Start index\r\n * @param end End index (or until completion)\r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* slice<V>(it:Iterable<V>, start = 0, end = Number.POSITIVE_INFINITY) {\r\n  // https://surma.github.io/underdash/\r\n  const iit = it[Symbol.iterator]();\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for(; start > 0; start--, end--) iit.next();\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) { \r\n    if (end-- > 0) { \r\n      yield v;\r\n    } else { \r\n      break; \r\n    } \r\n  }\r\n}\r\n\r\n/**\r\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\r\n * data, and exiting quickly \r\n * ```js\r\n * some([1, 2, 3, 4], e => e % 3 === 0);\r\n * // Yields: true\r\n * ```\r\n * @param it Iterable\r\n * @param f Filter function\r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function some<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) { \r\n    if (f(v)) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns items for which the filter function returns _true_\r\n * ```js\r\n * takeWhile([ 1, 2, 3, 4 ], e => e < 3);\r\n * // Yields: [ 1, 2 ]\r\n * ```\r\n * @param it Iterable\r\n * @param f Filter function\r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* takeWhile<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    if (!f(v)) return;\r\n    yield v;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns unique items from several iterables\r\n * ```js\r\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\r\n * Yields: returns [{i:0,v:2},{i:1,v:3}]\r\n *\r\n * @param it \r\n * @param f \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* unique<V>(it:Iterable<V>, f:((id:V) => V) = id => id) {\r\n  // https://surma.github.io/underdash/\r\n  const buffer = [];\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of it) {\r\n    const fv = f(v);\r\n    if (buffer.indexOf(fv) !== -1) continue;\r\n    //eslint-disable-next-line functional/immutable-data\r\n    buffer.push(fv);\r\n    yield v;\r\n  }\r\n}\r\n\r\n/**\r\n * Combine same-positioned items from several iterables\r\n * ```js\r\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\r\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\r\n * ```\r\n * @param its \r\n * @returns \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* zip<V>(...its:readonly Iterable<V>[]) {\r\n  // https://surma.github.io/underdash/\r\n  const iits = its.map(it => it[Symbol.iterator]());\r\n\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while(true) {\r\n    const vs = iits.map(it => it.next());\r\n    if (vs.some(v => v.done)) return;\r\n    yield vs.map(v => v.value);\r\n  }\r\n}"],"mappings":"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","names":[]}