{"version":3,"sources":["../src/collections/index.ts","../src/collections/CircularArray.ts","../src/collections/MapMultiMutable.ts","../src/collections/Stack.ts","../src/collections/Queue.ts","../src/collections/MapImmutable.ts","../src/collections/MapMutable.ts"],"sourcesContent":["export * from  './Interfaces.js';\r\n\r\nexport {mapSet, mapCircular, mapArray} from './MapMultiMutable.js';\r\nexport {circularArray} from './CircularArray.js';\r\nexport {simpleMapArrayMutable} from './SimpleMapArray.js';\r\nexport {setMutable} from './Set.js';\r\nexport {stack, stackMutable} from './Stack.js';\r\nexport {queue, queueMutable} from './Queue.js';\r\nexport {map} from './MapImmutable.js';\r\nexport {mapMutable} from './MapMutable.js';\r\n\r\n/**\r\n * Stacks store items in order. \r\n * \r\n * Stacks and queues can be helpful when it's necessary to process data in order, but each one has slightly different behaviour.\r\n * \r\n * Like a stack of plates, the newest item (on top) is removed\r\n * before the oldest items (at the bottom). {@link Queues} operate differently, with\r\n * the oldest items (at the front of the queue) removed before the newest items (at the end of the queue).\r\n * \r\n * Create stacks with {@link stack} or {@link stackMutable}. These return a {@link Stack} or {@link StackMutable} respectively.\r\n * \r\n * The ixfx implementation allow you to set a capacity limit with three {@link DiscardPolicy |policies} for\r\n * how items are evicted.\r\n */\r\nexport * as Stacks from './Stack.js';\r\n\r\n/** \r\n * Arrays are a list of data.\r\n * \r\n * ixfx has several functions for working with arrays.\r\n * \r\n * For arrays of numbers: {@link average}, {@link minMaxAvg}\r\n * \r\n * Randomisation: {@link randomIndex}, {@link randomElement}, {@link shuffle}\r\n * \r\n * Filtering: {@link without}\r\n * \r\n * Changing the shape: {@link groupBy}\r\n */\r\nexport * as Arrays from './Arrays.js';\r\n\r\n/**\r\n * Sets store unique items. \r\n * \r\n * ixfx's {@link SetMutable} compares items by value rather than reference, unlike the default JS implementation.\r\n * \r\n * Create using {@link setMutable}\r\n */\r\nexport * as Sets from './Set.js';\r\n\r\n/**\r\n * Queues store items in the order in which they are added.\r\n * \r\n * Stacks and queues can be helpful when it's necessary to process data in order, but each one has slightly different behaviour.\r\n * \r\n * Like lining up at a bakery, the oldest items (at the front of the queue) are removed \r\n * before the newest items (at the end of the queue). This is different to {@link Stacks},\r\n * where the newest item (on top) is removed before the oldest items (at the bottom).\r\n * \r\n * The ixfx implementations allow you to set a capacity limit with three {@link DiscardPolicy |policies} for\r\n * how items are evicted.\r\n * \r\n * Create queues with {@link queue} or {@link queueMutable}. These return a {@link Queue} or {@link QueueMutable} respectively.\r\n */\r\nexport * as Queues from './Queue.js';\r\n\r\n/**\r\n * Maps associate keys with values. Several helper functions are provided\r\n * for working with the standard JS Map class.\r\n * \r\n * ixfx also includes {@link MapMutable}, {@link MapImmutable}\r\n */\r\nexport * as Maps from './Map.js';\r\n","import {CircularArray} from \"./Interfaces.js\";\r\nimport { integer as guardInteger } from \"../Guards.js\";\r\n\r\nclass CircularArrayImpl<V> extends Array {\r\n  // ✔ Class is unit tested!\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  #capacity: number;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  #pointer: number;\r\n\r\n  constructor(capacity: number = 0) {\r\n    super();\r\n    // Allowed to create with capacity zero\r\n    guardInteger(capacity, `positive`, `capacity`);\r\n\r\n    // Can't throw because .filter won't use ctor proprly\r\n    this.#capacity = capacity;\r\n    this.#pointer = 0;\r\n  }\r\n\r\n  add(thing: V): CircularArrayImpl<V> {\r\n    const ca = CircularArrayImpl.from(this) as CircularArrayImpl<V>;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca[this.#pointer] = thing;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca.#capacity = this.#capacity;\r\n    if (this.#capacity > 0) {\r\n      /* eslint-disable-next-line functional/immutable-data */\r\n      ca.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\r\n    } else {\r\n      /* eslint-disable-next-line functional/immutable-data */\r\n      ca.#pointer = this.#pointer + 1;\r\n    }\r\n    return ca;\r\n  }\r\n\r\n  get pointer(): number {\r\n    return this.#pointer;\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    if (this.#capacity === 0) return false;\r\n    return this.length === this.#capacity;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Returns a new circular array. Immutable. A circular array only keeps up to `capacity` items.\r\n * Old items are overridden with new items.\r\n * \r\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\r\n * to keep the `CircularArray` behaviour.\r\n * @example\r\n * ```js\r\n * let a = circularArray(10);\r\n * a = a.add(`hello`); // Because it's immutable, capture the return result of `add`\r\n * a.isFull;  // True if circular array is full\r\n * a.pointer; // The current position in array it will write to\r\n * ```\r\n * @template V Value of array items\r\n * @param {number} capacity Capacity.\r\n * @return {*}  {CircularArray<V>}\r\n */\r\nexport const circularArray = <V>(capacity:number): CircularArray<V> => new CircularArrayImpl<V>(capacity);\r\n","// ✔ UNIT TESTED\r\nimport { SimpleEventEmitter } from \"../Events.js\";\r\nimport { ToString, toStringDefault, isEqualDefault } from \"../Util.js\";\r\nimport { hasAnyValue as mapHasAnyValue,  toArray as mapToArray, find as mapFind, filter as mapFilter, addUniqueByHash} from './Map.js';\r\nimport { without } from './Arrays.js';\r\nimport { circularArray } from './CircularArray.js';\r\nimport {CircularArray, MapArrayEvents, MapArrayOpts, MapCircularOpts, MapMultiOpts, MapOfMutable, MapSetOpts, MultiValue} from \"./Interfaces.js\";\r\n\r\nclass MapOfMutableImpl<V, M> extends SimpleEventEmitter<MapArrayEvents<V>> {\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #map: Map<string, M> = new Map();\r\n  readonly groupBy: ToString<V>;\r\n  readonly type: MultiValue<V, M>;\r\n\r\n  constructor(type:MultiValue<V, M>, opts:MapMultiOpts<V> = {}) {\r\n    super();\r\n    this.type = type;\r\n    this.groupBy = opts.groupBy ?? toStringDefault;\r\n  }\r\n\r\n  /**\r\n   * Returns the type name. For in-built implementations, it will be one of: array, set or circular\r\n   */\r\n  get typeName() {\r\n    return this.type.name;\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the longest child list\r\n   */\r\n  get lengthMax() {\r\n    //eslint-disable-next-line functional/no-let\r\n    let m = 0;\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const v of this.#map.values()) {\r\n      m = Math.max(m, this.type.count(v));\r\n    }\r\n    return m;\r\n  }\r\n\r\n  debugString(): string {\r\n    const keys = Array.from(this.#map.keys());\r\n    // eslint-disable-next-line functional/no-let\r\n    let r = `Keys: ${keys.join(`, `)}\\r\\n`;\r\n    keys.forEach(k => {\r\n      const v = this.#map.get(k);\r\n      if (v !== undefined) {\r\n        const asArray = this.type.toArray(v);\r\n        if (asArray !== undefined) {\r\n          r += ` - ${k} (${this.type.count(v)}) = ${JSON.stringify(asArray)}\\r\\n`;\r\n        }\r\n      } else r += ` - ${k} (undefined)\\r\\n`;\r\n    });\r\n    return r;\r\n  }\r\n\r\n  get isEmpty():boolean {\r\n    return (this.#map.size === 0);\r\n  }\r\n\r\n  clear() {\r\n    this.#map.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  addKeyedValues(key: string, ...values: ReadonlyArray<V>) {\r\n    const set = this.#map.get(key);\r\n    //console.log(`addKeyedValues: key: ${key} values: ${JSON.stringify(values)}`);\r\n    if (set === undefined) {\r\n      this.#map.set(key, this.type.add(undefined, values));\r\n      super.fireEvent(`addedKey`, {key:key});\r\n      super.fireEvent(`addedValues`, {values: values});\r\n    } else {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#map.set(key, this.type.add(set, values));\r\n      super.fireEvent(`addedValues`, {values: values});\r\n    }\r\n  }\r\n\r\n  addValue(...values:ReadonlyArray<V>) {\r\n    values.forEach(v => this.addKeyedValues(this.groupBy(v), v));\r\n  }\r\n\r\n  hasKeyValue(key:string, value:V):boolean {    \r\n    const m = this.#map.get(key);\r\n    if (m === undefined) return false;    \r\n    return this.type.has(m, value);\r\n  }\r\n\r\n  has(key:string):boolean {\r\n    return this.#map.has(key);\r\n  }\r\n\r\n  deleteKeyValue(key: string, value: V):boolean {\r\n    const a = this.#map.get(key);\r\n    if (a === undefined) return false;\r\n    const preCount = this.type.count(a);\r\n\r\n    const filtered = this.type.without(a, value);// this.type.filter(a, v => !this.valueComparer(v, value));\r\n    const postCount = filtered.length;\r\n    this.#map.set(key, this.type.add(undefined, filtered));\r\n    return preCount > postCount;\r\n  }\r\n\r\n  delete(key:string): boolean {\r\n    const a = this.#map.get(key);\r\n    if (a === undefined) return false;\r\n    this.#map.delete(key);\r\n    this.fireEvent(`deleteKey`, {key: key});\r\n    return true;\r\n  }\r\n\r\n  findKeyForValue(value: V): string | undefined {\r\n    const keys = Array.from(this.#map.keys());\r\n    const found = keys.find(key => {\r\n      const a = this.#map.get(key);\r\n      if (a === undefined) throw Error(`Bug: map could not be accessed`);\r\n      if (this.type.has(a, value)) return true;\r\n      return false;\r\n    });\r\n    return found;\r\n  }\r\n\r\n  count(key: string): number {\r\n    const e = this.#map.get(key);\r\n    if (e === undefined) return 0;\r\n    return this.type.count(e);\r\n  }\r\n\r\n  /**\r\n   * Returns the array of values stored under `key`\r\n   * or undefined if key does not exist\r\n   *\r\n   * @param {string} key\r\n   * @return {*}  {readonly}\r\n   * @memberof MutableMapArray\r\n   */\r\n  get(key: string): readonly V[] | undefined {\r\n    const m = this.#map.get(key);\r\n    if (m === undefined) return undefined;\r\n    return this.type.toArray(m);\r\n  }\r\n\r\n  getSource(key:string): M|undefined {\r\n    return this.#map.get(key);\r\n  }\r\n\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  keys(): string[] {\r\n    return Array.from(this.#map.keys());\r\n  }\r\n\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  keysAndCounts(): Array<[string, number]> {\r\n    const keys = this.keys();\r\n    /* eslint-disable-next-line functional/prefer-readonly-type */\r\n    const r = keys.map(k => [k, this.count(k)]) as Array<[string, number]>;\r\n    return r;\r\n  }\r\n\r\n  merge(other: MapOfMutable<V, M>) {\r\n    const keys = other.keys();\r\n    keys.forEach(key => {\r\n      const data = other.get(key);\r\n      if (data !== undefined) this.addKeyedValues(key, ...data);\r\n    });\r\n  }\r\n}\r\n\r\n// ✔ UNIT TESTED\r\n/**\r\n * Returns a {@link MapOfMutable} to allow storing multiple values under a key, unlike a regular Map.\r\n * @example\r\n * ```js\r\n * const map = mapArray();\r\n * map.add(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\r\n * \r\n * const hello = map.get(`hello`); // Get back values\r\n * ```\r\n * \r\n * Takes options { comparer: {@link IsEqual}, toString: {@link ToString}}\r\n * \r\n * A custom {@link ToString} function can be provided which is used when checking value equality (`has`, `without`)\r\n * ```js\r\n * const map = mapArray({toString:(v) => v.name}); // Compare values based on their `name` field;\r\n * ``` \r\n * \r\n * Alternatively, a {@link IsEqual} function can be used:\r\n * ```js\r\n * const map = mapArray({comparer: (a, b) => a.name === b.name });\r\n * ```\r\n * @param opts \r\n * @template V Data type of items \r\n * @returns {@link MapOfMutable}\r\n */\r\nexport const mapArray = <V>(opts:MapArrayOpts<V> = {}):MapOfMutable<V, ReadonlyArray<V>> => {\r\n  const comparer = opts.comparer === undefined ?\r\n    opts.toString === undefined ? (a:V, b:V) => opts.toString(a) === opts.toString(b) :\r\n      isEqualDefault\r\n    : opts.comparer;\r\n    \r\n  const t:MultiValue<V, ReadonlyArray<V>> = {\r\n    get name()  {\r\n      return `array`;\r\n    },\r\n    add:(dest, values) => {\r\n      if (dest === undefined) return [...values];\r\n      return [...dest, ...values];\r\n    },\r\n    count: (source) => source.length,\r\n    find: (source, predicate) => source.find(predicate),\r\n    filter: (source, predicate) => source.filter(predicate),\r\n    toArray: (source) => source,\r\n    has: (source, value) => source.find(v => comparer(v, value)) !== undefined,\r\n    without: (source, value) => source.filter(v => !comparer(v, value))\r\n  };\r\n  const m = new MapOfMutableImpl<V, ReadonlyArray<V>>(t, opts);\r\n  return m;\r\n};\r\n\r\n/**\r\n * Returns a {@link MapOfMutable} that uses a set to hold values.\r\n * This means that only unique values are stored under each key. By default it\r\n * uses the JSON representation to compare items. \r\n * \r\n * Options: { hash: {@link ToString} }\r\n * \r\n * @example Only storing the newest three items per key\r\n * ```js\r\n * const map = mapSetMutable();\r\n * map.add(`hello`, [1, 2, 3, 1, 2, 3]);\r\n * const hello = map.get(`hello`); // [1, 2, 3]\r\n * ```\r\n * \r\n * Provide a {@link ToString} function for custom equality checking\r\n * \r\n * @example\r\n * ```js\r\n * const hash = (v) => v.name; // Use name as the key\r\n * const map = mapSetMutable(hash);\r\n * map.add(`hello`, {age:40, name: `Mary`});\r\n * map.add(`hello`, {age:29, name: `Mary`}); // Value ignored as same name exists\r\n * ```\r\n * @param opts \r\n * @returns {@link MapOfMutable}\r\n */\r\nexport const mapSet = <V>(opts?:MapSetOpts<V>) => {\r\n  const hash = opts?.hash ?? toStringDefault;\r\n  const comparer = (a:V, b:V) => hash(a) === hash(b);\r\n\r\n  const t:MultiValue<V, ReadonlyMap<string, V>> = {\r\n    get name()  {\r\n      return `set`;\r\n    },\r\n    add:(dest, values) => addUniqueByHash(dest, hash, ...values),\r\n    count: (source) => source.size,\r\n    find: (source, predicate) => mapFind(source, predicate),\r\n    filter: (source, predicate) => mapFilter(source, predicate),\r\n    toArray: (source) => mapToArray(source),\r\n    has: (source, value) => mapHasAnyValue(source, value, comparer),\r\n    without: (source, value) => without(mapToArray(source), value, comparer)\r\n  };\r\n  const m = new MapOfMutableImpl<V, ReadonlyMap<string, V>>(t, opts);\r\n  return m;\r\n};\r\n\r\n/**\r\n * Returns a {@link MapOfMutable} that uses a {@link CircularArray} to hold values.\r\n * This means that the number of values stored under each key will be limited to the defined\r\n * capacity.\r\n * \r\n * Requires options: { capacity: number}\r\n * \r\n * @example Only storing the newest three items per key\r\n * ```js\r\n * const map = mapCircular({capacity: 3});\r\n * map.add(`hello`, [1, 2, 3, 4, 5]);\r\n * const hello = map.get(`hello`); // [3, 4, 5]\r\n * ```\r\n * @param opts \r\n * @returns\r\n */\r\nexport const mapCircular = <V>(opts:MapCircularOpts<V>):MapOfMutable<V, CircularArray<V>> => {\r\n  const comparer = isEqualDefault;\r\n  \r\n  const t:MultiValue<V, CircularArray<V>> = {\r\n    get name()  {\r\n      return `circular`;\r\n    },\r\n    add:(dest, values) => {\r\n      if (dest === undefined) dest = circularArray<V>(opts.capacity);\r\n      values.forEach(v => dest = dest?.add(v));\r\n      return dest;\r\n    },\r\n    count: (source) => source.length,\r\n    find: (source, predicate) => source.find(predicate),\r\n    filter: (source, predicate) => source.filter(predicate),\r\n    toArray: (source) => source,\r\n    has: (source, value) => source.find(v => comparer(v, value)) !== undefined,\r\n    without: (source, value) => source.filter(v => !comparer(v, value))\r\n  };\r\n  return new MapOfMutableImpl<V, CircularArray<V>>(t, opts);\r\n};\r\n","// ✔ Unit tested!\r\nimport {DiscardPolicy, Stack} from \"./Interfaces.js\";\r\nimport {StackMutable} from './Interfaces.js';\r\n\r\nexport type StackOpts = {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  readonly discardPolicy?: DiscardPolicy\r\n}\r\n\r\nconst trimStack = <V>(opts: StackOpts, stack: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = stack.length + toAdd.length;\r\n  const policy = opts.discardPolicy ?? `additions`;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);\r\n\r\n  switch (policy) {\r\n  case `additions`:\r\n    if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (stack.length === opts.capacity) {\r\n      return stack; // Completely full\r\n    } else {\r\n      // Only add some from the new array\r\n      return [...stack, ...toAdd.slice(0, toAdd.length-toRemove)];\r\n    }\r\n  case `newer`:\r\n    if (toRemove >= stack.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old (from 0)\r\n      if (opts.debug) console.log(` from orig: ${stack.slice(0, toRemove-1)}`);\r\n      return [...stack.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  case `older`:\r\n    // Oldest item in stack is position 0\r\n    return [...stack, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown discard policy ${policy}`);\r\n  }\r\n};\r\n\r\n// Add to top (last index)\r\nconst push = <V>(opts: StackOpts, stack: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\r\n  //const mutated = [...stack, ...toAdd];\r\n  const potentialLength = stack.length + toAdd.length;\r\n\r\n  const overSize = (opts.capacity && potentialLength > opts.capacity);\r\n  const toReturn  = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];\r\n  return toReturn;\r\n};\r\n\r\n// Remove from top (last index)\r\nconst pop = <V>(opts: StackOpts, stack: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (stack.length === 0) throw new Error(`Stack is empty`);\r\n  return stack.slice(0, stack.length - 1);\r\n};\r\n\r\n/**\r\n * Peek at the top of the stack (end of array)\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {V[]} stack\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: StackOpts, stack: ReadonlyArray<V>): V | undefined => stack[stack.length - 1];\r\n\r\nconst isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => stack.length === 0;\r\n\r\nconst isFull = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return stack.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------\r\n// Immutable\r\n// -------------------------\r\nclass StackImpl<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): Stack<V> {\r\n    return new StackImpl<V>(this.opts, push(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  pop(): Stack<V> {\r\n    return new StackImpl<V>(this.opts, pop(this.opts, this.data));\r\n  }\r\n\r\n  forEach(fn:(v:V) => void): void {\r\n    this.data.forEach(fn);\r\n  }\r\n\r\n  forEachFromTop(fn:(v:V) => void): void {\r\n    [...this.data].reverse().forEach(fn);\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n// -------------------------\r\n// Mutable\r\n// -------------------------\r\nclass StackMutableImpl<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = push(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  forEach(fn:(v:V) => void): void {\r\n    this.data.forEach(fn);\r\n  }\r\n\r\n  forEachFromTop(fn:(v:V) => void): void {\r\n    [...this.data].reverse().forEach(fn);\r\n  }\r\n\r\n  pop(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    pop(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns stack (immutable). Use {@link stackMutable} for a mutable one.\r\n * @example\r\n * ```js\r\n * let s = stack();\r\n * s = s.push(1, 2, 3, 4);\r\n * s.peek; // 4\r\n * s = s.pop();\r\n * s.peek; // 3\r\n * ```\r\n * @template V\r\n * @param {StackOpts} [opts={}]\r\n * @param {...V[]} startingItems\r\n * @returns {Stack<V>}\r\n */\r\nexport const stack = <V>(opts: StackOpts = {}, ...startingItems: ReadonlyArray<V>): Stack<V> => new StackImpl({...opts}, [...startingItems]);\r\n\r\n\r\n/**\r\n * Creates a stack (mutable). Use {@link stack} for an immutable one.\r\n * \r\n * @example\r\n * ```js\r\n * const s = stackMutable();\r\n * s.push(1, 2, 3, 4);\r\n * s.peek;  // 4\r\n * s.pop;   // 4\r\n * s.peek;  // 3\r\n * ```\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {...V[]} startingItems\r\n * @returns\r\n */\r\nexport const stackMutable = <V>(opts: StackOpts, ...startingItems: ReadonlyArray<V>):StackMutable<V> =>  new StackMutableImpl({...opts}, [...startingItems]);","// ✔ UNIT TESTED\r\n\r\nimport {QueueMutable, Queue, DiscardPolicy} from \"./Interfaces.js\";\r\n\r\n/**\r\n * Queue options.\r\n * \r\n * @example Cap size to 5 items, throwing away newest items already in queue.\r\n * ```js\r\n * const q = queue({capacity: 5, discardPolicy: `newer`});\r\n * ```\r\n */\r\nexport type QueueOpts =  {\r\n  /**\r\n   * @private\r\n   */\r\n  readonly debug?:boolean\r\n  /**\r\n   * Capcity limit\r\n   */\r\n  readonly capacity?: number\r\n  /**\r\n   * Default is `additions`, meaning new items are discarded.\r\n   * \r\n   * `older`: Removes items front of the queue (ie older items are discarded)\r\n   * \r\n   * `newer`: Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   * \r\n   * `additions`: Only adds new items that there are room for (ie. brand new items are discarded)\r\n   *\r\n   */\r\n  readonly discardPolicy?: DiscardPolicy\r\n}\r\n\r\nconst debug = (opts: QueueOpts, msg:string):void => {\r\n  /* eslint-disable-next-line functional/no-expression-statement */\r\n  opts.debug ? console.log(`queue:${msg}`) : null;\r\n};\r\n\r\nconst trimQueue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = queue.length + toAdd.length;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  const policy = opts.discardPolicy ?? `additions`;\r\n  debug(opts, `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);\r\n \r\n  switch (policy) {\r\n  // Only add what we can from toAdd\r\n  case `additions`:\r\n    debug(opts, `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (queue.length === opts.capacity) {\r\n      return queue; // Completely full\r\n    } else {\r\n      // Only add some from the new array (from the front)  \r\n      return [...queue, ...toAdd.slice(0, toRemove-1)];\r\n    }\r\n  // Remove from rear of queue (last index) before adding new things\r\n  case `newer`:\r\n    if (toRemove >= queue.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old\r\n      const toAddFinal = toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1));\r\n      const toKeep =  queue.slice(0, queue.length-toRemove);\r\n      debug(opts, `trimQueue: toRemove: ${toRemove} keeping: ${JSON.stringify(toKeep)} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(toAddFinal)}`);\r\n      const t=  [...toKeep, ...toAddFinal];    \r\n      debug(opts, `final: ${JSON.stringify(t)}`);\r\n      return t;\r\n    }\r\n  // Remove from the front of the queue (0 index). ie. older items are discarded\r\n  case `older`:\r\n    // If queue is A, B and toAdd is C, D this yields A, B, C, D\r\n    return [...queue, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Adds to the back of the queue (last array index)\r\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @param {...V[]} toAdd\r\n * @returns {V[]}\r\n */\r\nconst enqueue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n\r\n  const potentialLength = queue.length + toAdd.length;\r\n  const overSize = opts.capacity && potentialLength > opts.capacity;\r\n\r\n  const toReturn = overSize ? trimQueue(opts, queue, toAdd) : [...queue, ...toAdd];\r\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\r\n  if (!opts.capacity && toReturn.length !== potentialLength) throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\r\n  \r\n  return toReturn;\r\n};\r\n\r\n// Remove from front of queue (0 index)\r\nconst dequeue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (queue.length === 0) throw new Error(`Queue is empty`);\r\n  return queue.slice(1);\r\n};\r\n\r\n/**\r\n * Returns front of queue (oldest item), or undefined if queue is empty\r\n *\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): V | undefined => queue[0];\r\n\r\nconst isEmpty = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean => queue.length === 0;\r\n\r\nconst isFull = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return queue.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------------\r\n// Immutable\r\n// -------------------------------\r\nclass QueueImpl<V> {\r\n  readonly opts: QueueOpts;\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  /**\r\n   * Creates an instance of Queue.\r\n   * @param {QueueOpts} opts Options foor queue\r\n   * @param {V[]} data Initial data. Index 0 is front of queue\r\n   * @memberof Queue\r\n   */\r\n  constructor(opts: QueueOpts, data: ReadonlyArray<V>) {\r\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  forEach(fn:(v:V) => void) {\r\n    //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let i=this.data.length-1; i>=0; i--) {\r\n      fn(this.data[i]);\r\n    }  \r\n  }\r\n\r\n  forEachFromFront(fn:(v:V) => void) {\r\n    // From front of queue\r\n    this.data.forEach(vv => fn(vv));\r\n  }\r\n\r\n  enqueue(...toAdd: ReadonlyArray<V>): QueueImpl<V> {\r\n    return new QueueImpl<V>(this.opts, enqueue(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  dequeue(): QueueImpl<V> {\r\n    return new QueueImpl<V>(this.opts, dequeue(this.opts, this.data));\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n// -------------------------------\r\n// Mutable\r\n// -------------------------------\r\nclass QueueMutableImpl<V> implements QueueMutable<V> {\r\n  readonly opts: QueueOpts;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts:QueueOpts, data:ReadonlyArray<V>) {\r\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = enqueue(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  dequeue(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = dequeue(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\r\n * items differently. _Enqueing_ adds items at the back of the queue, while\r\n * _dequeing_ removes items from the front (ie. the oldest).\r\n *\r\n * ```js\r\n * let q = queue();           // Create\r\n * q = q.enqueue(`a`, `b`);   // Add two strings\r\n * const front = q.peek();    // `a` is at the front of queue (oldest)\r\n * q = q.dequeue();           // q now just consists of `b`  \r\n * ```\r\n * @example Cap size to 5 items, throwing away newest items already in queue.\r\n * ```js\r\n * const q = queue({capacity: 5, discardPolicy: `newer`});\r\n * ```\r\n * \r\n * @template V Data type of items\r\n * @param opts\r\n * @param startingItems Index 0 is the front of the queue\r\n * @returns A new queue\r\n */\r\nexport const queue = <V>(opts: QueueOpts = {}, ...startingItems: ReadonlyArray<V>): Queue<V> => {\r\n  opts = {...opts}; // Make a copy of options\r\n  return new QueueImpl(opts, [...startingItems]); // Make a copy of array so it can't be modified\r\n};\r\n\r\n/**\r\n * Returns a mutable queue. Queues are useful if you want to treat 'older' or 'newer'\r\n * items differently. _Enqueing_ adds items at the back of the queue, while\r\n * _dequeing_ removes items from the front (ie. the oldest).\r\n * \r\n * ```js\r\n * const q = queue();       // Create\r\n * q.enqueue(`a`, `b`);     // Add two strings\r\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\r\n * ```\r\n *\r\n * @example Cap size to 5 items, throwing away newest items already in queue.\r\n * ```js\r\n * const q = queue({capacity: 5, discardPolicy: `newer`});\r\n * ```\r\n * \r\n * @template V Data type of items\r\n * @param opts\r\n * @param startingItems Items are added in array order. So first item will be at the front of the queue.\r\n */\r\nexport const queueMutable = <V>(opts: QueueOpts = {}, ...startingItems: ReadonlyArray<V>): QueueMutable<V> => new QueueMutableImpl({...opts}, [...startingItems]);","\r\nimport {ArrayKeys, EitherKey, ObjKeys, MapImmutable } from \"./Interfaces\";\r\n\r\n/**\r\n * Adds an array o [k,v] to the map, returning a new instance\r\n * @param map Initial data\r\n * @param data Data to add\r\n * @returns New map with data added\r\n */\r\nconst addArray = <K, V>(map: ReadonlyMap<K, V>, data:ArrayKeys<K, V>): ReadonlyMap<K, V> => {\r\n  const x = new Map<K, V>(map.entries());\r\n  data.forEach(d => {\r\n    if (d[0] === undefined) throw new Error(`key cannot be undefined`);\r\n    if (d[1] === undefined) throw new Error(`value cannot be undefined`);\r\n    x.set(d[0], d[1]);\r\n  });\r\n  return x;\r\n};\r\n\r\n/**\r\n * Adds objects to the map, returning a new instance\r\n * @param map Initial data\r\n * @param data Data to add\r\n * @returns A new map with data added\r\n */\r\nconst addObjects = <K, V>(map: ReadonlyMap<K, V>, data:ObjKeys<K, V>): ReadonlyMap<K, V> => {\r\n  const x = new Map<K, V>(map.entries());\r\n  data.forEach(d => {\r\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\r\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\r\n\r\n    x.set(d.key, d.value);\r\n  });\r\n  return x;\r\n};\r\n\r\n/**\r\n * Returns true if map contains key\r\n * \r\n * @example\r\n * ```js\r\n * if (has(map, `London`)) ...\r\n * ```\r\n * @param map Map to search\r\n * @param key Key to find\r\n * @returns True if map contains key\r\n */\r\nexport const has = <K, V>(map: ReadonlyMap<K, V>, key: K): boolean => map.has(key);\r\n\r\n/**\r\n * Adds data to a map, returning the new map.\r\n * \r\n * Can add items in the form of [key,value] or {key, value}.\r\n * @example These all produce the same result\r\n * ```js\r\n * map.set(`hello`, `samantha`);\r\n * map.add([`hello`, `samantha`]);\r\n * map.add({key: `hello`, value: `samantha`})\r\n * ```\r\n * @param map Initial data\r\n * @param data One or more data to add in the form of [key,value] or {key, value} \r\n * @returns New map with data added\r\n */\r\nexport const add = <K, V>(map: ReadonlyMap<K, V>, ...data:EitherKey<K, V>): ReadonlyMap<K, V> => {\r\n  if (map === undefined) throw new Error(`map parameter is undefined`);\r\n  if (data === undefined) throw new Error(`data parameter i.s undefined`);\r\n  if (data.length === 0) return map;\r\n\r\n  const firstRecord = data[0];\r\n  const isObj = typeof (firstRecord as {readonly key:K, readonly value:V}).key !== `undefined` && typeof (firstRecord as {readonly key:K, readonly value:V}).value !== `undefined`;  //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\r\n  return isObj ? addObjects(map, data as ObjKeys<K, V>) : addArray(map, data as ArrayKeys<K, V>);\r\n};\r\n\r\n/**\r\n * Sets data in a copy of the initial map\r\n * @param map Initial map\r\n * @param key Key\r\n * @param value Value to  set\r\n * @returns New map with data set\r\n */\r\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key:K, value:V) => {\r\n  const x = new Map<K, V>(map.entries());\r\n  x.set(key, value);\r\n  return x;\r\n};\r\n\r\n/**\r\n * Delete a key from the map, returning a new map\r\n * @param map Initial data\r\n * @param key \r\n * @returns New map with data deleted\r\n */\r\nexport const del = <K, V>(map: ReadonlyMap<K, V>, key: K): ReadonlyMap<K, V> => {\r\n  const x = new Map<K, V>(map.entries());\r\n  x.delete(key);\r\n  return x;\r\n};\r\n\r\n/**\r\n * Returns an {@link MapImmutable}.\r\n * Use {@link mapMutable} as an alternatve.\r\n * \r\n * @param dataOrMap Optional initial data in the form of an array of {key:value} or [key,value]\r\n * @returns {@link MapImmutable}\r\n */\r\nexport const map = <K, V>(dataOrMap?: ReadonlyMap<K, V>|EitherKey<K, V>):MapImmutable<K, V> => {\r\n  if (dataOrMap === undefined) return map([]);\r\n  if (Array.isArray(dataOrMap)) return map(add(new Map(), ...dataOrMap));\r\n  const data = dataOrMap as ReadonlyMap<K, V>;\r\n  return {\r\n    add: (...itemsToAdd:EitherKey<K, V>) => {\r\n      const s = add(data, ...itemsToAdd);\r\n      return map(s);\r\n    },\r\n    get: (key:K) => data.get(key),\r\n    delete: (key:K) => map(del(data, key)),\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    clear: () => map(),\r\n    has: (key:K) => data.has(key),\r\n    entries: () => data.entries(),\r\n    isEmpty: () => data.size === 0\r\n  };\r\n};","import {add, del, set, has} from './MapImmutable.js';\r\nimport { EitherKey, MapMutable } from \"./Interfaces\";\r\n\r\n/**\r\n * Returns a {@link MapMutable} (which just wraps the in-built Map)\r\n * Use {@link map} for the immutable alternative.\r\n * \r\n * @param data Optional initial data in the form of an array of {key:value} or [key,value]\r\n * @returns {@link MapMutable}\r\n */\r\nexport const mapMutable = <K, V>(...data: EitherKey<K, V>): MapMutable<K, V> => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let m = add(new Map<K, V>(), ...data);\r\n  return {\r\n    add: (...data: EitherKey<K, V>) => {\r\n      m = add(m, ...data);\r\n    },\r\n    delete: (key: K) => {\r\n      m = del(m, key);\r\n    },\r\n    clear: () => {\r\n      m = add(new Map<K, V>());\r\n    },\r\n    set: (key: K, value: V): void => {\r\n      m = set(m, key, value);\r\n    },\r\n    get: (key: K): V | undefined => m.get(key),\r\n    entries: () => m.entries(),\r\n    isEmpty: () => m.size === 0,\r\n    has: (key: K) => has(m, key)\r\n  };\r\n};"],"mappings":"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","names":[]}