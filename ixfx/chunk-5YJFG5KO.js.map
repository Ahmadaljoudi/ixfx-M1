{"version":3,"sources":["../src/Util.ts"],"sourcesContent":["import { number as guardNumber} from \"./Guards.js\";\r\n\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * @example Usage\r\n * ```js\r\n * // 0.5 - just fine, within default of 0 to 1\r\n * clamp(0.5);         \r\n * // 1 - above default max of 1\r\n * clamp(1.5);         \r\n * // 0 - below range\r\n * clamp(-50, 0, 100); \r\n * // 50 - within range\r\n * clamp(50, 0, 50);   \r\n * ```\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * \r\n * @param v Value to clamp\r\n * @param Minimum value (inclusive)\r\n * @param Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Scales `v` from an input range to an output range (aka `map`)\r\n * \r\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\r\n * ```js\r\n * scale(sensorReading, 100, 500, 0, 1);\r\n * ```\r\n * \r\n * `scale` defaults to a percentage-range output, so you can get away with:\r\n * ```js\r\n * scale(sensorReading, 100, 500);\r\n * ```\r\n * \r\n * If inMin and inMax are equal, outMax will be returned.\r\n * @param v Value to scale\r\n * @param inMin Input minimum\r\n * @param inMax Input maximum\r\n * @param outMin Output minimum. If not specified, 0\r\n * @param outMax Output maximum. If not specified, 1.\r\n * @returns Scaled value\r\n */\r\nexport const scale = (\r\n  v:number, \r\n  inMin:number, inMax:number, \r\n  outMin?:number, outMax?:number\r\n):number => {\r\n  if (outMax === undefined) outMax = 1;\r\n  if (outMin === undefined) outMin = 0;\r\n  if (inMin === inMax) return outMax;\r\n  //console.log(`v: ${v} in: ${inMin}-${inMax} out: ${outMin}-${outMax}`);\r\n  return (v - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\r\n};\r\n\r\n/**\r\n * Scales an input percentage to a new percentage range.\r\n * \r\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\r\n * _output_ percentage of `outMin`-`outMax`.\r\n * \r\n * ```js\r\n * // Scales 50% to a range of 0-10%\r\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\r\n * ```\r\n * \r\n * An error is thrown if any parameter is outside of percentage range. This added\r\n * safety is useful for catching bugs. Otherwise, you could just as well call\r\n * `scale(percentage, 0, 1, outMin, outMax)`.\r\n * \r\n * If you want to scale some input range to percentage output range, just use `scale`:\r\n * ```js\r\n * // Yields 0.5\r\n * scale(2.5, 0, 5);\r\n * ```\r\n * @param percentage Input value, within percentage range\r\n * @param outMin Output minimum, between 0-1\r\n * @param outMax Output maximum, between 0-1\r\n * @returns Scaled value between outMin-outMax.\r\n */\r\nexport const scalePercentages = (percentage:number, outMin:number, outMax:number = 1):number => {\r\n  guardNumber(percentage, `percentage`, `v`);\r\n  guardNumber(outMin, `percentage`, `outMin`);\r\n  guardNumber(outMax, `percentage`, `outMax`);\r\n  return scale(percentage, 0, 1, outMin, outMax);\r\n};\r\n\r\n/**\r\n * Scales an input percentage value to an output range\r\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\r\n * ```js\r\n * scalePercent(0.5, 10, 20); // 15\r\n * ```\r\n * \r\n * @param v Value to scale\r\n * @param outMin Minimum for output\r\n * @param outMax Maximum for output\r\n * @returns \r\n */\r\nexport const scalePercent = (v:number, outMin:number, outMax:number):number => {\r\n  guardNumber(v, `percentage`, `v`);\r\n  return scale(v, 0, 1, outMin, outMax);\r\n};\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\r\n * Returns value then will always be at least zero, and a valid array index.\r\n * \r\n * @example Usage\r\n * ```js\r\n * // Array of length 4\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampIndex(0, myArray);    // 0\r\n * clampIndex(4, myArray);    // 3\r\n * clampIndex(-1, myArray);   // 0\r\n * \r\n * clampIndex(5, 3); // 2\r\n * ```\r\n * \r\n * Throws an error if `v` is not an integer.\r\n * @param v Value to clamp (must be an interger)\r\n * @param arrayOrLength Array, or length of bounds (must be an integer)\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const clampIndex = (v: number, arrayOrLength: number|readonly any[]):number => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  const length = (Array.isArray(arrayOrLength)) ?  arrayOrLength.length : arrayOrLength as number;\r\n\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\r\n * \r\n * @example Get the halfway point between 30 and 60\r\n * ```js\r\n * interpolate(0.5, 30, 60);\r\n * ```\r\n * \r\n * Interpolation is often used for animation. In that case, `amount`\r\n * would start at 0 and you would keep interpolating up to `1`\r\n * @example\r\n * ```js\r\n * // Go back and forth between 0 and 1 by 0.1\r\n * let pp = percentPingPong(0.1);\r\n * continuously(() => {\r\n *  // Get position in ping-pong\r\n *  const amt = pp.next().value;\r\n *  // interpolate between Math.PI and Math.PI*2\r\n *  const v = interpolate(amt, Math.PI, Math.PI*2); \r\n *  // do something with v...\r\n * }).start();\r\n * ```\r\n * \r\n * See also {@link Colour.interpolate}, {@link Points.interpolate}.\r\n * @param amount Interpolation amount, between 0 and 1 inclusive\r\n * @param a Start (ie when `amt` is 0)\r\n * @param b End (ie. when `amt` is 1)\r\n * @returns Interpolated value which will be betewen `a` and `b`.\r\n */\r\nexport const interpolate =(amount:number, a:number, b:number):number => {\r\n  const v = (1-amount) * a + amount * b;\r\n  return v;\r\n};\r\n\r\n\r\n/**\r\n * @private\r\n */\r\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\r\n\r\n/**\r\n * @private\r\n */\r\nexport type IsEqual<V> = (a:V, b:V) => boolean;\r\n\r\n/**\r\n * Default comparer function is equiv to checking `a === b`\r\n * @private\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqualDefault = <V>(a:V, b:V):boolean => a === b;\r\n\r\n/**\r\n * Comparer returns true if string representation of `a` and `b` are equal.\r\n * Uses `toStringDefault` to generate a string representation (`JSON.stringify`)\r\n * @private\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean} True if the contents of `a` and `b` are equal\r\n */\r\nexport const isEqualValueDefault = <V>(a:V, b:V):boolean => {\r\n  // ✔ UNIT TESTED\r\n  if (a === b) return true; // Object references are the same, or string values are the same\r\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\r\n};\r\n\r\n/**\r\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\r\n * @private\r\n * @template V\r\n * @param {V} itemToMakeStringFor\r\n * @returns {string}\r\n */\r\nexport const toStringDefault = <V>(itemToMakeStringFor:V):string => ((typeof itemToMakeStringFor === `string`) ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor));\r\n\r\n/**\r\n * Wraps a number within a specified range, defaulting to degrees (0-360)\r\n * \r\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\r\n * Eg: to add 200 to 200, we don't want 400, but 40. \r\n * ```js\r\n * const v = wrap(200+200, 0, 360); // 40\r\n * ```\r\n * \r\n * Or if we minus 100 from 10, we don't want -90 but 270\r\n * ```js\r\n * const v = wrap(10-100, 0, 360); // 270\r\n * ```\r\n * \r\n * `wrap` uses 0-360 as a default range, so both of these\r\n * examples could just as well be:\r\n * \r\n * ```js\r\n * wrap(200+200);  // 40\r\n * wrap(10-100);  // 270\r\n * ```\r\n * \r\n * Non-zero starting points can be used. A range of 20-70: \r\n * ```js\r\n * const v = wrap(-20, 20, 70); // 50 \r\n * ```\r\n * @param v Value to wrap\r\n * @param min Minimum of range (default: 0)\r\n * @param max Maximum of range (default: 360)\r\n * @returns \r\n */\r\nexport const wrap = (v:number, min:number = 0, max:number = 360) => {\r\n  if (v === min) return min;\r\n  if (v === max) return max;\r\n  v -= min; \r\n  max -= min;\r\n  v = v%max; \r\n  if (v < 0) v = max - Math.abs(v) + min;\r\n  return v + min;\r\n};\r\n\r\n/**\r\n * Performs a calculation within a wrapping number range. This is a lower-level function.\r\n * See also: {@link wrap} for simple wrapping within a range.\r\n * \r\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\r\n * `a` and `b` is the range you want to work in. \r\n * \r\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\r\n * ```js\r\n * wrapRange(0,360, (distance) => {\r\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\r\n *  return distance * 0.5; // eg return middle point \r\n * }, 30, 330);\r\n * ```\r\n * \r\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\r\n * conform it to the `min` and `max` range before it's returned to the caller.\r\n * \r\n * @param a Output start (eg. 60)\r\n * @param b Output end (eg 300)\r\n * @param min Range start (eg 0)\r\n * @param max Range end (eg 360)\r\n * @param fn Returns a computed value from 0 to `distance`.\r\n * @returns \r\n */\r\nexport const wrapRange = (min:number, max:number, fn:(distance:number)=>number, a:number, b:number) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let r = 0;\r\n  // No wrapping\r\n  const distF = Math.abs(b - a);\r\n  // When b is wrapped forwards\r\n  const distFwrap = Math.abs(max-a + b);\r\n  // When b is wrapped backwards (10, 300)\r\n  const distBWrap = Math.abs(a + (360-b));\r\n  \r\n  const distMin = Math.min(distF, distFwrap, distBWrap);\r\n  if (distMin === distBWrap) {\r\n    // (10, 300) = 70\r\n    r = a - fn(distMin);\r\n  } else if (distMin === distFwrap) {\r\n    // (300, 60) = 120\r\n    r = a + fn(distMin);\r\n  } else {\r\n    // Forwards or backwards without wrapping\r\n    if (a > b) {\r\n      // (240,120) -- backwards\r\n      r = a - fn(distMin);\r\n    } else {\r\n      // (120,240) -- forwards\r\n      r = a + fn(distMin);\r\n    }\r\n  }\r\n  return wrap(r, min, max); \r\n};\r\n"],"mappings":";;;;;AAyBO,IAAM,QAAQ,CAAC,GAAW,MAAM,GAAG,MAAM,MAAM;AAEpD,MAAI,OAAO,MAAM,CAAC;AAAG,UAAM,IAAI,MAAM,oBAAoB;AACzD,MAAI,OAAO,MAAM,GAAG;AAAG,UAAM,IAAI,MAAM,sBAAsB;AAC7D,MAAI,OAAO,MAAM,GAAG;AAAG,UAAM,IAAI,MAAM,sBAAsB;AAE7D,MAAI,IAAI;AAAK,WAAO;AACpB,MAAI,IAAI;AAAK,WAAO;AACpB,SAAO;AACT;AAuBO,IAAM,QAAQ,CACnB,GACA,OAAc,OACd,QAAgB,WACN;AACV,MAAI,WAAW;AAAW,aAAS;AACnC,MAAI,WAAW;AAAW,aAAS;AACnC,MAAI,UAAU;AAAO,WAAO;AAE5B,SAAQ,KAAI,SAAU,UAAS,UAAW,SAAQ,SAAS;AAC7D;AA2BO,IAAM,mBAAmB,CAAC,YAAmB,QAAe,SAAgB,MAAa;AAC9F,SAAY,YAAY,cAAc,GAAG;AACzC,SAAY,QAAQ,cAAc,QAAQ;AAC1C,SAAY,QAAQ,cAAc,QAAQ;AAC1C,SAAO,MAAM,YAAY,GAAG,GAAG,QAAQ,MAAM;AAC/C;AAcO,IAAM,eAAe,CAAC,GAAU,QAAe,WAAyB;AAC7E,SAAY,GAAG,cAAc,GAAG;AAChC,SAAO,MAAM,GAAG,GAAG,GAAG,QAAQ,MAAM;AACtC;AAuBO,IAAM,aAAa,CAAC,GAAW,kBAAgD;AAEpF,MAAI,CAAC,OAAO,UAAU,CAAC;AAAG,UAAM,IAAI,MAAM,mCAAmC,IAAI;AACjF,QAAM,SAAU,MAAM,QAAQ,aAAa,IAAM,cAAc,SAAS;AAExE,MAAI,CAAC,OAAO,UAAU,MAAM;AAAG,UAAM,IAAI,MAAM,wCAAwC,WAAW,OAAO,SAAS;AAClH,MAAI,KAAK,MAAM,CAAC;AAChB,MAAI,IAAI;AAAG,WAAO;AAClB,MAAI,KAAK;AAAQ,WAAO,SAAS;AACjC,SAAO;AACT;AA+BO,IAAM,cAAa,CAAC,QAAe,GAAU,MAAoB;AACtE,QAAM,IAAK,KAAE,UAAU,IAAI,SAAS;AACpC,SAAO;AACT;AAqBO,IAAM,iBAAiB,CAAI,GAAK,MAAgB,MAAM;AAWtD,IAAM,sBAAsB,CAAI,GAAK,MAAgB;AAE1D,MAAI,MAAM;AAAG,WAAO;AACpB,SAAO,gBAAgB,CAAC,MAAM,gBAAgB,CAAC;AACjD;AASO,IAAM,kBAAkB,CAAI,wBAAmC,OAAO,wBAAwB,WAAY,sBAAsB,KAAK,UAAU,mBAAmB;AAiClK,IAAM,OAAO,CAAC,GAAU,MAAa,GAAG,MAAa,QAAQ;AAClE,MAAI,MAAM;AAAK,WAAO;AACtB,MAAI,MAAM;AAAK,WAAO;AACtB,OAAK;AACL,SAAO;AACP,MAAI,IAAE;AACN,MAAI,IAAI;AAAG,QAAI,MAAM,KAAK,IAAI,CAAC,IAAI;AACnC,SAAO,IAAI;AACb;AA2BO,IAAM,YAAY,CAAC,KAAY,KAAY,IAA8B,GAAU,MAAa;AAErG,MAAI,IAAI;AAER,QAAM,QAAQ,KAAK,IAAI,IAAI,CAAC;AAE5B,QAAM,YAAY,KAAK,IAAI,MAAI,IAAI,CAAC;AAEpC,QAAM,YAAY,KAAK,IAAI,IAAK,OAAI,EAAE;AAEtC,QAAM,UAAU,KAAK,IAAI,OAAO,WAAW,SAAS;AACpD,MAAI,YAAY,WAAW;AAEzB,QAAI,IAAI,GAAG,OAAO;AAAA,EACpB,WAAW,YAAY,WAAW;AAEhC,QAAI,IAAI,GAAG,OAAO;AAAA,EACpB,OAAO;AAEL,QAAI,IAAI,GAAG;AAET,UAAI,IAAI,GAAG,OAAO;AAAA,IACpB,OAAO;AAEL,UAAI,IAAI,GAAG,OAAO;AAAA,IACpB;AAAA,EACF;AACA,SAAO,KAAK,GAAG,KAAK,GAAG;AACzB;","names":[]}