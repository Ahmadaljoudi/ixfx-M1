{"version":3,"sources":["../src/modulation/index.ts","../src/modulation/Envelope.ts","../src/modulation/Oscillator.ts"],"sourcesContent":["import {clamp} from '~/Util.js';\r\nimport {number as guardNumber} from '../Guards.js';\r\n\r\n/**\r\n * Easings module\r\n * \r\n * Overview:\r\n * * {@link Easings.time} - Ease by time\r\n * * {@link Easings.tick} - Ease by tick\r\n * * {@link Easings.get}  - Get an easing function by name\r\n */\r\nexport * as Easings from './Easing.js';\r\n\r\n/**\r\n * Envelope\r\n */\r\nexport * from './Envelope.js';\r\n\r\n/**\r\n * Oscillator\r\n */\r\nexport * as Oscillators from './Oscillator.js';\r\n\r\nexport type RandomSource = () => number;\r\n\r\nexport type JitterOpts = {\r\n  readonly type?: `rel`|`abs`,\r\n  readonly clamped?: boolean\r\n}\r\n\r\nexport const defaultRandom = Math.random;\r\n\r\n/**\r\n * Jitters `value` by the absolute `jitter` amount.\r\n * All values should be on a 0..1 scale, and return value by default clamped to 0..1\r\n * \r\n * ```js\r\n * // Jitter 0.5 by 10% (absolute)\r\n * // yields range of 0.4-0.6\r\n * jitter(0.5, 0.1);\r\n * \r\n * // Jitter 0.5 by 10% (relative)\r\n * // yields range of 0.45-0.55\r\n * jitter(0.5, 0.1, {type:`rel`});\r\n * ```\r\n * \r\n * You can also opt not to clamp values:\r\n * ```js\r\n * // Yields range of -1.5 - 1.5\r\n * jitter(0.5, 1, {clamped:false});\r\n * ```\r\n * \r\n * A custom source for random numbers can be provided. Eg, use a weighted\r\n * random number generator:\r\n * \r\n * ```js\r\n * import {weighted} from 'https://unpkg.com/ixfx/dist/random.js';\r\n * jitter(0.5, 0.1, {}, weighted);\r\n * ```\r\n * @param value Value to jitter\r\n * @param jitter Absolute amount to jitter by\r\n * @param opts Jitter options\r\n * @param rand Source of random numbers, Math.random by default.\r\n * @returns Jittered value on 0..1 scale\r\n */\r\nexport const jitter = (value:number, jitter:number, opts:JitterOpts = {}, rand:RandomSource = defaultRandom) => {\r\n  guardNumber(value, `percentage`, `value`);\r\n  guardNumber(jitter, `percentage`, `jitter`);\r\n\r\n  const type = opts.type ?? `abs`;\r\n  const clamped = opts.clamped ?? true;\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let v:number;\r\n  if (type === `rel`) {\r\n    jitter = value * jitter;\r\n    const j = jitter * 2 * rand();\r\n    v = value - jitter + j;\r\n  } else if (type === `abs`) {\r\n    const j = jitter * 2 * rand();\r\n    v = value - jitter + j;\r\n  } else {\r\n    throw new Error(`Unknown jitter type: ${type}.`);\r\n  }\r\n  if (clamped) return clamp(v);\r\n  return v;\r\n};","import {SimpleEventEmitter} from \"../Events.js\";\r\nimport { msElapsedTimer, TimerSource} from \"../flow/Timer.js\";\r\nimport { Timer } from \"../flow/Timer.js\";\r\nimport { StateMachine } from \"../flow/StateMachine.js\";\r\nimport {Path} from \"~/geometry/Path.js\";\r\nimport * as Bezier from '../geometry/Bezier.js';\r\nimport {scale} from \"../Util.js\";\r\n\r\n/**\r\n * @returns Returns a full set of default ADSR options\r\n */\r\nexport const defaultAdsrOpts = ():EnvelopeOpts => ({\r\n  attackBend: -1,\r\n  decayBend: -.3,\r\n  releaseBend: -.3,\r\n  peakLevel: 1,\r\n  initialLevel: 0,\r\n  sustainLevel: 0.6,\r\n  releaseLevel: 0,\r\n  attackDuration: 600,\r\n  decayDuration: 200,\r\n  releaseDuration: 800,\r\n  shouldLoop: false\r\n});\r\n\r\nexport type EnvelopeOpts = AdsrOpts & AdsrTimingOpts;\r\n/**\r\n * Options for the ADSR envelope. \r\n * \r\n * Use {@link defaultAdsrOpts} to get an initial default:\r\n * @example\r\n * ```js\r\n * let env = adsr({\r\n *  ...defaultAdsrOpts(),\r\n *  attackDuration: 2000,\r\n *  releaseDuration: 5000,\r\n *  sustainLevel: 1,\r\n *  retrigger: false\r\n * });\r\n * ```\r\n */\r\nexport type AdsrOpts = {\r\n  /**\r\n   * Attack bezier 'bend'. Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly attackBend: number\r\n  /**\r\n   * Decay bezier 'bend'. Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly decayBend: number\r\n  /**\r\n   * Release bezier 'bend'. Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly releaseBend: number\r\n\r\n   /**\r\n    * Peak level (maximum of attack stage)\r\n    */\r\n   readonly peakLevel:number\r\n\r\n  /**\r\n   * Starting level (usually 0)\r\n   */\r\n   readonly initialLevel?:number\r\n/**\r\n * Sustain level. Only valid if trigger and hold happens\r\n */ \r\n   readonly sustainLevel:number\r\n/**\r\n * Release level, when envelope is done (usually 0)\r\n */\r\n   readonly releaseLevel?:number\r\n\r\n  /**\r\n   * When _false_, envelope starts from it's current level when being triggered.\r\n   * _True_ by default.\r\n   */\r\n  readonly retrigger?: boolean\r\n}\r\n\r\nexport type AdsrTimingOpts = {\r\n  /**\r\n   * If true, envelope indefinately returns to attack stage after release\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  readonly shouldLoop: boolean\r\n\r\n  /**\r\n   * Duration for attack stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly attackDuration: number\r\n  /**\r\n   * Duration for decay stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly decayDuration: number\r\n  /**\r\n   * Duration for release stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly releaseDuration: number\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface CompleteEvent { /* no-op */}\r\n\r\ntype Events = {\r\n  readonly change: StateChangeEvent\r\n  readonly complete: CompleteEvent\r\n};\r\n\r\nclass AdsrBase extends SimpleEventEmitter<Events> {\r\n  readonly #sm:StateMachine;\r\n  readonly #timeSource:TimerSource;\r\n  #timer:Timer|undefined;\r\n\r\n  #holding:boolean;\r\n  #holdingInitial:boolean;\r\n\r\n  attackDuration:number;\r\n  decayDuration:number;\r\n  releaseDuration:number;\r\n  decayDurationTotal:number;\r\n  shouldLoop:boolean;\r\n  constructor(opts:AdsrTimingOpts) {\r\n    super();\r\n    \r\n    this.attackDuration = opts.attackDuration ?? 300;\r\n    this.decayDuration = opts.decayDuration ?? 500;\r\n    this.releaseDuration = opts.releaseDuration ?? 1000;\r\n    this.shouldLoop = opts.shouldLoop ?? false;\r\n\r\n    const descr ={\r\n      attack: [`decay`, `release`],\r\n      decay: [`sustain`, `release`],\r\n      sustain: [`release`],\r\n      release: [`complete`],\r\n      complete: null\r\n    };\r\n    \r\n    this.#sm = new StateMachine(`attack`, descr);\r\n    this.#sm.addEventListener(`change`, (ev => {\r\n      // Reset timer on release\r\n      if (ev.newState === `release` && this.#holdingInitial) {\r\n        this.#timer?.reset();\r\n      }\r\n      super.fireEvent(`change`, ev);\r\n    }));\r\n    this.#sm.addEventListener(`stop`, (ev => {\r\n      super.fireEvent(`complete`, ev);\r\n    }));\r\n    \r\n    this.#timeSource = msElapsedTimer;\r\n    this.#holding = this.#holdingInitial = false;\r\n\r\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\r\n  }\r\n\r\n  protected switchState():boolean {\r\n    if (this.#timer === undefined) return false;\r\n    // eslint-disable-next-line functional/no-let\r\n    let elapsed = this.#timer.elapsed;\r\n    const wasHeld = this.#holdingInitial && !this.#holding;\r\n\r\n    // Change through states for as long as needed\r\n    // eslint-disable-next-line functional/no-let\r\n    let hasChanged = false;\r\n    // eslint-disable-next-line functional/no-loop-statement\r\n    do {\r\n      hasChanged = false;\r\n      switch (this.#sm.state) {\r\n      case `attack`:\r\n        // console.log(`switchState - attack ${wasHeld}`);\r\n\r\n        if (elapsed > this.attackDuration || wasHeld) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `decay`:\r\n        // console.log(`switchState - decay ${wasHeld}`);\r\n\r\n        if (elapsed > this.decayDurationTotal || wasHeld) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `sustain`:\r\n        // console.log(`switchState - sustain ${wasHeld}`);\r\n        if (!this.#holding || wasHeld) {\r\n          elapsed = 0;\r\n          this.#sm.next();\r\n          this.#timer?.reset();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `release`:\r\n        // console.log(`switchState - release`);\r\n        if (elapsed > this.releaseDuration) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `complete`:\r\n        if (this.shouldLoop) {\r\n          this.trigger(this.#holdingInitial);\r\n        }\r\n      }\r\n    } while (hasChanged);\r\n    return hasChanged;\r\n  }\r\n\r\n  /**\r\n   * Computes a stage progress from 0-1\r\n   * @param allowStateChange \r\n   * @returns \r\n   */\r\n  protected computeRaw(allowStateChange = true):[stage:string|undefined, amount:number, prevStage:string] {\r\n    if (this.#timer === undefined) return [undefined, 0, this.#sm.state];\r\n  \r\n    // Change state if necessary based on elapsed time\r\n    if (allowStateChange) this.switchState();\r\n    \r\n    const prevStage = this.#sm.state;\r\n\r\n    const elapsed = this.#timer.elapsed;\r\n    // eslint-disable-next-line functional/no-let\r\n    let relative = 0;\r\n    const state = this.#sm.state;\r\n    switch (state) {\r\n    case `attack`:\r\n      relative = elapsed / this.attackDuration;\r\n      break;\r\n    case `decay`:\r\n      relative = (elapsed - this.attackDuration) / this.decayDuration;\r\n      break;\r\n    case `sustain`:\r\n      relative = 1;\r\n      break;\r\n    case `release`:\r\n      relative = Math.min(elapsed / this.releaseDuration, 1);\r\n      break;\r\n    case `complete`:\r\n      return [undefined, 1, prevStage];\r\n    default:\r\n      throw new Error(`State machine in unknown state: ${state}`);\r\n    }\r\n    return [state, relative, prevStage];\r\n  }\r\n\r\n  get isDone():boolean {\r\n    return this.#sm.isDone;\r\n  }\r\n\r\n  onTrigger():void {\r\n    /* no op */\r\n  }\r\n\r\n  trigger(hold:boolean = false) {\r\n    this.onTrigger();\r\n\r\n    this.#sm.reset();\r\n    this.#timer = this.#timeSource();\r\n    this.#holding = hold;\r\n    this.#holdingInitial = hold;\r\n  }\r\n\r\n  compute(): void {\r\n    /* no-op */\r\n  }\r\n\r\n  release() {\r\n    if (this.isDone || !this.#holdingInitial) return; // Was never holding or done\r\n  \r\n    // Setting holding flag to false, computeRaw will change state\r\n    this.#holding = false;\r\n    this.compute();\r\n  }\r\n}\r\n\r\n/**\r\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\r\n * usually in response to an intial trigger.\r\n * \r\n * Created with the {@link adsr} function.\r\n * \r\n * @example Setup\r\n * ```js\r\n * const opts = {\r\n *  ...defaultAdsrOpts(),\r\n *  attackDuration: 1000,\r\n *  decayDuration: 200,\r\n *  sustainDuration: 100\r\n * }\r\n * const env = adsr(opts);\r\n * ```\r\n * \r\n * @example Using\r\n * ```js\r\n * env.trigger(); // Start envelop\r\n * ...\r\n * // Get current value of envelope\r\n * const [state, scaled, raw] = env.compute();\r\n * ```\r\n * \r\n * * `state` is string: `attack`, `decay`, `sustain`, `release`, `complete \r\n * * `scaled` is a value scaled according to stage _levels_\r\n * * `raw` is the progress from 0 to 1 within a stage\r\n * \r\n * ...normally you'd just want:\r\n * ```js\r\n * const value = env.value; // Get scaled \r\n * ```\r\n * \r\n * @example Hold & release\r\n * ```js\r\n * env.trigger(true); // Pass in true to hold\r\n * ...envelope will stop at sustain stage...\r\n * env.relese();      // Release into decay\r\n * ```\r\n * \r\n * Check if it's done:\r\n * ```js\r\n * env.isDone; // True if envelope is completed\r\n * ```\r\n * \r\n * Envelope has events to track activity: `change` and `complete`:\r\n * \r\n * ```\r\n * env.addEventListener(`change`, ev => {\r\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\r\n * })\r\n * ```\r\n */\r\nexport interface Adsr extends SimpleEventEmitter<Events> {\r\n  /**\r\n   * Compute value of envelope at this point in time.\r\n   * \r\n   * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\r\n   * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  compute(allowStateChange?:boolean):readonly [stage:string|undefined, scaled:number, raw:number]\r\n\r\n  /**\r\n   * Returns the scaled value\r\n   * Same as .compute()[1]\r\n   */\r\n  get value():number;\r\n /**\r\n  * Releases a held envelope. Has no effect if envelope was not held or is complete.\r\n  */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  release():void\r\n  /**\r\n   * Triggers envelope.\r\n   * \r\n   * If event is already trigged,\r\n   * it will be _retriggered_. If`opts.retriggered` is false (default)\r\n   * envelope starts again at `opts.initialValue`. Otherwise it starts at\r\n   * the current value.\r\n   * \r\n   * @param hold If _true_ envelope will hold at sustain stage\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  trigger(hold?:boolean):void\r\n  /** \r\n   * _True_ if envelope is completed\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get isDone():boolean;\r\n}\r\n\r\nclass AdsrImpl extends AdsrBase implements Adsr {\r\n  readonly attackPath:Path;\r\n  readonly decayPath:Path;\r\n  readonly releasePath:Path;\r\n\r\n  readonly initialLevel;\r\n  readonly peakLevel;\r\n  readonly releaseLevel;\r\n  readonly sustainLevel;\r\n\r\n  readonly attackBend;\r\n  readonly decayBend;\r\n  readonly releaseBend;\r\n\r\n  protected initialLevelOverride:number|undefined;\r\n  readonly retrigger:boolean;\r\n  private releasedAt:number|undefined;\r\n\r\n  constructor(opts:EnvelopeOpts) {\r\n    super(opts);\r\n    this.initialLevel = opts.initialLevel ?? 0;\r\n    this.peakLevel = opts.peakLevel ?? 1;\r\n    this.releaseLevel = opts.releaseLevel ?? 0;\r\n    this.sustainLevel = opts.sustainLevel ?? 0.75;\r\n    this.retrigger = opts.retrigger ?? true;\r\n    \r\n    this.attackBend = opts.attackBend ?? 0;\r\n    this.releaseBend = opts.releaseBend ?? 0;\r\n    this.decayBend = opts.decayBend ?? 0;\r\n    \r\n    const max = 1;\r\n    this.attackPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.initialLevel}, \r\n      {x: max, y: this.peakLevel}, \r\n      -this.attackBend\r\n    ));\r\n    this.decayPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.peakLevel}, \r\n      {x: max, y: this.sustainLevel}, \r\n      -this.decayBend\r\n    ));\r\n    this.releasePath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.sustainLevel},\r\n      {x: max, y: this.releaseLevel}, \r\n      -this.releaseBend\r\n    ));\r\n  }\r\n\r\n  onTrigger() {\r\n    this.initialLevelOverride = undefined;\r\n    if (!this.retrigger) {      \r\n      const [_stage, scaled, _raw] = this.compute();\r\n      if (!Number.isNaN(scaled) && scaled > 0) {\r\n        console.log(`Retrigger. Last value was: ${scaled}`);\r\n        this.initialLevelOverride = scaled;\r\n      }\r\n    }\r\n  }\r\n\r\n  get value():number {\r\n    return this.compute(true)[1];\r\n  }\r\n\r\n  compute(allowStateChange = true):[stage:string|undefined, scaled:number, raw:number] {\r\n    const [stage, amt] = super.computeRaw(allowStateChange);\r\n    if (stage === undefined) return [undefined, NaN, NaN];\r\n    // eslint-disable-next-line functional/no-let\r\n    let v;\r\n    switch (stage) {\r\n    case `attack`:\r\n      v = this.attackPath.interpolate(amt).y;\r\n      if (this.initialLevelOverride !== undefined) {\r\n        v = scale(v, 0, this.initialLevel, this.initialLevelOverride, this.initialLevel);\r\n      }\r\n      this.releasedAt = v;\r\n      break;\r\n    case `decay`:\r\n      //Bezier.computeQuadraticSimple(start, end, bend, amt);\r\n      v = this.decayPath.interpolate(amt).y;\r\n      this.releasedAt = v;\r\n      break;\r\n    case `sustain`:\r\n      v = this.sustainLevel;\r\n      this.releasedAt = v;\r\n      break;\r\n    case `release`:\r\n      v = this.releasePath.interpolate(amt).y;\r\n      // Bound release level to the amp level that we released at.\r\n      // ie. when release happens before a stage completes\r\n      if (this.releasedAt !== undefined) v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\r\n      break;\r\n    case `complete`:\r\n      v = this.releaseLevel;\r\n      this.releasedAt = undefined;\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown state: ${stage}`);\r\n    }\r\n    return [stage, v, amt];\r\n  }\r\n}\r\n\r\n/**\r\n * @inheritdoc Adsr\r\n * @param opts \r\n * @returns New {@link Adsr} Envelope\r\n */\r\nexport const adsr = (opts:EnvelopeOpts):Adsr => new AdsrImpl(opts);","//import {number as guardNumber} from \"../Guards.js\";\r\n\r\nimport * as Timers from '../flow/Timer.js';\r\n\r\n/**\r\n * Sine oscillator.\r\n * \r\n * ```js\r\n * const osc = sine(Timers.frequencyTimer(10));\r\n * const osc = sine(0.1);\r\n * osc.next().value;\r\n * ```\r\n * \r\n * // Saw/tri pinch\r\n * ```js\r\n * const v = Math.pow(osc.value, 2);\r\n * ```\r\n * \r\n * // Saw/tri bulge\r\n * ```js\r\n * const v = Math.pow(osc.value, 0.5);\r\n * ```\r\n * \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* sine(timerOrFreq:Timers.Timer|number) {\r\n  if (typeof timerOrFreq === `number`) timerOrFreq = Timers.frequencyTimer(timerOrFreq);\r\n  \r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    // Rather than -1 to 1, we want 0 to 1\r\n    yield (Math.sin(timerOrFreq.elapsed*Math.PI*2) + 1) / 2;\r\n  }\r\n}\r\n\r\n/**\r\n * Bipolar sine (-1 to 1)\r\n * @param timerOrFreq \r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* sineBipolar(timerOrFreq:Timers.Timer|number) {\r\n  if (typeof timerOrFreq === `number`) timerOrFreq = Timers.frequencyTimer(timerOrFreq);\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    yield Math.sin(timerOrFreq.elapsed*Math.PI*2);\r\n  }\r\n}\r\n\r\n/**\r\n * Triangle oscillator\r\n * ```js\r\n * const osc = triangle(Timers.frequencyTimer(0.1));\r\n * const osc = triangle(0.1);\r\n * osc.next().value;\r\n * ```\r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* triangle(timerOrFreq:Timers.Timer|number) {\r\n  if (typeof timerOrFreq === `number`) timerOrFreq = Timers.frequencyTimer(timerOrFreq);\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    // elapsed is repeatedly 0->1\r\n    //eslint-disable-next-line functional/no-let\r\n    let v = timerOrFreq.elapsed; \r\n    // /2 = 0->0.5\r\n    if (v < 0.5) {\r\n      // Upward\r\n      v *= 2;        \r\n    } else {\r\n      // Downward\r\n      v = 2 - v*2;\r\n    }\r\n    yield v;\r\n  }\r\n}\r\n\r\n/**\r\n * Saw oscillator\r\n * ```js\r\n * const osc = saw(Timers.frequencyTimer(0.1));\r\n * const osc = saw(0.1);\r\n * osc.next().value;\r\n * ```\r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* saw(timerOrFreq:Timers.Timer) {\r\n  if (typeof timerOrFreq === `number`) timerOrFreq = Timers.frequencyTimer(timerOrFreq);\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    yield timerOrFreq.elapsed;\r\n  }\r\n}\r\n\r\n/**\r\n * Square oscillator\r\n * ```js\r\n * const osc = square(Timers.frequencyTimer(0.1));\r\n * const osc = square(0.1);\r\n * osc.next().value;\r\n * ```\r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* square(timerOrFreq:Timers.Timer) {\r\n  if (typeof timerOrFreq === `number`) timerOrFreq = Timers.frequencyTimer(timerOrFreq);\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {   \r\n    yield (timerOrFreq.elapsed < 0.5) ? 0 : 1;\r\n  }\r\n}"],"mappings":"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","names":[]}