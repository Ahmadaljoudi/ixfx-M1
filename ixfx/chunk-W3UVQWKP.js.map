{"version":3,"sources":["../src/IterableAsync.ts"],"sourcesContent":["/* eslint-disable */\r\n/**\r\n * \r\n * ```js\r\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\r\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\r\n * ```\r\n * @param it \r\n * @param size \r\n */\r\nexport async function* chunks<V>(it:Iterable<V>, size:number) {\r\n  // Source: https://surma.github.io/underdash/\r\n  let buffer = [];\r\n  for await (const v of it) {\r\n    buffer.push(v);\r\n    if (buffer.length === size) {\r\n      yield buffer;\r\n      buffer = [];\r\n    }\r\n  }\r\n  if (buffer.length > 0) yield buffer;\r\n}\r\n\r\nexport async function* concat<V>(...its:readonly Iterable<V>[]) {\r\n  // Source: https://surma.github.io/underdash/\r\n\r\n  for await (const it of its) yield* it;\r\n}\r\n\r\nexport async function* dropWhile<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  //const iit = it[Symbol.asyncIterator]();\r\n  for await (const v of it)\r\n  { if (!f(v)) {\r\n    yield v;\r\n    break;\r\n  } }\r\n  yield* it;\r\n}\r\n\r\nexport async function equals<V>(it1:Iterable<V>, it2:Iterable<V>) {\r\n  // https://surma.github.io/underdash/\r\n  const iit1 = it1[Symbol.iterator]();\r\n  const iit2 = it2[Symbol.iterator]();\r\n  while (true) {\r\n    const i1 = await iit1.next(), i2 = await iit2.next();\r\n    if (i1.value !== i2.value) return false;\r\n    if (i1.done || i2.done) return i1.done && i2.done;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if `f` returns true for \r\n * every item in iterable\r\n * @param it \r\n * @param f \r\n * @returns \r\n */\r\n export async function every<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  let ok = true;\r\n  for await (const v of it) ok = ok && f(v);\r\n  return ok;\r\n}\r\n\r\n/**\r\n * Yields `v` for each item within `it`.\r\n * \r\n * ```js\r\n * fill([1, 2, 3], 0);\r\n * // Yields: [0, 0, 0]\r\n * ```\r\n * @param it \r\n * @param v \r\n */\r\n export async function* fill<V>(it:AsyncIterable<V>, v:V) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const _ of it) yield v;\r\n}\r\n\r\n/**\r\n * ```js\r\n * filter([1, 2, 3, 4], e => e % 2 == 0);\r\n * returns [2, 4]\r\n * ```\r\n * @param it \r\n * @param f \r\n */\r\n export async function* filter<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) {\r\n    if (!f(v)) continue;\r\n    yield v;\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * ```js\r\n * find([1, 2, 3, 4], e => e > 2);\r\n * // Yields: 3\r\n * ```\r\n * @param it \r\n * @param f \r\n * @returns \r\n */\r\n export async function find<V>(it:Iterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it)\r\n  { if (f(v)) return v; } \r\n}\r\n\r\n/**\r\n * ```js\r\n * flatten([1, [2, 3], [[4]]]);\r\n * // Yields: [1, 2, 3, [4]];\r\n * ```\r\n * @param it \r\n */\r\n export async function* flatten<V>(it:AsyncIterable<V>) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) {\r\n    if (Symbol.asyncIterator in v) { \r\n      // @ts-ignore\r\n      yield* v;\r\n    } else {\r\n      yield v;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @param it \r\n * @param f \r\n */\r\n export async function forEach<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) f(v);\r\n}\r\n\r\nexport async function* map<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) \r\n  { yield f(v); }\r\n}\r\n\r\nexport async function max<V>(it:AsyncIterable<V>, gt = (a:V, b:V) => a > b) {\r\n  // https://surma.github.io/underdash/\r\n  let max;\r\n  for await (const v of it) {\r\n    if(!max) {\r\n      max = v;\r\n      continue;\r\n    }\r\n    max = gt(max, v)?max:v;\r\n  }\r\n  return max;\r\n}\r\n\r\nexport async function min<V>(it:AsyncIterable<V>, gt = (a:V, b:V) => a > b) {\r\n  // https://surma.github.io/underdash/\r\n  let min;\r\n  for await (const v of it) {\r\n    if(!min) {\r\n      min = v;\r\n      continue;\r\n    }\r\n    min = gt(min, v)?v:min;\r\n  }\r\n  return min;\r\n}\r\n\r\n/**\r\n * Returns count from `start` for a given length\r\n * ```js\r\n * range(-5, 10);\r\n * // Yields: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\r\n * ```\r\n * @param start \r\n * @param len \r\n */\r\n export async function* range(start:number, len:number) {\r\n  // https://surma.github.io/underdash/\r\n  for (let i=0;i<len;i++) {\r\n    yield start++;\r\n  }\r\n  //for (let i=len;len > 0; len--) yield start++;\r\n}\r\n\r\nexport async function reduce<V>(it:AsyncIterable<V>, f:(acc:V, current:V) => V, start:V) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) start = f(start, v);\r\n  return start;\r\n}\r\n\r\nexport async function* slice<V>(it:AsyncIterable<V>, start = 0, end = Number.POSITIVE_INFINITY) {\r\n  // https://surma.github.io/underdash/\r\n  const iit = it[Symbol.asyncIterator]();\r\n  for(; start > 0; start--, end--) await iit.next();\r\n  for await (const v of it) \r\n  { if(end-- > 0)\r\n  { yield v; }\r\n  else\r\n  { break; } }\r\n}\r\n\r\nexport async function some<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) \r\n  { if(f(v)) return true; }\r\n  return false;\r\n}\r\n\r\nexport async function* takeWhile<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\r\n  // https://surma.github.io/underdash/\r\n  for await (const v of it) {\r\n    if (!f(v)) return;\r\n    yield v;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array of values from an iterator.\r\n * \r\n * ```js\r\n * const data = await toArray(adsrSample(opts, 10));\r\n * ```\r\n * \r\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\r\n * will never return.\r\n * \r\n * @param it Asynchronous iterable\r\n * @param count Number of items to return, by default all.\r\n * @returns \r\n */\r\n export async function toArray<V>(it:AsyncIterable<V>, count = Infinity):Promise<readonly V[]> {\r\n  // https://2ality.com/2016/10/asynchronous-iteration.html\r\n  const result = [];\r\n  const iterator = it[Symbol.asyncIterator]();\r\n  while (result.length < count) {\r\n      const {value,done} = await iterator.next();\r\n      if (done) break;\r\n      result.push(value);\r\n  }\r\n  return result;\r\n\r\n}\r\n\r\nexport async function* unique<V>(it:AsyncIterable<V>, f:((id:V) => V) = id => id) {\r\n  // https://surma.github.io/underdash/\r\n  const buffer = [];\r\n  for await (const v of it) {\r\n    const fv = f(v);\r\n    if (buffer.indexOf(fv) !== -1) continue;\r\n    buffer.push(fv);\r\n    yield v;\r\n  }\r\n}\r\n\r\nexport async function* zip<V>(...its:AsyncIterable<V>[]) {\r\n  // https://surma.github.io/underdash/\r\n  const iits = its.map(it => it[Symbol.asyncIterator]());\r\n  while(true) {\r\n    const vs = await Promise.all(iits.map(it => it.next()));\r\n    if (vs.some(v => v.done)) return;\r\n    yield vs.map(v => v.value);\r\n  }\r\n}"],"mappings":"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","names":[]}