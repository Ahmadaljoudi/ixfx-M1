{"version":3,"sources":["../src/collections/Map.ts"],"sourcesContent":["import { IsEqual, ToString } from \"../Util.js\";\n\n// âœ” UNIT TESTED!\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n * \n * Having a comparer function is useful to check by value rather than object reference.\n * \n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(map:ReadonlyMap<K, V>, key:K, value:V, comparer:IsEqual<V>):boolean => {\n  if (!map.has(key)) return false;\n  const values = Array.from(map.values());\n  return values.some(v => comparer(v, value));\n};\n\nexport type GetOrGenerate<K, V, Z> = (key:K, args?:Z)=>Promise<V>;\n\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n * \n * See {@link getOrGenerateSync} for a synchronous version.\n * \n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n * \n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n * \n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const getOrGenerate = <K, V, Z>(map:Map<K, V>, fn:(key:K, args?:Z)=>Promise<V>|V):GetOrGenerate<K, V, Z> => async (key:K, args?:Z):Promise<V> => {\n  //eslint-disable-next-line functional/no-let\n  let value = map.get(key);\n  if (value !== undefined) return Promise.resolve(value);\n  value = await fn(key, args);\n  if (value === undefined) throw new Error(`fn returned undefined`);\n  map.set(key, value);\n  return value;\n};\n\n/**\n * @inheritDoc getOrGenerate\n * @param map \n * @param fn \n * @returns \n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const getOrGenerateSync = <K, V, Z>(map:Map<K, V>, fn:(key:K, args?:Z)=>V) => (key:K, args?:Z):V => {\n  //eslint-disable-next-line functional/no-let\n  let value = map.get(key);\n  if (value !== undefined) return value;\n  value = fn(key, args);\n  map.set(key, value);\n  return value;\n};\n\n/**\n * Adds items to a map only if their key doesn't already exist \n * \n * Uses provided {@link Util.ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n * \n * \n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addUniqueByHash(map, p => p.name, ...peopleArray);\n * ```\n * @param set \n * @param hashFunc \n * @param values \n * @returns \n */\nexport const addUniqueByHash = <V>(set:ReadonlyMap<string, V>|undefined, hashFunc:ToString<V>, ...values:readonly V[]) => {\n  const s = set === undefined ? new Map() : new Map(set);\n  values.forEach(v => {\n    const vStr = hashFunc(v);\n    if (s.has(vStr)) return;\n    s.set(vStr, v);\n  });\n  return s;\n};\n\n\n/**\n * Returns true if _any_ key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n * \n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n * \n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n * \n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(map:ReadonlyMap<K, V>, value:V, comparer:IsEqual<V>):boolean => {\n  const entries = Array.from(map.entries());\n  return entries.some(kv => comparer(kv[1], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n * \n * If you just want the first match, use `find`\n * \n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n * \n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate \n * @returns Values that match predicate\n */\n//eslint-disable-next-line func-style\nexport function * filter<V>(map:ReadonlyMap<string, V>, predicate:(v:V)=>boolean) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map \n * @returns \n */\nexport const toArray = <V>(map:ReadonlyMap<string, V>):ReadonlyArray<V> => Array.from(map.values());\n\n/**\n * Returns a Map from an iterable\n * @param data Input data\n * @param keyFn Function which returns a string id\n * @param allowOverwrites If true, items with same id will silently overwrite each other, with last write wins\n * @returns \n */\nexport const fromIterable = <V>(data:Iterable<V>, keyFn:(v:V)=>string, allowOverwrites = false):ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const id = keyFn(d);\n    if (m.has(id) && !allowOverwrites) throw new Error(`id ${id} is already used and new data will overwrite it. `);\n    m.set(id, d);\n  }\n  return m;\n};\n\n/**\n * Returns the first found item that matches `predicate` or _undefined_.\n * \n * If you want all matches, use {@link filter}.\n * \n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching item\n * @returns Found item or _undefined_\n */\nexport const find = <V>(map:ReadonlyMap<string, V>, predicate:(v:V)=>boolean):V|undefined =>  Array.from(map.values()).find(vv => predicate(vv));\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link mapToObj}.\n * \n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n * \n * const o = mapToObjTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n * \n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n * \n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform \n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns \n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const mapToObjTransform = <T, K>(m:ReadonlyMap<string, T>, valueTransform:(value:T)=>K):{readonly [key:string]:K} => Array.from(m).reduce((obj:any, [key, value]) => {\n  const t = valueTransform(value);\n  /* eslint-disable-next-line functional/immutable-data */\n  obj[key] = t;\n  return obj;\n}, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that \n * `keys` and `values` are the same length.\n * \n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n  * @param keys String keys\n  * @param values Values\n  * @typeParam V Type of values\n  * @return Object with keys and values\n  */\nexport const zipKeyValue = <V>(keys:ReadonlyArray<string>, values:ArrayLike<V|undefined>) => {\n  if (keys.length !== values.length) throw new Error(`Keys and values arrays should be same length`);\n  return Object.fromEntries(keys.map((k, i) => [k, values[i]]));\n};\n\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n * \n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n * \n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n * \n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n * \n * If you want to combine values into a single object, consider instead  {@link mapToObjTransform}.\n * @param source \n * @param transformer \n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns \n */\nexport const transformMap = <K, V, R>(\n  source:ReadonlyMap<K, V>,\n  transformer:(value:V, key:K)=>R\n) => new Map(\n    Array.from(source, v => [v[0], transformer(v[1], v[0])])\n  );\n\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON\n * \n * @example\n * ```js\n * const str = JSON.stringify(mapToObj(map));\n * ```\n * @param m \n * @returns \n */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport const mapToObj = <T>(m:ReadonlyMap<string, T>):{ readonly [key:string]:T} => Array.from(m).reduce((obj:any, [key, value]) => {\n  /* eslint-disable-next-line functional/immutable-data */\n  obj[key] = value;\n  return obj;\n}, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n * \n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n * \n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n * \n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n * \n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m \n * @param transformer A function that takes a key and item, returning a new item.\n * @returns \n */\nexport const mapToArray = <K, V, R>(\n  m:ReadonlyMap<K, V>,\n  transformer:(key:K, item:V)=>R\n):readonly R[] => Array.from(m.entries()).map(x => transformer(x[0], x[1]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a:V, b:V)=>V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n * \n * There's also [Arrays.mergeByKey](functions/Collections.Arrays.mergeByKey.html) if you don't already have a map.\n * \n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n * \n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n * \n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n * \n * The final result will be:\n * \n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n * \n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n * \n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be \n * passed through.\n * \n * @param reconcile \n * @param maps \n */\nexport const mergeByKey = <K, V>(reconcile:MergeReconcile<V>, ...maps:readonly ReadonlyMap<K, V>[]):ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [mk, mv] of m) {\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      if (v) {\n        v = reconcile(v, mv);\n      } else {\n        v = mv;\n      }\n      result.set(mk, v);\n    }\n  }\n  return result;\n};"],"mappings":"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","names":[]}