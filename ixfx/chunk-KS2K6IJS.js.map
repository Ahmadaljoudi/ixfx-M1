{"version":3,"sources":["../src/Generators.ts"],"sourcesContent":["import {sleep} from \"./Timer.js\";\r\nimport {number as guardNumber} from \"./Guards.js\";\r\n/**\r\n * Generates values from `produce` with `intervalMs` time delay\r\n * \r\n * @example Produce a random number every 500ms:\r\n * ```\r\n * const randomGenerator = atInterval(() => Math.random(), 1000);\r\n * for await (const r of randomGenerator) {\r\n *  // Random value every 1 second\r\n * }\r\n * ```\r\n *\r\n * @template V\r\n * @param intervalMs Interval between execution\r\n * @param produce Function to call\r\n * @template V Data type\r\n * @returns\r\n */\r\nexport const interval = async function*<V>(produce: () => Promise<V>, intervalMs: number) {\r\n  //eslint-disable-next-line functional/no-let\r\n  let cancelled = false;\r\n  //eslint-disable-next-line functional/no-try-statement\r\n  try {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (!cancelled) {\r\n      await sleep(intervalMs);\r\n      if (cancelled) return;\r\n      yield await produce();\r\n    }\r\n  } finally {\r\n    cancelled = true;\r\n  }\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, starting from `start` and coutnting by `interval`.\r\n * If `end` is provided, generator stops when reached.\r\n * \r\n * Unlike numericRange, numbers might contain rounding errors\r\n * \r\n * ```js\r\n * for (const c of numericRangeRaw(10, 100)) {\r\n *  // 100, 110, 120 ...\r\n * }\r\n * ```\r\n * @param interval Interval between numbers\r\n * @param start Start\r\n * @param end End (if undefined, range never ends)\r\n */\r\nexport const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = start;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n *\r\n * @example For-loop\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * \r\n * @example If you want more control over when/where incrementing happens...\r\n * ```js\r\n * let percent = numericRange(0.1, 0, 1);\r\n * \r\n * let percentResult = percent.next().value;\r\n * ```\r\n * \r\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\r\n * number.\r\n * \r\n * @param interval Interval between numbers\r\n * @param start Start\r\n * @param end End (if undefined, range never ends)\r\n * @param repeating If true, range loops from start indefinately\r\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  guardNumber(interval,  `nonZero`);\r\n  \r\n  const negativeInterval = interval < 0;\r\n  if (end === undefined) {\r\n    /* no op */\r\n  } else {\r\n    if (negativeInterval && start < end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\r\n    if (!negativeInterval && start > end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\r\n  }\r\n\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    //eslint-disable-next-line functional/no-let\r\n    let v = start * rounding;\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Returns a number range between 0.0-1.0. By default it loops back to 0 after reaching 1\r\n * @param interval Interval (defaults to 0.01 or 1%)\r\n * @param repeating Whether generator should loop\r\n * @param start Start\r\n * @param end End\r\n * @returns \r\n */\r\nexport const rangePercent = function (interval:number = 0.01, repeating:boolean = true, start:number = 0, end = 1) {\r\n  guardNumber(interval, `percentage`, `interval`);\r\n  guardNumber(start, `percentage`, `start`);\r\n  guardNumber(end, `percentage`, `end`);\r\n  return numericRange(interval, start, end, repeating);\r\n};\r\n\r\n/**\r\n * Continually loops up and down between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * @example Usage\r\n * ```js\r\n * for (let v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * @example Alternative:\r\n * ```js\r\n * let pp = percentPingPong(0.1, 0.5); // Setup generator one time\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to 0 and 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * @param interval Amount to increment by. Defaults to 10%\r\n * @param offset Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, start: number = 0, end:number = 1, offset:number = 0, rounding: number = 1000) {\r\n  // if (offset === undefined && interval > 0) offset = 0;\r\n  // else if (offset === undefined && interval < 0) offset = 1;\r\n  // else offset = offset as number;\r\n  // if (offset > 1 || offset < 0) throw new Error(`offset must be between 0 and 1`);\r\n\r\n  guardNumber(interval, `bipolar`, `interval`);\r\n  guardNumber(end, `bipolar`, `end`);\r\n  guardNumber(offset, `bipolar`, `offset`);\r\n  guardNumber(start, `bipolar`, `start`);\r\n  \r\n  return pingPong(interval, start, end, offset, rounding);\r\n};\r\n\r\n/**\r\n * Ping-pongs continually back and forth `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * In a loop:\r\n * ```\r\n * for (const c of pingPong(10, 0, 100)) {\r\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\r\n * }\r\n * ```\r\n * \r\n * Manual:\r\n * ```\r\n * const pp = pingPong(10, 0, 100);\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * @param interval Amount to increment by. Use negative numbers to start counting down\r\n * @param lower Lower bound (inclusive)\r\n * @param upper Upper bound (inclusive, must be greater than start)\r\n * @param offset Starting point within bounds (defaults to `lower`)\r\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, offset?: number, rounding: number = 1) {\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(offset)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (offset === undefined) offset = lower;\r\n  else offset = Math.floor(offset * rounding);\r\n  if (offset > upper || offset < lower) throw new Error(`Offset must be within lower and upper`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = offset;\r\n  yield v / rounding;\r\n  //eslint-disable-next-line functional/no-let\r\n  let firstLoop = true;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n"],"mappings":"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","names":[]}