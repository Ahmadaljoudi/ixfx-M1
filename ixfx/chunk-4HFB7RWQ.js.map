{"version":3,"sources":["../src/flow/StateMachine.ts"],"sourcesContent":["// âœ” UNIT TESTED\r\n\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\nimport { isStringArray } from \"../Guards.js\";\r\n\r\nexport interface Options {\r\n  readonly debug?: boolean\r\n}\r\n\r\n//type StateName = string | number | Symbol;\r\n\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\nexport interface StopEvent {\r\n  readonly state: string;\r\n}\r\n\r\ntype StateMachineEventMap = {\r\n  readonly change: StateChangeEvent\r\n  readonly stop: StopEvent\r\n};\r\n\r\ntype StateEvent = (args: unknown, sender: StateMachine) => void;\r\ntype StateHandler = string | StateEvent | null;\r\n\r\nexport interface State {\r\n  readonly [event: string]: StateHandler;\r\n}\r\n\r\nexport interface MachineDescription {\r\n  readonly [key: string]: string | readonly string[] | null;\r\n}\r\n\r\n/**\r\n * Returns a machine description based on a list of strings. The final string is the final\r\n * state.\r\n * \r\n * ```js\r\n * const states = [`one`, `two`, `three`];\r\n * const sm = new StateMachine(states[0], fromList(states));\r\n * ```\r\n * @param {...readonly} states\r\n * @param {*} string\r\n * @param {*} []\r\n * @return {*}  {MachineDescription}\r\n */\r\nexport const fromList = (...states:readonly string[]):MachineDescription => {\r\n  const t = {};\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i=0;i<states.length; i++) {\r\n    if (i === states.length - 1) {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data \r\n      t[states[i]] = null;\r\n    } else {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data\r\n      t[states[i]] = states[i+1];\r\n    }\r\n  }\r\n  return t;\r\n};\r\n\r\n/**\r\n * State machine\r\n *\r\n * Machine description is a simple object of possible state names to allowed state(s). Eg. the following\r\n * has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `Sleep` can only transition to the `wakeup`\r\n * state, while `wakeup` can transition to either `coffee` or `breakfast`. \r\n * \r\n * Use `null` to signify the final state. Multiple states can terminate the machine if desired.\r\n * ```\r\n * const description = { \r\n *  sleep: 'wakeup',\r\n *  wakeup: ['coffee', 'breakfast'],\r\n *  coffee: `bike`,\r\n *  breakfast: `bike`,\r\n *  bike: null\r\n * }\r\n * ```\r\n * Create the machine with the starting state (`sleep`)\r\n * ```\r\n * const machine = new StateMachine(`sleep`, description);\r\n * ```\r\n * \r\n * Change the state by name:\r\n * ```\r\n * machine.state = `wakeup`\r\n * ```\r\n * \r\n * Or request an automatic transition (will use first state if there are several options)\r\n * ```\r\n * machine.next();\r\n * ```\r\n * \r\n * Check status\r\n * ```\r\n * if (machine.state === `coffee`) ...;\r\n * if (machine.isDone()) ...\r\n * ```\r\n * \r\n * Listen for state changes\r\n * ```\r\n * machine.addEventListener(`change`, (evt) => {\r\n *  const {priorState, newState} = evt;\r\n *  console.log(`State change from ${priorState} -> ${newState}`);\r\n * });\r\n * ```\r\n * @export\r\n * @class StateMachine\r\n * @extends {SimpleEventEmitter<StateMachineEventMap>}\r\n */\r\nexport class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #state: string;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #debug: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #m: MachineDescription;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #isDone: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #initial: string;\r\n\r\n  /**\r\n   * Create a state machine with initial state, description and options\r\n   * @param {string} initial Initial state\r\n   * @param {MachineDescription} m Machine description\r\n   * @param {Options} [opts={debug: false}] Options for machine\r\n   * @memberof StateMachine\r\n   */\r\n  constructor(initial: string, m: MachineDescription, opts: Options = {debug: false}) {\r\n    super();\r\n    const [isValid, errorMsg] = StateMachine.validate(initial, m);\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    this.#initial = initial;\r\n    this.#m = m;\r\n    this.#debug = opts.debug ?? false;\r\n    this.#state = initial;\r\n    this.#isDone = false;\r\n  }\r\n\r\n  get states():readonly string[] {\r\n    return Object.keys(this.#m);\r\n  }\r\n\r\n  static validate(initial:string, m:MachineDescription):readonly [boolean, string]  {\r\n    // Check that object is structured properly\r\n    const keys = Object.keys(m);\r\n    // eslint-disable-next-line functional/prefer-readonly-type\r\n    const finalStates:string[] = [];\r\n    const seenKeys = new Set();\r\n    const seenVals = new Set();\r\n\r\n    // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n    for (let i=0;i<keys.length;i++) {\r\n      const key = keys[i];\r\n      if (seenKeys.has(key)) return [false, `Key ${key} is already used`];\r\n      seenKeys.add(key);\r\n\r\n      if (typeof keys[i] !== `string`) return [false, `Key[${i}] is not a string`];\r\n      const val = m[key];\r\n      if (val === undefined) return [false, `Key ${key} value is undefined`];\r\n      if (typeof val === `string`) {\r\n        seenVals.add(val);\r\n        if (val === key) return [false, `Loop present for ${key}`];\r\n      } else if (Array.isArray(val)) {\r\n        if (!isStringArray(val)) return [false, `Key ${key} value is not an array of strings`];\r\n        val.forEach(v => seenVals.add(v));\r\n        if (val.find(v => v === key)) return [false, `Loop present for ${key}`];\r\n      } else if (val === null) {\r\n        // eslint-disable-next-line functional/immutable-data\r\n        finalStates.push(key);\r\n      } else {\r\n        return [false, `Key ${key} has a value that is neither null, string or array`];\r\n      }\r\n    }\r\n\r\n    // Check that all values have a top-level state\r\n    const seenValsArray = Array.from(seenVals);\r\n    const missing = seenValsArray.find(v => !seenKeys.has(v));\r\n    if (missing) return [false, `Potential state '${missing}' does not exist as a top-level state`];\r\n\r\n    // Check machine contains intial state\r\n    if (m[initial] === undefined) return [false, `Initial state ${initial} not present`];\r\n    return [true, ``];\r\n  }\r\n\r\n  /**\r\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\r\n   * If machine is finalised, no error is thrown and null is returned.\r\n   * \r\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\r\n   * @memberof StateMachine\r\n   */\r\n  next(): string | null {\r\n    // Get possible transitions for current state\r\n    const r = this.#m[this.#state];\r\n    if (r === null) return null; // At the end\r\n\r\n    // If there are multiple options, use the first\r\n    if (Array.isArray(r)) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      if (typeof r[0] === `string`) this.state = r[0];\r\n      else throw new Error(`Error in machine description. Potential state array does not contain strings`);\r\n    } else if (typeof r === `string`) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.state = r; // Just one option\r\n    } else throw new Error(`Error in machine description. Potential state is neither array nor string`);\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Returns true if state machine is in its final state\r\n   *\r\n   * @returns\r\n   * @memberof StateMachine\r\n   */\r\n  get isDone():boolean {\r\n    return this.#isDone;\r\n  }\r\n\r\n  /**\r\n   * Resets machine to initial state\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  reset() {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#isDone = false;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = this.#initial;\r\n  }\r\n\r\n  /**\r\n   * Checks whether a state change is valid.\r\n   *\r\n   * @static\r\n   * @param {string} priorState From state\r\n   * @param {string} newState To state\r\n   * @param {MachineDescription} description Machine description\r\n   * @returns {[boolean, string]} If valid: [true,''], if invalid: [false, 'Error msg here']\r\n   * @memberof StateMachine\r\n   */\r\n  static isValid(priorState:string, newState:string, description:MachineDescription):readonly [boolean, string] {\r\n    // Does state exist?\r\n    if (description[newState] === undefined) return [false, `Machine cannot change to non-existent state ${newState}`];\r\n\r\n    // Is transition allowed?\r\n    const rules = description[priorState];\r\n    if (Array.isArray(rules)) {\r\n      if (!rules.includes(newState)) return [false, `Machine cannot ${priorState} -> ${newState}. Allowed transitions: ${rules.join(`, `)}`];\r\n    } else {\r\n      if (newState !== rules && rules !== `*`) return [false, `Machine cannot ${priorState} -> ${newState}. Allowed transition: ${rules}`];\r\n    }\r\n    return [true, `ok`];\r\n  }\r\n\r\n  isValid(newState:string):readonly [boolean, string] {\r\n    return StateMachine.isValid(this.state, newState, this.#m);\r\n  }\r\n\r\n  /**\r\n   * Sets state. Throws an error if an invalid transition is attempted.\r\n   * Use `StateMachine.isValid` to check validity without changing.\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  set state(newState: string) {\r\n    const priorState = this.#state;\r\n\r\n    const [isValid, errorMsg] = StateMachine.isValid(priorState, newState, this.#m);\r\n\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);\r\n\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = newState;\r\n\r\n    const rules = this.#m[newState];\r\n    if (rules === null) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#isDone = true;\r\n    }\r\n    setTimeout(() => {\r\n      this.fireEvent(`change`, {newState: newState, priorState: priorState});\r\n      if (this.isDone) this.fireEvent(`stop`, {state: newState });\r\n    }, 1);\r\n  }\r\n\r\n  /**\r\n * Return current state\r\n *\r\n * @type {string}\r\n * @memberof StateMachine\r\n */\r\n  get state(): string {\r\n    return this.#state;\r\n  }\r\n}"],"mappings":";;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAiDO,IAAM,WAAW,IAAI,WAAgD;AAC1E,QAAM,IAAI;AAEV,WAAS,IAAE,GAAE,IAAE,OAAO,QAAQ,KAAK;AACjC,QAAI,MAAM,OAAO,SAAS,GAAG;AAG3B,QAAE,OAAO,MAAM;AAAA,WACV;AAGL,QAAE,OAAO,MAAM,OAAO,IAAE;AAAA;AAAA;AAG5B,SAAO;AAAA;AA/DT;AAmHO,kCAA2B,mBAAyC;AAAA,EAmBzE,YAAY,SAAiB,GAAuB,OAAgB,EAAC,OAAO,SAAQ;AAClF;AAlBF;AAEA;AAEA;AAEA;AAEA;AAWE,UAAM,CAAC,SAAS,YAAY,cAAa,SAAS,SAAS;AAC3D,QAAI,CAAC;AAAS,YAAM,IAAI,MAAM;AAE9B,uBAAK,UAAW;AAChB,uBAAK,IAAK;AACV,uBAAK,QAAS,KAAK,SAAS;AAC5B,uBAAK,QAAS;AACd,uBAAK,SAAU;AAAA;AAAA,MAGb,SAA2B;AAC7B,WAAO,OAAO,KAAK,mBAAK;AAAA;AAAA,SAGnB,SAAS,SAAgB,GAAkD;AAEhF,UAAM,OAAO,OAAO,KAAK;AAEzB,UAAM,cAAuB;AAC7B,UAAM,WAAW,oBAAI;AACrB,UAAM,WAAW,oBAAI;AAGrB,aAAS,IAAE,GAAE,IAAE,KAAK,QAAO,KAAK;AAC9B,YAAM,MAAM,KAAK;AACjB,UAAI,SAAS,IAAI;AAAM,eAAO,CAAC,OAAO,OAAO;AAC7C,eAAS,IAAI;AAEb,UAAI,OAAO,KAAK,OAAO;AAAU,eAAO,CAAC,OAAO,OAAO;AACvD,YAAM,MAAM,EAAE;AACd,UAAI,QAAQ;AAAW,eAAO,CAAC,OAAO,OAAO;AAC7C,UAAI,OAAO,QAAQ,UAAU;AAC3B,iBAAS,IAAI;AACb,YAAI,QAAQ;AAAK,iBAAO,CAAC,OAAO,oBAAoB;AAAA,iBAC3C,MAAM,QAAQ,MAAM;AAC7B,YAAI,CAAC,cAAc;AAAM,iBAAO,CAAC,OAAO,OAAO;AAC/C,YAAI,QAAQ,OAAK,SAAS,IAAI;AAC9B,YAAI,IAAI,KAAK,OAAK,MAAM;AAAM,iBAAO,CAAC,OAAO,oBAAoB;AAAA,iBACxD,QAAQ,MAAM;AAEvB,oBAAY,KAAK;AAAA,aACZ;AACL,eAAO,CAAC,OAAO,OAAO;AAAA;AAAA;AAK1B,UAAM,gBAAgB,MAAM,KAAK;AACjC,UAAM,UAAU,cAAc,KAAK,OAAK,CAAC,SAAS,IAAI;AACtD,QAAI;AAAS,aAAO,CAAC,OAAO,oBAAoB;AAGhD,QAAI,EAAE,aAAa;AAAW,aAAO,CAAC,OAAO,iBAAiB;AAC9D,WAAO,CAAC,MAAM;AAAA;AAAA,EAUhB,OAAsB;AAEpB,UAAM,IAAI,mBAAK,IAAG,mBAAK;AACvB,QAAI,MAAM;AAAM,aAAO;AAGvB,QAAI,MAAM,QAAQ,IAAI;AAEpB,UAAI,OAAO,EAAE,OAAO;AAAU,aAAK,QAAQ,EAAE;AAAA;AACxC,cAAM,IAAI,MAAM;AAAA,eACZ,OAAO,MAAM,UAAU;AAEhC,WAAK,QAAQ;AAAA;AACR,YAAM,IAAI,MAAM;AACvB,WAAO,KAAK;AAAA;AAAA,MASV,SAAiB;AACnB,WAAO,mBAAK;AAAA;AAAA,EAQd,QAAQ;AAEN,uBAAK,SAAU;AAEf,uBAAK,QAAS,mBAAK;AAAA;AAAA,SAad,QAAQ,YAAmB,UAAiB,aAA2D;AAE5G,QAAI,YAAY,cAAc;AAAW,aAAO,CAAC,OAAO,+CAA+C;AAGvG,UAAM,QAAQ,YAAY;AAC1B,QAAI,MAAM,QAAQ,QAAQ;AACxB,UAAI,CAAC,MAAM,SAAS;AAAW,eAAO,CAAC,OAAO,kBAAkB,iBAAiB,kCAAkC,MAAM,KAAK;AAAA,WACzH;AACL,UAAI,aAAa,SAAS,UAAU;AAAK,eAAO,CAAC,OAAO,kBAAkB,iBAAiB,iCAAiC;AAAA;AAE9H,WAAO,CAAC,MAAM;AAAA;AAAA,EAGhB,QAAQ,UAA4C;AAClD,WAAO,cAAa,QAAQ,KAAK,OAAO,UAAU,mBAAK;AAAA;AAAA,MASrD,MAAM,UAAkB;AAC1B,UAAM,aAAa,mBAAK;AAExB,UAAM,CAAC,SAAS,YAAY,cAAa,QAAQ,YAAY,UAAU,mBAAK;AAE5E,QAAI,CAAC;AAAS,YAAM,IAAI,MAAM;AAE9B,QAAI,mBAAK;AAAQ,cAAQ,IAAI,iBAAiB,iBAAiB;AAG/D,uBAAK,QAAS;AAEd,UAAM,QAAQ,mBAAK,IAAG;AACtB,QAAI,UAAU,MAAM;AAElB,yBAAK,SAAU;AAAA;AAEjB,eAAW,MAAM;AACf,WAAK,UAAU,UAAU,EAAC,UAAoB;AAC9C,UAAI,KAAK;AAAQ,aAAK,UAAU,QAAQ,EAAC,OAAO;AAAA,OAC/C;AAAA;AAAA,MASD,QAAgB;AAClB,WAAO,mBAAK;AAAA;AAAA;AA3LT;AAEL;AAEA;AAEA;AAEA;AAEA;","names":[]}