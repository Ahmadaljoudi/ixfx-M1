{"version":3,"sources":["../src/Text.ts"],"sourcesContent":["/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n * \n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text \n * @param start Start match\n * @param end If undefined, `start` will be used instead\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns \n */\nexport const between = (source: string, start: string, end?: string, lastEndMatch = true): string | undefined => {\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);\n  if (endPos < 0) return;\n\n  return source.substring(startPos+1, endPos);\n};\n\n\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source:string, code:number, start = 0, end = source.length-1):number => {\n  //eslint-disable-next-line functional/no-let\n  for (let i=start;i<=end;i++) {\n    if (source.charCodeAt(i) === code) return i;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with chars removed at `removeStart` position\n * ```js\n * omitChars(`hello there`, 1, 3);\n * // Yields: `ho there`\n * ```\n * @param source \n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove \n * @returns \n */\nexport const omitChars = (source:string, removeStart:number, removeLength:number) =>  source.substring(0, removeStart) + source.substring(removeStart+removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n * \n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n * \n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns \n */\nexport const splitByLength = (source:string, length:number):readonly string[] => {\n  const chunks = Math.ceil(source.length/length);\n  const ret:string[] = [];\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n\n  //eslint-disable-next-line functional/no-let  \n  for (let c=0;c<chunks;c++) {\n    //eslint-disable-next-line functional/immutable-data\n    ret.push(source.substring(start, start+length));\n    start += length;\n  }\n  return ret;\n};\n\n/**\n * Returns the `source` string up until (and excluding) `match`. If match is not\n * found, all of `source` is returned.\n * \n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * @param source \n * @param match \n * @param startPos If provided, gives the starting offset. Default 0\n */\nexport const untilMatch = (source:string, match:string, startPos = 0):string => {\n  if (startPos > source.length) throw new Error(`startPos should be less than length`);\n  const m = source.indexOf(match, startPos);\n  \n  if (m < 0) return source;\n  return source.substring(startPos, m);\n};\n\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source \n * @param wrappers \n * @returns \n */\nexport const unwrap = (source: string, ...wrappers: readonly string[]): string => {\n  //eslint-disable-next-line functional/no-let\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.substring(w.length, source.length - (w.length * 2) + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string\n  /**\n   * Start position, with respect to source text\n   */\n   readonly start: number\n  /**\n   * End position, with respect to source text\n   */\n   readonly end: number\n  /**\n   * Index of range. First range is 0\n   */\n   readonly index: number\n}\n\nexport type LineSpan = {\n  readonly start: number\n  readonly end: number\n  readonly length: number\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n * \n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n * \n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges: readonly Range[], start: number, end: number): LineSpan => {\n  //eslint-disable-next-line functional/no-let\n  let s = -1;\n  //eslint-disable-next-line functional/no-let\n  let e = -1;\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < ranges.length; i++) {\n    const r = ranges[i];\n    s = i;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = s; i < ranges.length; i++) {\n    const r = ranges[i];\n    e = i;\n    if (end === r.end) {\n      e = i + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return {length: e - s, start: s, end: e};\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n * \n * Each range consists of:\n * ```js\n * { \n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source \n * @param split \n * @returns \n */\nexport const splitRanges = (source: string, split: string):readonly Range[] => {\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n  //eslint-disable-next-line functional/no-let\n  let text = ``;\n  const ranges: Range[] = [];\n  //eslint-disable-next-line functional/no-let\n  let index = 0;\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < source.length; i++) {\n    if (source.indexOf(split, i) === i) {\n      //eslint-disable-next-line functional/no-let\n      const end = i;\n      //eslint-disable-next-line functional/immutable-data\n      ranges.push({\n        text, start, end, index\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(i);\n    }\n  }\n  if (start < source.length) {\n    //eslint-disable-next-line functional/immutable-data\n    ranges.push({text, start, index, end: source.length});\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n * \n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source \n * @param chars \n * @returns \n */\nexport const countCharsFromStart = (source: string, ...chars: readonly string[]): number => {\n  //eslint-disable-next-line functional/no-let\n  let counted = 0;\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < source.length; i++) {\n    if (chars.includes(source.charAt(i))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n * \n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within \n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source:string, start:string, end:string = start):boolean => source.startsWith(start) && source.endsWith(end);\n\n//eslint-disable-next-line no-useless-escape\nexport const htmlEntities = (source:string):string => source.replace(/[\\u00A0-\\u9999<>\\&]/g, i => `&#${i.charCodeAt(0)};`);"],"mappings":"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","names":[]}