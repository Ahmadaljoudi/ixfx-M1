{"version":3,"sources":["../src/flow/index.ts","../src/flow/Timer.ts","../src/data/Clamp.ts","../src/flow/Timeout.ts","../src/flow/UpdateOutdated.ts","../src/flow/Continuously.ts","../src/flow/Debounce.ts","../src/flow/Throttle.ts","../src/flow/WaitFor.ts"],"sourcesContent":["import { number as guardNumber} from \"../Guards.js\";\r\nimport {sleep} from \"./Sleep.js\";\r\n\r\nimport * as StateMachine from './StateMachine.js';\r\nimport * as Timer from './Timer.js';\r\n\r\nexport {StateMachine};\r\nexport * from './Timer.js';\r\n\r\nexport * from './Interval.js';\r\nexport * from './Timeout.js';\r\nexport * from './UpdateOutdated.js';\r\nexport * from './Continuously.js';\r\nexport * from './Debounce.js';\r\nexport * from './Throttle.js';\r\nexport * from './Sleep.js';\r\nexport * from './WaitFor.js';\r\nexport * from './Delay.js';\r\n\r\nexport type HasCompletion = {\r\n  get isDone(): boolean;\r\n}\r\n\r\n/**\r\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\r\n * If `fn` returns _false_, iterator cancels. \r\n * \r\n * Over the default JS `forEach` function, this one allows you to exit the\r\n * iteration early.\r\n * \r\n * @example\r\n * ```js\r\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\r\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\r\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\r\n * ```\r\n * \r\n * Use {@link forEachAsync} if you want to use an async `iterator` and async `fn`.\r\n * @param iterator Iterable or array\r\n * @typeParam V Type of iterable\r\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\r\n */\r\nexport const forEach = <V>(iterator:IterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>boolean|void) => {\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const x of iterator) {\r\n    const r = fn(x);\r\n    if (typeof r === `boolean` && !r) break;\r\n  }\r\n};\r\n\r\n/**\r\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\r\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\r\n * \r\n * Use {@link forEach} for a synchronous version.\r\n * \r\n * ```\r\n * // Prints items from array every second\r\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\r\n * ```\r\n * \r\n * @example Retry `doSomething` up to five times, with 5 seconds between each attempt\r\n * ```\r\n * await forEachAsync(count(5), i=> {\r\n *  try {\r\n *    await doSomething();\r\n *    return false; // Succeeded, exit early\r\n *  } catch (ex) {\r\n *    console.log(ex);\r\n *    return true; // Keep trying\r\n *  }\r\n * }, 5000);\r\n * ```\r\n * @param iterator Iterable thing to loop over\r\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\r\n * @typeParam V Type of iterable\r\n */\r\nexport const forEachAsync = async function <V> (iterator:AsyncIterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>Promise<boolean>|Promise<void>, intervalMs?:number) {\r\n  if (Array.isArray(iterator)) {\r\n    // Handle array\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const x of iterator) {\r\n      const r = await fn(x);\r\n      if (intervalMs) await sleep(intervalMs);\r\n      if (typeof r === `boolean` && !r) break;\r\n    }\r\n  } else {\r\n    // Handle an async iterator\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for await (const x of iterator) {\r\n      const r = await fn(x);\r\n      if (intervalMs) await sleep(intervalMs);\r\n      if (typeof r === `boolean` && !r) break;\r\n    }\r\n  }\r\n};\r\n\r\nexport type RepeatPredicate = (repeats:number, valuesProduced:number)=>boolean;\r\n/**\r\n * Runs `fn` a certain number of times, accumulating result into an array.\r\n * If `fn` returns undefined, the result is ignored.\r\n * \r\n * ```js\r\n * // Results will be an array with five random numbers\r\n * const results = repeat(5, () => Math.random());\r\n * ```\r\n * \r\n * Repeats can be specified as an integer (eg. 5 for five repeats), or a function\r\n * that gives _false_ when repeating should stop.\r\n * \r\n * ```js\r\n * // Keep running `fn` until we've accumulated 10 values\r\n * // Useful if `fn` sometimes returns _undefined_\r\n * const results = repeat((repeats, valuesProduced) => valuesProduced < 10, fn);\r\n * ```\r\n * \r\n * If you don't need to accumulate return values, consider {@link Generators.count | Generators.count} with {@link Flow.forEach | Flow.forEach}.\r\n * \r\n * @param countOrPredicate Number of repeats or function returning false when to stop \r\n * @param fn Function to run, must return a value to accumulate into array or _undefined_\r\n * @returns Array of accumulated results\r\n */\r\nexport const repeat = <V>(countOrPredicate:number|RepeatPredicate, fn:()=>V|undefined):readonly V[] => {\r\n  // Unit tested: expected return array length\r\n  //eslint-disable-next-line functional/no-let\r\n  let repeats, valuesProduced;\r\n  repeats = valuesProduced = 0;\r\n  const ret = [];\r\n\r\n  if (typeof countOrPredicate === `number`) {\r\n    guardNumber(countOrPredicate, `positive`, `countOrPredicate`);\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (countOrPredicate-- > 0) {\r\n      repeats++;\r\n      const v = fn();\r\n      if (v === undefined) continue;\r\n      //eslint-disable-next-line functional/immutable-data\r\n      ret.push(v);\r\n      valuesProduced++;\r\n    }\r\n  } else {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (countOrPredicate(repeats, valuesProduced)) {\r\n      repeats++;\r\n      const v = fn();\r\n      if (v === undefined) continue;\r\n      //eslint-disable-next-line functional/immutable-data\r\n      ret.push(v);\r\n      valuesProduced++;\r\n    }\r\n  }\r\n  return ret;\r\n};\r\n\r\n\r\ntry {\r\n  if (typeof window !== `undefined`) {\r\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\r\n    (window as any).ixfx = {...(window as any).ixfx, Flow: {StateMachine, Timer, forEach, forEachAsync, repeat}};\r\n  }\r\n} catch { /* no-op */ }\r\n","import {clamp} from '../data/Clamp.js';\r\nimport {HasCompletion} from './index.js';\r\n/**\r\n * Creates a timer\r\n */\r\nexport type TimerSource = () => Timer;\r\n \r\n/**\r\n * A timer instance\r\n */\r\nexport type Timer = {\r\n  reset(): void\r\n  get elapsed(): number\r\n}\r\n\r\nexport type ModTimer = Timer & {\r\n  mod(amt:number):void\r\n}\r\n\r\n\r\nexport const frequencyTimerSource = (frequency:number):TimerSource => () => frequencyTimer(frequency, msElapsedTimer());\r\n\r\n/**\r\n * Wraps a timer, returning a relative elapsed value.\r\n * \r\n * ```js\r\n * let t = relativeTimer(1000, msElapsedTimer());\r\n * ```\r\n * \r\n * @private\r\n * @param total \r\n * @param timer \r\n * @param clampValue If true, returned value never exceeds 1.0 \r\n * @returns \r\n */\r\nexport const relativeTimer = (total:number, timer: Timer, clampValue = true):ModTimer & HasCompletion => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let done = false;\r\n  //eslint-disable-next-line functional/no-let\r\n  let modAmt = 1;\r\n\r\n  return {\r\n    mod(amt:number) {\r\n      modAmt = amt;\r\n    },\r\n    get isDone() {\r\n      return done;\r\n    },\r\n    reset:() => {\r\n      done = false;\r\n      timer.reset();\r\n    },\r\n    get elapsed() {\r\n      //eslint-disable-next-line functional/no-let\r\n      let v = timer.elapsed / (total * modAmt);\r\n      if (clampValue) v = clamp(v);\r\n      if (v >= 1) done = true;\r\n      return v;\r\n    }\r\n  };\r\n};\r\n\r\n  \r\nexport const frequencyTimer = (frequency:number, timer:Timer = msElapsedTimer()):ModTimer => {\r\n  const cyclesPerSecond = frequency/1000;\r\n  //eslint-disable-next-line functional/no-let\r\n  let modAmt = 1;\r\n  return {\r\n    mod:(amt:number) => {\r\n      modAmt = amt;\r\n    },\r\n    reset:() => {\r\n      timer.reset();\r\n    },\r\n    get elapsed() {\r\n      // Get position in a cycle\r\n      const v = timer.elapsed * (cyclesPerSecond * modAmt);\r\n\r\n      // Get fractional part\r\n      const f = v - Math.floor(v);\r\n      if (f < 0) throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v} f: ${f}`);\r\n      if (f > 1) throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v} f: ${f}`);\r\n      return f;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * A timer that uses clock time\r\n * @private\r\n * @returns {Timer}\r\n */\r\nexport const msElapsedTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    get elapsed() {\r\n      return performance.now() - start;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * A timer that progresses with each call\r\n * @private\r\n * @returns {Timer}\r\n */\r\nexport const ticksElapsedTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    get elapsed() { return start++; }\r\n  };\r\n};\r\n","/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * @example Usage\r\n * ```js\r\n * // 0.5 - just fine, within default of 0 to 1\r\n * clamp(0.5);         \r\n * // 1 - above default max of 1\r\n * clamp(1.5);         \r\n * // 0 - below range\r\n * clamp(-50, 0, 100); \r\n * // 50 - within range\r\n * clamp(50, 0, 50);   \r\n * ```\r\n * \r\n * For clamping integer ranges, consider {@link clampIndex }\r\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\r\n * \r\n * @param v Value to clamp\r\n * @param Minimum value (inclusive)\r\n * @param Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\r\n * Returns value then will always be at least zero, and a valid array index.\r\n * \r\n * @example Usage\r\n * ```js\r\n * // Array of length 4\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampIndex(0, myArray);    // 0\r\n * clampIndex(4, myArray);    // 3\r\n * clampIndex(-1, myArray);   // 0\r\n * \r\n * clampIndex(5, 3); // 2\r\n * ```\r\n * \r\n * Throws an error if `v` is not an integer.\r\n * \r\n * For some data it makes sense that data might 'wrap around' if it exceeds the\r\n * range. For example rotation angle. Consider using {@link wrap} for this.\r\n * \r\n * @param v Value to clamp (must be an interger)\r\n * @param arrayOrLength Array, or length of bounds (must be an integer)\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const clampIndex = (v: number, arrayOrLength: number|readonly any[]):number => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  const length = (Array.isArray(arrayOrLength)) ?  arrayOrLength.length : arrayOrLength as number;\r\n\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};","import {integer as guardInteger} from '../Guards.js';\r\nimport {HasCompletion} from './index.js';\r\n\r\nexport type TimeoutSyncCallback = (elapsedMs?:number, ...args:readonly unknown[]) => void\r\nexport type TimeoutAsyncCallback = (elapsedMs?:number, ...args:readonly unknown[]) => Promise<void>\r\n\r\n/**\r\n * A resettable timeout, returned by {@link timeout}\r\n */\r\nexport type Timeout = HasCompletion & {\r\n  start(altTimeoutMs?: number, args?:readonly unknown[]): void;\r\n  cancel(): void;\r\n  get isDone(): boolean;\r\n}\r\n\r\n\r\n/**\r\n * Returns a {@link Timeout} that can be triggered, cancelled and reset\r\n *  \r\n * Once `start()` is called, `callback` will be scheduled to execute after `timeoutMs`.\r\n * If `start()` is called again, the waiting period will be reset to `timeoutMs`.\r\n * \r\n * @example Essential functionality\r\n * ```js\r\n * const fn = () => {\r\n *  console.log(`Executed`);\r\n * };\r\n * const t = timeout(fn, 60*1000); \r\n * t.start();   // After 1 minute `fn` will run, printing to the console\r\n * ```\r\n * \r\n * @example Control execution functionality\r\n * ```\r\n * t.cancel();  // Cancel it from running\r\n * t.start();   // Schedule again after 1 minute\r\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\r\n * t.isDone;    // True if a scheduled event is pending\r\n * ```\r\n * \r\n * Callback function receives any additional parameters passed in from start.\r\n * This can be useful for passing through event data:\r\n * \r\n * @example\r\n * ```js\r\n * const t = timeout( (elapsedMs, ...args) => {\r\n *  // args contains event data\r\n * }, 1000);\r\n * el.addEventListener(`click`, t.start);\r\n * ```\r\n * \r\n * Asynchronous callbacks can be used as well:\r\n * ```js\r\n * timeout(async () => {...}, 100);\r\n * ```\r\n * \r\n * If you don't expect to need to control the timeout, consider using {@link delay},\r\n * which can run a given function after a specified delay.\r\n * @param callback \r\n * @param timeoutMs \r\n * @returns {@link Timeout}\r\n */\r\nexport const timeout = (callback:TimeoutSyncCallback|TimeoutAsyncCallback, timeoutMs:number):Timeout => {\r\n  if (callback === undefined) throw new Error(`callback parameter is undefined`);\r\n  guardInteger(timeoutMs, `aboveZero`, `timeoutMs`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let timer = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let startedAt = 0;\r\n  const start = async (altTimeoutMs:number = timeoutMs, args:unknown[]):Promise<void> => {\r\n    \r\n    const p = new Promise<void>((resolve, reject) => {\r\n      startedAt = performance.now();\r\n      try {\r\n        guardInteger(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\r\n      } catch (e) {\r\n        reject(e);\r\n        return;\r\n      }\r\n      if (timer !== 0) cancel();\r\n      timer = window.setTimeout(async () => {\r\n        await callback(performance.now() - startedAt, ...args);\r\n        timer = 0;\r\n        resolve(undefined); \r\n      }, altTimeoutMs);\r\n    });\r\n    return p;\r\n  };\r\n\r\n  const cancel = () => {\r\n    if (timer === 0) return;\r\n    startedAt = 0;\r\n    window.clearTimeout(timer);\r\n  };\r\n\r\n  return {\r\n    start,\r\n    cancel,\r\n    get isDone() {\r\n      return timer !== 0;\r\n    },\r\n  };\r\n};\r\n","\r\nexport type UpdateFailPolicy = `fast` | `slow` | `backoff`; \r\n/**\r\n * Calls the async `fn` to generate a value if there is no prior value or\r\n * `intervalMs` has elapsed since value was last generated.\r\n * @example\r\n * ```js\r\n * const f = updateOutdated(async () => {\r\n *  const r = await fetch(`blah`);\r\n *  return await r.json();\r\n * }, 60*1000);\r\n * \r\n * // Result will be JSON from fetch. If fetch happened already in the\r\n * // last 60s, return cached result. Otherwise it will fetch data\r\n * const result = await f();\r\n * ```\r\n * \r\n * Callback `fn` is passed how many milliseconds have elapsed since last update. It's\r\n * minimum value will be `intervalMs`.\r\n * \r\n * ```js\r\n * const f = updateOutdated(async elapsedMs => {\r\n *  // Do something with elapsedMs?\r\n * }, 60*1000;\r\n * ```\r\n * \r\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\r\n * * `fast`: Invocation will happen immediately on next attempt\r\n * * `slow`: Next invocation will wait `intervalMs` as if it was successful\r\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\r\n * \r\n * @param fn Async function to call. Must return a value.\r\n * @param intervalMs Maximum age of cached result\r\n * @param updateFail `slow` by default\r\n * @returns Value\r\n */\r\nexport const updateOutdated = <V>(fn:(elapsedMs?:number)=>Promise<V>, intervalMs:number, updateFail:UpdateFailPolicy = `slow`):()=>Promise<V> => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let lastRun = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let lastValue:V|undefined;\r\n  //eslint-disable-next-line functional/no-let\r\n  let intervalMsCurrent = intervalMs;\r\n\r\n  //eslint-disable-next-line no-async-promise-executor\r\n  return () => (new Promise(async (resolve, reject) => {\r\n    const elapsed = performance.now() - lastRun;\r\n    if (lastValue === undefined || elapsed > intervalMsCurrent) {\r\n      try {\r\n        lastRun = performance.now();\r\n        lastValue = await fn(elapsed);\r\n        intervalMsCurrent = intervalMs;\r\n      } catch (ex) {\r\n        if (updateFail === `fast`) {\r\n          lastValue = undefined;\r\n          lastRun = 0;\r\n        } else if (updateFail === `backoff`) {\r\n          intervalMsCurrent = Math.floor(intervalMsCurrent*1.2);\r\n        }\r\n        reject(ex);\r\n        return;\r\n      }\r\n    } \r\n    resolve(lastValue);\r\n  }));\r\n};","import {integer as guardInteger} from '../Guards.js';\r\nimport {HasCompletion} from './index.js';\r\n\r\n/**\r\n * Runs a function continuously, returned by {@link Continuously}\r\n */\r\nexport type Continuously = HasCompletion & {\r\n  /**\r\n   * Starts loop. If already running, it is reset\r\n   */\r\n  start(): void\r\n  /**\r\n   * How many milliseconds since start() was last called\r\n   */\r\n  get elapsedMs(): number\r\n  /**\r\n   * How many iterations of the loop since start() was last called\r\n   */\r\n  get ticks(): number\r\n  /**\r\n   * Whether loop has finished\r\n   */\r\n  get isDone(): boolean\r\n  /**\r\n   * Stops loop\r\n   */\r\n  cancel(): void\r\n}\r\n\r\nexport type ContinuouslySyncCallback = (ticks?:number, elapsedMs?:number) => boolean|void\r\nexport type ContinuouslyAsyncCallback = (ticks?:number, elapsedMs?:number) => Promise<boolean|void>\r\n\r\n/**\r\n * Returns a {@link Continuously} that continuously executes `callback`. \r\n * If callback returns _false_, loop exits.\r\n * \r\n * Call `start` to begin/reset loop. `cancel` stops loop.\r\n * \r\n * @example Animation loop\r\n * ```js\r\n * const draw = () => {\r\n *  // Draw on canvas\r\n * }\r\n * \r\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\r\n * continuously(draw).start();  \r\n * ```\r\n * \r\n * @example With delay\r\n * ```js\r\n * const fn = () => {\r\n *  console.log(`1 minute`);\r\n * }\r\n * const c = continuously(fn, 60*1000);\r\n * c.start(); // Runs `fn` every minute\r\n * ```\r\n * \r\n * @example Control a 'continuously'\r\n * ```js\r\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\r\n * c.elapsedMs;  // How many milliseconds have elapsed since start\r\n * c.ticks;      // How many iterations of loop since start\r\n * ```\r\n * \r\n * Asynchronous callback functions are supported too:\r\n * ```js\r\n * continuously(async () => { ..});\r\n * ```\r\n * \r\n * The `callback` function can receive a few arguments:\r\n * ```js\r\n * continuously( (ticks, elapsedMs) => {\r\n *  // ticks: how many times loop has run\r\n *  // elapsedMs:  how long since last loop\r\n * }).start();\r\n * ```\r\n * \r\n * And if `callback` explicitly returns _false_, the loop will exit:\r\n * ```js\r\n * continuously((ticks) => {\r\n *  // Stop after 100 iterations\r\n *  if (ticks > 100) return false;\r\n * }).start();\r\n * ```\r\n * @param callback Function to run. If it returns false, loop exits.\r\n * @param resetCallback Callback when/if loop is reset. If it returns false, loop exits\r\n * @param intervalMs \r\n * @returns \r\n */\r\nexport const continuously = (callback:ContinuouslyAsyncCallback|ContinuouslySyncCallback, intervalMs?:number, resetCallback?:((ticks?:number, elapsedMs?:number) => boolean|void)):Continuously => {\r\n  if (intervalMs !== undefined) guardInteger(intervalMs, `positive`, `intervalMs`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let running = false;\r\n  //eslint-disable-next-line functional/no-let\r\n  let ticks = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let startedAt = performance.now();\r\n  const schedule = (intervalMs === undefined || intervalMs === 0) ? (cb:()=>void) => window.requestAnimationFrame(cb) : (cb:()=>void) => window.setTimeout(cb, intervalMs);\r\n  const cancel = () => {\r\n    if (!running) return;\r\n    running = false;\r\n    ticks = 0;\r\n  };\r\n\r\n  const loop = async () => {\r\n    if (!running) return;\r\n    const valOrPromise = callback(ticks++, performance.now() - startedAt);\r\n    //eslint-disable-next-line functional/no-let\r\n    let val;\r\n    if (typeof valOrPromise === `object`) {\r\n      val = await valOrPromise;\r\n    } else {\r\n      val = valOrPromise;\r\n    }\r\n    if (val !== undefined && !val) {\r\n      cancel();\r\n      return;\r\n    }\r\n\r\n    schedule(loop);\r\n  };\r\n\r\n  const start = () => {\r\n    // Already running, but theres a resetCallback to check if we should keep going\r\n    if (running && resetCallback !== undefined) {\r\n      const r = resetCallback(ticks, performance.now() - startedAt);\r\n      startedAt = performance.now();\r\n      if (r !== undefined && !r) {\r\n        // Reset callback tells us to stop\r\n        cancel();\r\n        return; // Skip starting again\r\n      } \r\n    } else if (running) {\r\n      return; // already running\r\n    }\r\n\r\n    // Start running\r\n    running = true;\r\n    schedule(loop);\r\n  };\r\n\r\n  return {\r\n    start,\r\n    get isDone() {\r\n      return !running;\r\n    },\r\n    get ticks() {\r\n      return ticks;\r\n    },\r\n    get elapsedMs() {\r\n      return performance.now() - startedAt;\r\n    },\r\n    cancel\r\n  };\r\n};","import {timeout, TimeoutSyncCallback, TimeoutAsyncCallback} from \"./Timeout.js\";\r\n\r\n/**\r\n * Returns a debounce function which acts to filter calls to a given function `fn`.\r\n * \r\n * Eg, Let's create a debounced wrapped for a function:\r\n * ```js\r\n * const fn = () => console.log('Hello');\r\n * const debouncedFn = debounce(fn, 1000);\r\n * ```\r\n * \r\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\r\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\r\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\r\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\r\n * is faster than the provided timeout.\r\n * \r\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\r\n * \r\n * ```js\r\n * // Create\r\n * const d = debounce(fn, 1000);\r\n * \r\n * // Don't do this if we want to benefit from the debounce\r\n * fn();\r\n * \r\n * // Use the debounced wrapper\r\n * d(); // Only calls fn after 1000s\r\n * ```\r\n * \r\n * A practical use for this is handling high-frequency streams of data, where we don't really\r\n * care about processing every event, only last event after a period. Debouncing is commonly\r\n * used on microcontrollers to prevent button presses being counted twice.\r\n * \r\n * @example Handle most recent pointermove event after 1000ms\r\n * ```js\r\n * // Set up debounced handler\r\n * const moveDebounced = debounce((elapsedMs, evt) => {\r\n *    // Handle event\r\n * }, 500);\r\n * \r\n * // Wire up event\r\n * el.addEventListener(`pointermove`, moveDebounced);\r\n * ```\r\n * \r\n * Arguments can be passed to the debounced function:\r\n * \r\n * ```js\r\n * const fn = (x) => console.log(x);\r\n * const d = debounce(fn, 1000);\r\n * d(10);\r\n * ```\r\n * \r\n * If the provided function is asynchronous, it's possible to await the debounced\r\n * version as well. If the invocation was filtered, it returns instantly.\r\n * \r\n * ```js\r\n * const d = debounce(fn, 1000);\r\n * await d();\r\n * ```\r\n * @param callback Function to filter access to\r\n * @param timeoutMs Minimum time between invocations\r\n * @returns Debounce function\r\n */\r\nexport const debounce = (callback:TimeoutSyncCallback|TimeoutAsyncCallback, timeoutMs:number):DebouncedFunction => {\r\n  const t = timeout(callback, timeoutMs);\r\n  return (...args:unknown[]) => t.start(undefined, args);\r\n};\r\n\r\n/**\r\n * Debounced function\r\n */\r\nexport type DebouncedFunction = (...args:readonly unknown[]) =>void\r\n","/***\r\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\r\n * \r\n * @example Only handle move event every 500ms\r\n * ```js\r\n * const moveThrottled = throttle( (elapsedMs, args) => {\r\n *  // Handle ar\r\n * }, 500);\r\n * el.addEventListener(`pointermove`, moveThrottled)\r\n * ```\r\n * \r\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\r\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\r\n * that the return function from `throttle` is repeatedly called, such as the case for handling\r\n * a stream of data/events.\r\n * \r\n * @example Manual trigger\r\n * ```js\r\n * // Set up once\r\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\r\n * \r\n * // Later, trigger throttle. Sometimes the callback will run,\r\n * // with data passed in to args[0]\r\n * t(data);\r\n * ```\r\n */\r\nexport const throttle = (callback:(elapsedMs:number, ...args:readonly unknown[]) => void|Promise<unknown>, intervalMinMs:number) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let trigger = 0;\r\n\r\n  return async (...args:unknown[]) => {\r\n    const elapsed = performance.now()-trigger; \r\n    if (elapsed >= intervalMinMs) {\r\n      const r = callback(elapsed, ...args);\r\n      if (typeof r === `object`) await r;\r\n      trigger = performance.now();\r\n    }\r\n  };\r\n};","\r\n/**\r\n * Helper function for calling code that should fail after a timeout.\r\n * In short, it allows you to signal when the function succeeded, to cancel it, or\r\n * to be notified if it was canceled or completes.\r\n * \r\n * \r\n * @example Verbose example\r\n * ```js\r\n * // This function is called by `waitFor` if it was cancelled\r\n * const onAborted = (reason:string) => {\r\n *  // 'reason' is a string describing why it has aborted.\r\n *  // ie: due to timeout or because done() was called with an error\r\n * };\r\n * \r\n * // This function is called by `waitFor` if it completed\r\n * const onComplete = (success:boolean) => {\r\n *  // Called if we were aborted or finished succesfully.\r\n *  // onComplete will be called after onAborted, if it was an error case\r\n * }\r\n * \r\n * // If done() is not called after 1000, onAborted will be called\r\n * // if done() is called or there was a timeout, onComplete is called\r\n * const done = waitFor(1000, onAborted, onComplete);\r\n * \r\n * // Signal completed successfully (thus calling onComplete(true))\r\n * done();\r\n * \r\n * // Signal there was an error (thus calling onAborted and onComplete(false))\r\n * done(`Some error`);\r\n * ```\r\n * \r\n * The completion handler is useful for removing event handlers.\r\n * \r\n * @example Compact example\r\n * ```js\r\n * const done = waitFor(1000, \r\n *  (reason) => {\r\n *    console.log(`Aborted: ${reason}`);\r\n *  },\r\n *  (success) => {\r\n *    console.log(`Completed. Success: ${success ?? `Yes!` : `No`}`)\r\n *  });\r\n * \r\n * try {\r\n *  runSomethingThatMightScrewUp();\r\n *  done(); // Signal it succeeded\r\n * } catch (e) {\r\n *  done(e); // Signal there was an error\r\n * }\r\n * ```\r\n * @param timeoutMs \r\n * @param onAborted \r\n * @param onComplete \r\n * @returns \r\n */\r\nexport const waitFor = (timeoutMs:number, onAborted:(reason:string)=>void, onComplete?:(success:boolean)=>void) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let success = false;\r\n  const done = (error?:string) => {\r\n    if (t !== 0) {\r\n      window.clearTimeout(t);\r\n      t = 0;\r\n    }\r\n    if (error) {\r\n      onAborted(error); \r\n    } else {\r\n      success = true;\r\n    }\r\n    if (onComplete !== undefined) onComplete(success);\r\n  };\r\n  \r\n  //eslint-disable-next-line functional/no-let\r\n  let t = window.setTimeout(() => {\r\n    t = 0;\r\n    try {\r\n      onAborted(`Timeout after ${timeoutMs}ms`);\r\n    } finally {\r\n      if (onComplete !== undefined) onComplete(success);\r\n    }\r\n  }, timeoutMs);\r\n\r\n  return done;\r\n};"],"mappings":"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","names":[]}