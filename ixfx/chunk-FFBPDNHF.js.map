{"version":3,"sources":["../src/Generators.ts","../src/modulation/PingPong.ts"],"sourcesContent":["// import {sleep} from \"./Timer.js\";\r\nimport {sleep} from \"./flow/Timer.js\";\r\nimport {number as guardNumber, integer as guardInteger} from \"./Guards.js\";\r\nexport {pingPong, pingPongPercent} from './modulation/PingPong.js';\r\n\r\n/**\r\n * Generates a range of numbers, starting from `start` and coutnting by `interval`.\r\n * If `end` is provided, generator stops when reached.\r\n * \r\n * Unlike numericRange, numbers might contain rounding errors\r\n * \r\n * ```js\r\n * for (const c of numericRangeRaw(10, 100)) {\r\n *  // 100, 110, 120 ...\r\n * }\r\n * ```\r\n * @param interval Interval between numbers\r\n * @param start Start\r\n * @param end End (if undefined, range never ends)\r\n */\r\nexport const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = start;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\r\n * If `fn` returns _false_, iterator cancels. \r\n * \r\n * @example\r\n * ```js\r\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\r\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\r\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\r\n * ```\r\n * \r\n * Use `forEachAsync` if you want to use an async `iterator` and async `fn`.\r\n * @param iterator Iterable or array\r\n * @param fn Function to call for each item. If function returns false, iteration cancels\r\n */\r\nexport const forEach = <V>(iterator:IterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>boolean|void) => {\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const x of iterator) {\r\n    const r = fn(x);\r\n    if (typeof r === `boolean` && !r) break;\r\n  }\r\n};\r\n\r\n/**\r\n * Iterates over an async iterable, calling `fn` for each value, with optional\r\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\r\n * \r\n * Use `forEach` for a synchronous version.\r\n * \r\n * ```js\r\n * // Prints items from array evry second\r\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\r\n * ```\r\n * @param iterator \r\n * @param fn \r\n */\r\nexport const forEachAsync = async function <V> (iterator:AsyncIterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>Promise<boolean>|void, intervalMs?:number) {\r\n  if (Array.isArray(iterator)) {\r\n    // Handle array\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const x of iterator) {\r\n      const r = await fn(x);\r\n      if (intervalMs) await sleep(intervalMs);\r\n      if (typeof r === `boolean` && !r) break;\r\n    }\r\n  } else {\r\n    // Handle an async iterator\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for await (const x of iterator) {\r\n      const r = await fn(x);\r\n      if (intervalMs) await sleep(intervalMs);\r\n      if (typeof r === `boolean` && !r) break;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n *\r\n * @example For-loop\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * \r\n * @example If you want more control over when/where incrementing happens...\r\n * ```js\r\n * let percent = numericRange(0.1, 0, 1);\r\n * \r\n * let percentResult = percent.next().value;\r\n * ```\r\n * \r\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\r\n * number.\r\n * \r\n * @param interval Interval between numbers\r\n * @param start Start. Defaults to 0\r\n * @param end End (if undefined, range never ends)\r\n * @param repeating Range loops from start indefinately. Default _false_\r\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  guardNumber(interval,  `nonZero`);\r\n  \r\n  const negativeInterval = interval < 0;\r\n  if (end === undefined) {\r\n    /* no op */\r\n  } else {\r\n    if (negativeInterval && start < end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\r\n    if (!negativeInterval && start > end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\r\n  }\r\n\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    //eslint-disable-next-line functional/no-let\r\n    let v = start * rounding;\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\r\n * count decreases. If `offset` is provided, this is added to the return result.\r\n * @example\r\n * ```js\r\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\r\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\r\n * for (const v of count(5, 5)) {\r\n *  // Yields: 5, 6, 7, 8, 9\r\n * }\r\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\r\n * ```\r\n * \r\n * @example Used with forEach\r\n * ```js\r\n * // Prints `Hi` 5x\r\n * forEach(count(5), () => console.log(`Hi`));\r\n * ```\r\n * \r\n * If you want to accumulate return values, consider using\r\n * {@link repeat}.\r\n * @param amount Number of integers to yield \r\n * @param offset Added to result\r\n */\r\nexport const count = function* (amount:number, offset:number = 0) {\r\n  // Unit tested.\r\n  guardInteger(amount, ``, `amount`);\r\n  guardInteger(offset, ``, `offset`);\r\n\r\n  if (amount === 0) return;\r\n  \r\n  //eslint-disable-next-line functional/no-let\r\n  let i = 0;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    if (amount < 0) yield -i + offset;\r\n    else yield i + offset;\r\n  } while (i++ < Math.abs(amount) - 1);\r\n};\r\n\r\n/**\r\n * Returns a non-repeating number range between 0.0-1.0. \r\n * \r\n * If `repeating` is true, it loops back to 0 after reaching 1\r\n * @param interval Interval (default: 0.01, ie. 1%)\r\n * @param repeating Whether generator should loop (default: false)\r\n * @param start Start (default: 0)\r\n * @param end End (default: 1)\r\n * @returns \r\n */\r\nexport const rangePercent = function (interval:number = 0.01, repeating:boolean = false, start:number = 0, end = 1) {\r\n  guardNumber(interval, `percentage`, `interval`);\r\n  guardNumber(start, `percentage`, `start`);\r\n  guardNumber(end, `percentage`, `end`);\r\n  return numericRange(interval, start, end, repeating);\r\n};\r\n\r\n\r\n// export const gaussian = function*(mean:number, std:number, stepLength:number = 0.1) {\r\n//   const a = 1/Math.sqrt(2*Math.PI);\r\n\r\n//   const get = (x:number) => {\r\n//     var f = a / std;\r\n//     var p = -1/2;\r\n//     var c = (x-mean)/std;\r\n//     c *= c;\r\n//     p *= c;\r\n//     return f * Math.pow(Math.E, p);\r\n//   }\r\n\r\n//   for (let i=-1;i<1;i+=stepLength) {\r\n//     yield(get(i));\r\n//   }\r\n// }","import {number as guardNumber} from \"../Guards.js\";\r\n\r\n/**\r\n * Continually loops up and down between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * @example Usage\r\n * ```js\r\n * for (const v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * @example Alternative:\r\n * ```js\r\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\r\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\r\n * ```\r\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\r\n * ```\r\n * @param interval Amount to increment by. Defaults to 10%\r\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, lower?: number, upper?: number, start?: number, rounding: number = 1000) {\r\n  if (lower === undefined) lower = 0;\r\n  if (upper === undefined) upper = 1;\r\n  if (start === undefined) start = lower;\r\n  guardNumber(interval, `bipolar`, `interval`);\r\n  guardNumber(upper, `bipolar`, `end`);\r\n  guardNumber(start, `bipolar`, `offset`);\r\n  guardNumber(lower, `bipolar`, `start`);\r\n  return pingPong(interval, lower, upper, start, rounding);\r\n};\r\n\r\n/**\r\n * Ping-pongs continually back and forth `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * In a loop:\r\n * ```\r\n * for (const c of pingPong(10, 0, 100)) {\r\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\r\n * }\r\n * ```\r\n * \r\n * Manual:\r\n * ```\r\n * const pp = pingPong(10, 0, 100);\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * @param interval Amount to increment by. Use negative numbers to start counting down\r\n * @param lower Lower bound (inclusive)\r\n * @param upper Upper bound (inclusive, must be greater than start)\r\n * @param start Starting point within bounds (defaults to `lower`)\r\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, start?: number, rounding: number = 1) {\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (start === undefined) start = lower;\r\n  else start = Math.floor(start * rounding);\r\n  if (start > upper || start < lower) throw new Error(`Start (${start/rounding}) must be within lower (${lower/rounding}) and upper (${upper/rounding})`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = start;\r\n  yield v / rounding;\r\n  //eslint-disable-next-line functional/no-let\r\n  let firstLoop = true;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n"],"mappings":"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","names":[]}