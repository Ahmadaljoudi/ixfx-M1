{"version":3,"sources":["../src/IterableAsync.ts"],"sourcesContent":["import {IsEqual} from \"./Util\";\n\n/**\n * Breaks an iterable into array chunks\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it \n * @param size \n */\n//eslint-disable-next-line func-style\nexport async function* chunks<V>(it:Iterable<V>, size:number) {\n  // Source: https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  let buffer = [];\n  for await (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n/**\n * Return concatenation of iterators\n * @param its \n */\n//eslint-disable-next-line func-style\nexport async function* concat<V>(...its:readonly Iterable<V>[]) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\n/**\n * Drops elements that do not meet the predicate `f`.\n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport async function* dropWhile<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  //const iit = it[Symbol.asyncIterator]();\n  for await (const v of it) { \n    if (!f(v)) {\n      yield v;\n      break;\n    }\n  }\n  yield* it;\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1 \n * @param it2 \n * @param equality \n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function equals<V>(it1:Iterable<V>, it2:Iterable<V>, equality?:IsEqual<V>) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[Symbol.iterator]();\n  const iit2 = it2[Symbol.iterator]();\n  //eslint-disable-next-line no-constant-condition\n  while (true) {\n    const i1 = await iit1.next(), i2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(i1.value, i2.value)) return false;\n    } else if (i1.value !== i2.value) return false;\n    if (i1.done || i2.done) return i1.done && i2.done;\n  }\n}\n\n/**\n * Returns _true_ if `f` returns _true_ for \n * every item in iterable\n * @param it \n * @param f \n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function every<V>(it:Iterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  let ok = true;\n  for await (const v of it) ok = ok && f(v);\n  return ok;\n}\n\n/**\n * Yields `v` for each item within `it`.\n * \n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n * @param it \n * @param v \n */\n//eslint-disable-next-line func-style\nexport async function* fill<V>(it:AsyncIterable<V>, v:V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, returning items which match `f`.\n * \n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport async function* filter<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n * @param it \n * @param f \n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function find<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) { \n    if (f(v)) return v;\n  } \n}\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it \n */\n//eslint-disable-next-line func-style\nexport async function* flatten<V>(it:AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (Symbol.asyncIterator in v) { \n      // @ts-ignore\n      yield* v;\n    } else {\n      yield v;\n    }\n  }\n}\n\n/**\n * Execute function `f` for each item in iterable\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport async function forEach<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) f(v);\n}\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport async function* map<V, X>(it:AsyncIterable<V>, f:(v:V) => X) {\n  // https://surma.github.io/underdash/\n  \n  for await (const v of it) { \n    yield f(v);\n  }\n}\n\n/**\n * Returns the maximum seen of an iterable\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:1, v:-9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function max<V>(it:AsyncIterable<V>, gt = (a:V, b:V) => a > b) {\n  // https://surma.github.io/underdash/\n  \n  //eslint-disable-next-line functional/no-let\n  let max;\n  \n  for await (const v of it) {\n    if(!max) {\n      max = v;\n      continue;\n    }\n    max = gt(max, v)?max:v;\n  }\n  return max;\n}\n\n/**\n * Returns the minimum seen of an iterable\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function min<V>(it:AsyncIterable<V>, gt = (a:V, b:V) => a > b) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  let min;\n  \n  for await (const v of it) {\n    if(!min) {\n      min = v;\n      continue;\n    }\n    min = gt(min, v)?v:min;\n  }\n  return min;\n}\n\n/**\n * Returns count from `start` for a given length\n * ```js\n * range(-5, 10);\n * // Yields: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n * ```\n * @param start \n * @param len \n */\n//eslint-disable-next-line func-style\nexport async function* range(start:number, len:number) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  for (let i=0;i<len;i++) {\n    yield start++;\n  }\n  //for (let i=len;len > 0; len--) yield start++;\n}\n\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function reduce<V>(it:AsyncIterable<V>, f:(acc:V, current:V) => V, start:V) {\n  // https://surma.github.io/underdash/\n  \n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Returns a section from an iterable\n * @param it Iterable\n * @param start Start index\n * @param end End index (or until completion)\n */\n//eslint-disable-next-line func-style\nexport async function* slice<V>(it:AsyncIterable<V>, start = 0, end = Number.POSITIVE_INFINITY) {\n  // https://surma.github.io/underdash/\n  const iit = it[Symbol.asyncIterator]();\n  \n  for(; start > 0; start--, end--) await iit.next();\n  \n  for await (const v of it) { \n    if (end-- > 0) { \n      yield v;\n    } else { \n      break; \n    } \n  }\n}\n\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly \n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function some<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  \n  for await (const v of it) { \n    if (f(v)) return true;\n  }\n  return false;\n}\n\n/**\n * Returns items for which the filter function returns _true_\n * ```js\n * takeWhile([ 1, 2, 3, 4 ], e => e < 3);\n * // Yields: [ 1, 2 ]\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function* takeWhile<V>(it:AsyncIterable<V>, f:(v:V) => boolean) {\n  // https://surma.github.io/underdash/\n  \n  for await (const v of it) {\n    if (!f(v)) return;\n    yield v;\n  }\n}\n\n/**\n * Returns an array of values from an iterator.\n * \n * ```js\n * const data = await toArray(adsrSample(opts, 10));\n * ```\n * \n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n * \n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function toArray<V>(it:AsyncIterable<V>, count = Infinity):Promise<readonly V[]> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result = [];\n  const iterator = it[Symbol.asyncIterator]();\n  \n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(value);\n  }\n  return result;\n\n}\n\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport async function* unique<V>(it:AsyncIterable<V>, f:((id:V) => V) = id => id) {\n  // https://surma.github.io/underdash/\n  const buffer = [];\n  \n  for await (const v of it) {\n    const fv = f(v);\n    if (buffer.indexOf(fv) !== -1) continue;\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(fv);\n    yield v;\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its \n * @returns \n */\n//eslint-disable-next-line func-style\nexport async function* zip<V>(...its:readonly AsyncIterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map(it => it[Symbol.asyncIterator]());\n  \n  while(true) {\n    const vs = await Promise.all(iits.map(it => it.next()));\n    if (vs.some(v => v.done)) return;\n    yield vs.map(v => v.value);\n  }\n}"],"mappings":"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","names":[]}