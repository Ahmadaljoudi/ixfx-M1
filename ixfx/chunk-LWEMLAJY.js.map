{"version":3,"sources":["../src/flow/Sleep.ts","../src/flow/Interval.ts","../src/flow/Delay.ts"],"sourcesContent":["import {integer as guardInteger} from '../Guards.js';\r\n/**\r\n * Returns after `timeoutMs`. \r\n * \r\n * @example In an async function\r\n * ```js\r\n * console.log(`Hello`);\r\n * await sleep(1000);\r\n * console.log(`There`); // Prints one second after\r\n * ```\r\n * \r\n * @example As a promise\r\n * ```js\r\n * console.log(`Hello`);\r\n * sleep(1000)\r\n *  .then(() => console.log(`There`)); // Prints one second after\r\n * ```\r\n * \r\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\r\n * \r\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\r\n * \r\n * @param timeoutMs\r\n * @return\r\n */\r\nexport const sleep = <V>(timeoutMs: number, value?:V): Promise<V|undefined> => {\r\n  guardInteger(timeoutMs, `positive`, `timeoutMs`);\r\n  if (timeoutMs === 0) {\r\n    return new Promise<V|undefined>(resolve => requestAnimationFrame(_ => {\r\n      resolve(value);\r\n    }));\r\n  } else {\r\n    return new Promise<V|undefined>(resolve => setTimeout(() => resolve(value), timeoutMs));\r\n  }\r\n};","import {sleep} from \"./Sleep.js\";\r\n\r\nexport type IntervalAsync<V> = (() => V|Promise<V>) | Generator<V>;\r\n/**\r\n * Generates values from `produce` with `intervalMs` time delay. \r\n * `produce` can be a simple function that returns a value, an async function, or a generator.\r\n * \r\n * @example Produce a random number every 500ms:\r\n * ```\r\n * const randomGenerator = interval(() => Math.random(), 1000);\r\n * for await (const r of randomGenerator) {\r\n *  // Random value every 1 second\r\n *  // Warning: does not end by itself, a `break` statement is needed\r\n * }\r\n * ```\r\n *\r\n * @example Return values from a generator every 500ms:\r\n * ```js\r\n * // Make a generator that counts to 10\r\n * const counter = count(10);\r\n * for await (const v of interval(counter, 1000)) {\r\n *  // Do something with `v`\r\n * }\r\n * ```\r\n * \r\n * If you just want to loop at a certain speed, consider using {@link continuously} instead.\r\n * @template V Returns value of `produce` function\r\n * @param intervalMs Interval between execution\r\n * @param produce Function to call\r\n * @template V Data type\r\n * @returns\r\n */\r\nexport const interval = async function*<V>(produce: IntervalAsync<V>, intervalMs: number) {\r\n  //eslint-disable-next-line functional/no-let\r\n  let cancelled = false;\r\n  try {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (!cancelled) {\r\n      await sleep(intervalMs);\r\n      if (cancelled) return;\r\n      if (typeof produce === `function`) {\r\n        // Returns V or Promise<V>\r\n        const result = await produce();\r\n        yield result;\r\n      } else if (typeof produce === `object`) {\r\n        // Generator, perhaps?\r\n        if (`next` in produce && `return` in produce && `throw` in produce) {\r\n          const result = await produce.next();\r\n          if (result.done) return;\r\n          yield result.value; \r\n        } else {\r\n          throw new Error(`interval: produce param does not seem to be a generator?`);\r\n        }\r\n      } else {\r\n        throw new Error(`produce param does not seem to return a value/Promise and is not a generator?`);\r\n      }\r\n    }\r\n  } finally {\r\n    cancelled = true;\r\n  }\r\n};","import {sleep} from \"./Sleep.js\";\r\n\r\n/**\r\n * Pauses execution for `timeoutMs` after which the asynchronous `callback` is executed and awaited.\r\n * \r\n * @example Pause and wait for function\r\n * ```js\r\n * const result = await delay(async () => Math.random(), 1000);\r\n * console.log(result); // Prints out result after one second\r\n * ```\r\n * \r\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\r\n * \r\n * @example Schedule a function without waiting\r\n * ```js\r\n * delay(async () => {\r\n *  console.log(Math.random())\r\n * }, 1000);\r\n * // Prints out a random number after 1 second.\r\n * ```\r\n * \r\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\r\n * \r\n * \r\n * If you want to be able to cancel or re-run a delayed function, consider using\r\n * {@link timeout} instead.\r\n * \r\n * @template V\r\n * @param callback What to run after `timeoutMs`\r\n * @param timeoutMs How long to delay\r\n * @return Returns result of `callback`.\r\n */\r\nexport const delay = async <V>(callback:() => Promise<V>, timeoutMs: number): Promise<V> =>  {\r\n  await sleep(timeoutMs);\r\n  return Promise.resolve(await callback());\r\n};\r\n\r\n/**\r\n * Async generator that loops via `requestAnimationFrame`.\r\n * \r\n * ```\r\n * // Loop forever \r\n * (async () => {\r\n *  const loop = delayAnimationLoop();\r\n *  while (true) {\r\n *    await loop.next();\r\n * \r\n *    // Do something...\r\n *    // Warning: loops forever\r\n *  }\r\n * })();\r\n * ```\r\n * \r\n * ```\r\n * const loop = delayAnimationLoop();\r\n * for await (const o of loop) {\r\n *  // Do something...\r\n *  // Warning: loops forever\r\n * }\r\n * ```\r\n */\r\n//eslint-disable-next-line func-style\r\nasync function* delayAnimationLoop() {\r\n  //eslint-disable-next-line functional/no-let,@typescript-eslint/no-explicit-any\r\n  let resolve:any;\r\n  //eslint-disable-next-line functional/no-let\r\n  let p = new Promise<undefined>(r => resolve = r);\r\n  //eslint-disable-next-line functional/no-let\r\n  let timer = 0;\r\n  const callback = () => {\r\n    resolve();\r\n    p = new Promise<undefined>(r => resolve = r);\r\n  };\r\n\r\n  try {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (true) {\r\n      timer = window.requestAnimationFrame(callback);\r\n      yield await p;\r\n    }\r\n  } finally {\r\n    resolve();\r\n    window.cancelAnimationFrame(timer);\r\n  }\r\n}\r\n\r\n/**\r\n * Async generator that loops at a given `timeoutMs`.\r\n * \r\n * @example Loop runs every second\r\n * ```\r\n * // Loop forever \r\n * (async () => {\r\n *  const loop = delayLoop(1000);\r\n *  while (true) {\r\n *    await loop.next();\r\n * \r\n *    // Do something...\r\n *    // Warning: loops forever\r\n *  }\r\n * })();\r\n * ```\r\n * \r\n * @example For Await loop every second\r\n * ```\r\n * const loop = delayLoop(1000);\r\n * for await (const o of loop) {\r\n *  // Do something...\r\n *  // Warning: loops forever\r\n * }\r\n * ```\r\n * @param timeoutMs Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\r\n */\r\n//eslint-disable-next-line func-style\r\nexport async function* delayLoop(timeoutMs:number) {\r\n  if (timeoutMs === 0) return yield* delayAnimationLoop();\r\n\r\n  //eslint-disable-next-line functional/no-let,@typescript-eslint/no-explicit-any\r\n  let resolve:any;\r\n  //eslint-disable-next-line functional/no-let\r\n  let p = new Promise<undefined>(r => resolve = r);\r\n  //eslint-disable-next-line functional/no-let\r\n  let timer = 0;\r\n  const callback = () => {\r\n    resolve();\r\n    p = new Promise<undefined>(r => resolve = r);\r\n  };\r\n\r\n  try {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (true) {\r\n      timer = window.setTimeout(callback, timeoutMs);\r\n      yield await p;\r\n    }\r\n  } finally {\r\n    resolve();\r\n    window.clearTimeout(timer);\r\n  }\r\n}\r\n\r\n"],"mappings":";;;;;AAyBO,IAAM,QAAQ,CAAI,WAAmB,UAAmC;AAC7E,UAAa,WAAW,YAAY,WAAW;AAC/C,MAAI,cAAc,GAAG;AACnB,WAAO,IAAI,QAAqB,aAAW,sBAAsB,OAAK;AACpE,cAAQ,KAAK;AAAA,IACf,CAAC,CAAC;AAAA,EACJ,OAAO;AACL,WAAO,IAAI,QAAqB,aAAW,WAAW,MAAM,QAAQ,KAAK,GAAG,SAAS,CAAC;AAAA,EACxF;AACF;;;ACFO,IAAM,WAAW,iBAAmB,SAA2B,YAAoB;AAExF,MAAI,YAAY;AAChB,MAAI;AAEF,WAAO,CAAC,WAAW;AACjB,YAAM,MAAM,UAAU;AACtB,UAAI;AAAW;AACf,UAAI,OAAO,YAAY,YAAY;AAEjC,cAAM,SAAS,MAAM,QAAQ;AAC7B,cAAM;AAAA,MACR,WAAW,OAAO,YAAY,UAAU;AAEtC,YAAI,UAAU,WAAW,YAAY,WAAW,WAAW,SAAS;AAClE,gBAAM,SAAS,MAAM,QAAQ,KAAK;AAClC,cAAI,OAAO;AAAM;AACjB,gBAAM,OAAO;AAAA,QACf,OAAO;AACL,gBAAM,IAAI,MAAM,0DAA0D;AAAA,QAC5E;AAAA,MACF,OAAO;AACL,cAAM,IAAI,MAAM,+EAA+E;AAAA,MACjG;AAAA,IACF;AAAA,EACF,UAAE;AACA,gBAAY;AAAA,EACd;AACF;;;AC5BO,IAAM,QAAQ,OAAU,UAA2B,cAAmC;AAC3F,QAAM,MAAM,SAAS;AACrB,SAAO,QAAQ,QAAQ,MAAM,SAAS,CAAC;AACzC;AA2BA,qCAAqC;AAEnC,MAAI;AAEJ,MAAI,IAAI,IAAI,QAAmB,OAAK,UAAU,CAAC;AAE/C,MAAI,QAAQ;AACZ,QAAM,WAAW,MAAM;AACrB,YAAQ;AACR,QAAI,IAAI,QAAmB,OAAK,UAAU,CAAC;AAAA,EAC7C;AAEA,MAAI;AAEF,WAAO,MAAM;AACX,cAAQ,OAAO,sBAAsB,QAAQ;AAC7C,YAAM,MAAM;AAAA,IACd;AAAA,EACF,UAAE;AACA,YAAQ;AACR,WAAO,qBAAqB,KAAK;AAAA,EACnC;AACF;AA8BA,0BAAiC,WAAkB;AACjD,MAAI,cAAc;AAAG,WAAO,OAAO,mBAAmB;AAGtD,MAAI;AAEJ,MAAI,IAAI,IAAI,QAAmB,OAAK,UAAU,CAAC;AAE/C,MAAI,QAAQ;AACZ,QAAM,WAAW,MAAM;AACrB,YAAQ;AACR,QAAI,IAAI,QAAmB,OAAK,UAAU,CAAC;AAAA,EAC7C;AAEA,MAAI;AAEF,WAAO,MAAM;AACX,cAAQ,OAAO,WAAW,UAAU,SAAS;AAC7C,YAAM,MAAM;AAAA,IACd;AAAA,EACF,UAAE;AACA,YAAQ;AACR,WAAO,aAAa,KAAK;AAAA,EAC3B;AACF;","names":[]}