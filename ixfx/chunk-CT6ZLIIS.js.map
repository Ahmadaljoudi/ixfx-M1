{"version":3,"sources":["../src/modulation/Envelope.ts","../src/Timer.ts","../src/StateMachine.ts","../src/modulation/Easing.ts"],"sourcesContent":["import {SimpleEventEmitter} from \"../Events.js\";\r\nimport {msRelativeTimer, Timer, TimerSource} from \"../Timer.js\";\r\nimport { StateMachine, fromList as descriptionFromList } from \"../StateMachine.js\";\r\nimport {Path} from \"~/geometry/Path.js\";\r\nimport * as Bezier from '../geometry/Bezier.js';\r\n\r\nexport const defaultAdsrOpts = ():AdsrOpts => ({\r\n  attackBend: -1,\r\n  decayBend: -.3,\r\n  releaseBend: -.3,\r\n  peakLevel: 1,\r\n  initialLevel: 0,\r\n  sustainLevel: 0.6,\r\n  releaseLevel: 0,\r\n  attackDuration: 600,\r\n  decayDuration: 200,\r\n  releaseDuration: 800,\r\n  shouldLoop: false\r\n});\r\n\r\nexport type AdsrOpts = AdsrBaseOpts & {\r\n  /**\r\n   * Attack bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly attackBend: number\r\n  /**\r\n   * Decay bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly decayBend: number\r\n  /**\r\n   * Release bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly releaseBend: number\r\n\r\n   readonly peakLevel:number\r\n\r\n   readonly initialLevel:number\r\n \r\n   readonly sustainLevel:number\r\n\r\n   readonly releaseLevel:number\r\n}\r\n\r\nexport type AdsrBaseOpts = {\r\n  /**\r\n   * If true, envelope indefinately returns to attack stage after release\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  readonly shouldLoop: boolean\r\n\r\n  /**\r\n   * Duration for attack stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly attackDuration: number,\r\n  /**\r\n   * Duration for decay stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly decayDuration: number,\r\n  /**\r\n   * Duration for release stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly releaseDuration: number\r\n}\r\n\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface CompleteEvent { /* no-op */}\r\n\r\ntype Events = {\r\n  readonly change: StateChangeEvent\r\n  readonly complete: CompleteEvent\r\n};\r\n\r\nclass AdsrBase extends SimpleEventEmitter<Events> {\r\n  readonly #sm:StateMachine;\r\n  readonly #timeSource:TimerSource;\r\n  #timer:Timer|undefined;\r\n\r\n  #holding:boolean;\r\n  #holdingInitial:boolean;\r\n\r\n  attackDuration:number;\r\n  decayDuration:number;\r\n  releaseDuration:number;\r\n  decayDurationTotal:number;\r\n  shouldLoop:boolean;\r\n\r\n  constructor(opts:AdsrBaseOpts) {\r\n    super();\r\n    \r\n    this.attackDuration = opts.attackDuration ?? 300;\r\n    this.decayDuration = opts.decayDuration ?? 500;\r\n    this.releaseDuration = opts.releaseDuration ?? 1000;\r\n    this.shouldLoop = opts.shouldLoop ?? false;\r\n\r\n    const descr = descriptionFromList(`attack`, `decay`, `sustain`, `release`, `complete`);\r\n    this.#sm = new StateMachine(`attack`, descr);\r\n    this.#sm.addEventListener(`change`, (ev => {\r\n      super.fireEvent(`change`, ev);\r\n    }));\r\n    this.#sm.addEventListener(`stop`, (ev => {\r\n      super.fireEvent(`complete`, ev);\r\n    }));\r\n    \r\n    this.#timeSource = msRelativeTimer;\r\n    this.#holding = this.#holdingInitial = false;\r\n\r\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\r\n  }\r\n\r\n  switchState() {\r\n    if (this.#timer === undefined) return;\r\n    // eslint-disable-next-line functional/no-let\r\n    let elapsed = this.#timer.elapsed();\r\n\r\n    // Change through states for as long as needed\r\n    // eslint-disable-next-line functional/no-let\r\n    let hasChanged = false;\r\n    // eslint-disable-next-line functional/no-loop-statement\r\n    do {\r\n      hasChanged = false;\r\n      switch (this.#sm.state) {\r\n      case `attack`:\r\n        if (elapsed > this.attackDuration) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `decay`:\r\n        if (elapsed > this.decayDurationTotal) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `sustain`:\r\n        if (!this.#holding) {\r\n          elapsed = 0;\r\n          this.#timer?.reset();\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `release`:\r\n        if (elapsed > this.releaseDuration) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `complete`:\r\n        if (this.shouldLoop) {\r\n          this.trigger(this.#holdingInitial);\r\n        }\r\n      }\r\n    } while (hasChanged); \r\n  }\r\n\r\n  computeRaw():[stage:string|undefined, amount:number] {\r\n    if (this.#timer === undefined) return [undefined, 0];\r\n  \r\n    // Change state if necessary based on elapsed time\r\n    this.switchState();\r\n    \r\n    const elapsed = this.#timer.elapsed();\r\n    // eslint-disable-next-line functional/no-let\r\n    let relative = 0;\r\n    const state = this.#sm.state;\r\n    switch (state) {\r\n    case `attack`:\r\n      relative = elapsed / this.attackDuration;\r\n      break;\r\n    case `decay`:\r\n      relative = (elapsed - this.attackDuration) / this.decayDuration;\r\n      break;\r\n    case `sustain`:\r\n      relative = 1;\r\n      break;\r\n    case `release`:\r\n      relative = elapsed / this.releaseDuration;\r\n      break;\r\n    case `complete`:\r\n      return [undefined, 0];\r\n    default:\r\n      throw new Error(`State machine in unknown state: ${state}`);\r\n    }\r\n    return [state, relative];\r\n  }\r\n\r\n  get isDone():boolean {\r\n    return this.#sm.isDone;\r\n  }\r\n\r\n  trigger(hold:boolean = false) {\r\n    this.#sm.reset();\r\n    this.#timer = this.#timeSource();\r\n    this.#holding = hold;\r\n    this.#holdingInitial = hold;\r\n  }\r\n\r\n  release() {\r\n    this.#holding = false;\r\n  }\r\n}\r\n\r\nclass Adsr extends AdsrBase {\r\n  readonly attackPath:Path;\r\n  readonly decayPath:Path;\r\n  readonly releasePath:Path;\r\n\r\n  readonly initialLevel;\r\n  readonly peakLevel;\r\n  readonly releaseLevel;\r\n  readonly sustainLevel;\r\n\r\n  readonly attackBend;\r\n  readonly decayBend;\r\n  readonly releaseBend;\r\n\r\n  constructor(opts:AdsrOpts) {\r\n    super(opts);\r\n\r\n    this.initialLevel = opts.initialLevel ?? 0;\r\n    this.peakLevel = opts.peakLevel ?? 1;\r\n    this.releaseLevel = opts.releaseLevel ?? 0;\r\n    this.sustainLevel = opts.sustainLevel ?? 0.75;\r\n\r\n    this.attackBend = opts.attackBend ?? 0;\r\n    this.releaseBend = opts.releaseBend ?? 0;\r\n    this.decayBend = opts.decayBend ?? 0;\r\n\r\n    const max = 1;\r\n    this.attackPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.initialLevel}, \r\n      {x: max, y: this.peakLevel}, \r\n      -this.attackBend\r\n    ));\r\n    this.decayPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.peakLevel}, \r\n      {x: max, y: this.sustainLevel}, \r\n      -this.decayBend\r\n    ));\r\n    this.releasePath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.sustainLevel},\r\n      {x: max, y: this.releaseLevel}, \r\n      -this.releaseBend\r\n    ));\r\n  }\r\n\r\n  compute():[stage:string|undefined, scaled:number, raw:number] {\r\n    const [stage, amt] = super.computeRaw();\r\n    if (stage === undefined) return [undefined, NaN, NaN];\r\n    // eslint-disable-next-line functional/no-let\r\n    let v;\r\n    switch (stage) {\r\n    case `attack`:\r\n      v = this.attackPath.compute(amt);\r\n      break;\r\n    case `decay`:\r\n      v = this.decayPath.compute(amt);\r\n      break;\r\n    case `sustain`:\r\n      v = {x:1, y:this.sustainLevel};\r\n      break;\r\n    case `release`:\r\n      v = this.releasePath.compute(amt);\r\n      break;\r\n    case `complete`:\r\n      v = {x:1, y: this.releaseLevel};\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown state: ${stage}`);\r\n    }\r\n\r\n    return [stage, v.y, amt];\r\n  }\r\n}\r\n\r\nexport const adsr = (opts:AdsrOpts):Adsr => new Adsr(opts);","\r\nexport type Timer = {\r\n  reset(): void\r\n  elapsed(): number\r\n}\r\n\r\nexport type TimerSource = () => Timer;\r\n/**\r\n * A timer that uses clock time\r\n *\r\n * @returns {Timer}\r\n */\r\nexport const msRelativeTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = window.performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = window.performance.now();\r\n    },\r\n    elapsed: () => (window.performance.now() - start)\r\n  };\r\n};\r\n\r\n/**\r\n * A timer that progresses with each call\r\n *\r\n * @returns {Timer}\r\n */\r\nexport const tickRelativeTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => start++\r\n  };\r\n};","\r\nimport {SimpleEventEmitter} from \"./Events.js\";\r\nimport { isStringArray } from \"./Guards.js\";\r\n/*\r\ntype MappedTypeWithNewProperties<Type> = {\r\n  [Properties in keyof Type as NewKeyType]: Type[Properties]\r\n}\r\n*/\r\n// type MachineEventMap<M extends MachineDescription> = {\r\n//   [Properties in keyof M as ]\r\n// }\r\n\r\nexport interface Options {\r\n  readonly debug?: boolean\r\n}\r\n\r\n//type StateName = string | number | Symbol;\r\n\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\nexport interface StopEvent {\r\n  readonly state: string;\r\n}\r\n\r\n// type Paths<T> = T extends MachineDescription\r\n//   ? keyof T | {[K in keyof T]: Paths<T[K]['events']>}[keyof T]\r\n//   : never\r\n\r\ntype StateMachineEventMap = {\r\n  readonly change: StateChangeEvent\r\n  readonly stop: StopEvent\r\n};\r\n\r\n//type ValidStates<M extends MachineDescription> = keyof M & string;\r\n\r\n\r\ntype StateEvent = (args: unknown, sender: StateMachine) => void;\r\ntype StateHandler = string | StateEvent | null;\r\n\r\nexport interface State {\r\n  readonly [event: string]: StateHandler;\r\n}\r\n\r\nexport interface MachineDescription {\r\n  readonly [key: string]: string | readonly string[] | null;\r\n}\r\n\r\n/**\r\n * Returns a machine description based on a list of strings. The final string is the final\r\n * state.\r\n * \r\n * ```js\r\n * const states = [`one`, `two`, `three`];\r\n * const sm = new StateMachine(states[0], fromList(states));\r\n * ```\r\n * @param {...readonly} states\r\n * @param {*} string\r\n * @param {*} []\r\n * @return {*}  {MachineDescription}\r\n */\r\nexport const fromList = (...states:readonly string[]):MachineDescription => {\r\n  const t = {};\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i=0;i<states.length; i++) {\r\n    if (i === states.length - 1) {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data \r\n      t[states[i]] = null;\r\n    } else {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data\r\n      t[states[i]] = states[i+1];\r\n    }\r\n  }\r\n  return t;\r\n};\r\n\r\n// export type StateEventCallback<M extends MachineDescription> = (event: string, state: ValidStates<M>, params: any, machine: StateMachine<M>) => boolean;\r\n\r\n/**\r\n * State machine\r\n *\r\n * Machine description is a simple object of possible state names to allowed state(s). Eg. the following\r\n * has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `Sleep` can only transition to the `wakeup`\r\n * state, while `wakeup` can transition to either `coffee` or `breakfast`. \r\n * \r\n * Use `null` to signify the final state. Multiple states can terminate the machine if desired.\r\n * ```\r\n * const description = { \r\n *  sleep: 'wakeup',\r\n *  wakeup: ['coffee', 'breakfast'],\r\n *  coffee: `bike`,\r\n *  breakfast: `bike`,\r\n *  bike: null\r\n * }\r\n * ```\r\n * Create the machine with the starting state (`sleep`)\r\n * ```\r\n * const machine = new StateMachine(`sleep`, description);\r\n * ```\r\n * \r\n * Change the state by name:\r\n * ```\r\n * machine.state = `wakeup`\r\n * ```\r\n * \r\n * Or request an automatic transition (will use first state if there are several options)\r\n * ```\r\n * machine.next();\r\n * ```\r\n * \r\n * Check status\r\n * ```\r\n * if (machine.state === `coffee`) ...;\r\n * if (machine.isDone()) ...\r\n * ```\r\n * \r\n * Listen for state changes\r\n * ```\r\n * machine.addEventListener(`change`, (evt) => {\r\n *  const {priorState, newState} = evt;\r\n *  console.log(`State change from ${priorState} -> ${newState}`);\r\n * });\r\n * ```\r\n * @export\r\n * @class StateMachine\r\n * @extends {SimpleEventEmitter<StateMachineEventMap>}\r\n */\r\nexport class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #state: string;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #debug: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #m: MachineDescription;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #isDone: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #initial: string;\r\n\r\n  /**\r\n   * Create a state machine with initial state, description and options\r\n   * @param {string} initial Initial state\r\n   * @param {MachineDescription} m Machine description\r\n   * @param {Options} [opts={debug: false}] Options for machine\r\n   * @memberof StateMachine\r\n   */\r\n  constructor(initial: string, m: MachineDescription, opts: Options = {debug: false}) {\r\n    super();\r\n    const [isValid, errorMsg] = StateMachine.validate(initial, m);\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    this.#initial = initial;\r\n    this.#m = m;\r\n    this.#debug = opts.debug ?? false;\r\n    this.#state = initial;\r\n    this.#isDone = false;\r\n  }\r\n\r\n  get states():readonly string[] {\r\n    return Object.keys(this.#m);\r\n  }\r\n\r\n  static validate(initial:string, m:MachineDescription):readonly [boolean, string]  {\r\n    // Check that object is structured properly\r\n    const keys = Object.keys(m);\r\n    // eslint-disable-next-line functional/prefer-readonly-type\r\n    const finalStates:string[] = [];\r\n    const seenKeys = new Set();\r\n    const seenVals = new Set();\r\n\r\n    // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n    for (let i=0;i<keys.length;i++) {\r\n      const key = keys[i];\r\n      if (seenKeys.has(key)) return [false, `Key ${key} is already used`];\r\n      seenKeys.add(key);\r\n\r\n      if (typeof keys[i] !== `string`) return [false, `Key[${i}] is not a string`];\r\n      const val = m[key];\r\n      if (val === undefined) return [false, `Key ${key} value is undefined`];\r\n      if (typeof val === `string`) {\r\n        seenVals.add(val);\r\n        if (val === key) return [false, `Loop present for ${key}`];\r\n      } else if (Array.isArray(val)) {\r\n        if (!isStringArray(val)) return [false, `Key ${key} value is not an array of strings`];\r\n        val.forEach(v => seenVals.add(v));\r\n        if (val.find(v => v === key)) return [false, `Loop present for ${key}`];\r\n      } else if (val === null) {\r\n        // eslint-disable-next-line functional/immutable-data\r\n        finalStates.push(key);\r\n      } else {\r\n        return [false, `Key ${key} has a value that is neither null, string or array`];\r\n      }\r\n    }\r\n\r\n    // Check that all values have a top-level state\r\n    const seenValsArray = Array.from(seenVals);\r\n    const missing = seenValsArray.find(v => !seenKeys.has(v));\r\n    if (missing) return [false, `Potential state '${missing}' does not exist as a top-level state`];\r\n\r\n    // Check machine contains intial state\r\n    if (m[initial] === undefined) return [false, `Initial state ${initial} not present`];\r\n    return [true, ``];\r\n  }\r\n\r\n  /**\r\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\r\n   * If machine is finalised, no error is thrown and null is returned.\r\n   * \r\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\r\n   * @memberof StateMachine\r\n   */\r\n  next(): string | null {\r\n    // Get possible transitions for current state\r\n    const r = this.#m[this.#state];\r\n    if (r === null) return null; // At the end\r\n\r\n    // If there are multiple options, use the first\r\n    if (Array.isArray(r)) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      if (typeof r[0] === `string`) this.state = r[0];\r\n      else throw new Error(`Error in machine description. Potential state array does not contain strings`);\r\n    } else if (typeof r === `string`) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.state = r; // Just one option\r\n    } else throw new Error(`Error in machine description. Potential state is neither array nor string`);\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Returns true if state machine is in its final state\r\n   *\r\n   * @returns\r\n   * @memberof StateMachine\r\n   */\r\n  get isDone():boolean {\r\n    return this.#isDone;\r\n  }\r\n\r\n  /**\r\n   * Resets machine to initial state\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  reset() {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#isDone = false;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = this.#initial;\r\n  }\r\n\r\n  /**\r\n   * Checks whether a state change is valid.\r\n   *\r\n   * @static\r\n   * @param {string} priorState From state\r\n   * @param {string} newState To state\r\n   * @param {MachineDescription} description Machine description\r\n   * @returns {[boolean, string]} If valid: [true,''], if invalid: [false, 'Error msg here']\r\n   * @memberof StateMachine\r\n   */\r\n  static isValid(priorState:string, newState:string, description:MachineDescription):readonly [boolean, string] {\r\n    // Does state exist?\r\n    if (description[newState] === undefined) return [false, `Machine cannot change to non-existent state ${newState}`];\r\n\r\n    // Is transition allowed?\r\n    const rules = description[priorState];\r\n    if (Array.isArray(rules)) {\r\n      if (!rules.includes(newState)) return [false, `Machine cannot ${priorState} -> ${newState}. Allowed transitions: ${rules.join(`, `)}`];\r\n    } else {\r\n      if (newState !== rules && rules !== `*`) return [false, `Machine cannot ${priorState} -> ${newState}. Allowed transition: ${rules}`];\r\n    }\r\n    return [true, `ok`];\r\n  }\r\n\r\n  isValid(newState:string):readonly [boolean, string] {\r\n    return StateMachine.isValid(this.state, newState, this.#m);\r\n  }\r\n\r\n  /**\r\n   * Sets state. Throws an error if an invalid transition is attempted.\r\n   * Use `StateMachine.isValid` to check validity without changing.\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  set state(newState: string) {\r\n    const priorState = this.#state;\r\n\r\n    const [isValid, errorMsg] = StateMachine.isValid(priorState, newState, this.#m);\r\n\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);\r\n\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = newState;\r\n\r\n    //const priorRules = this.#m[priorState];\r\n    const rules = this.#m[newState];\r\n    if (rules === null) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#isDone = true;\r\n    }\r\n    setTimeout(() => {\r\n      this.fireEvent(`change`, {newState: newState, priorState: priorState});\r\n      if (this.isDone) this.fireEvent(`stop`, {state: newState });\r\n    }, 1);\r\n  }\r\n\r\n  /**\r\n * Return current state\r\n *\r\n * @type {string}\r\n * @memberof StateMachine\r\n */\r\n  get state(): string {\r\n    return this.#state;\r\n  }\r\n  /*\r\n  fire(eventName: string, params?: any): boolean {\r\n    let handler = this.#state[eventName];\r\n    if (handler === undefined) {\r\n      if (this.#debug) console.log(`StateMachine: state '${this.#stateName}' has no handler for event '${eventName}'.`);\r\n      return false; // Event is not handled in this state\r\n    }\r\n    if (typeof (handler) === 'string') {\r\n      // Strings are assumed to be the next state\r\n      return this.#setState(handler)\r\n    } else if (handler == null) {\r\n      this.#isDone = true;\r\n      this.fireEvent('stop', {state: this.#stateName});\r\n      return false;\r\n    } else {\r\n      // Call function\r\n      let state = handler(params, this);\r\n      if (state !== undefined && typeof state === 'string') {\r\n        // If handler returns string, assume it's a new state\r\n        this.#setState(state);\r\n      }\r\n      return true;\r\n    }\r\n  }*/\r\n\r\n}\r\n\r\n\r\n/*\r\ninterface ListMachineDefinition {\r\n  [key: string]: State;\r\n}\r\n\r\nclass ListStateMachine extends StateMachine {\r\n  constructor(initial: string, listMachineDef: ListMachineDefinition, opts?: Options) {\r\n    super(initial, listMachineDef, opts)\r\n  }\r\n\r\n  next(params?: any): boolean {\r\n    return this.fire('next', params);\r\n  }\r\n}\r\n\r\nconst createListMachine = (list: string[], opts?: Options): ListStateMachine => {\r\n  let map = {};\r\n  for (let i = 0; i < list.length; i++) {\r\n    let next = i < list.length - 1 ? list[i + 1] : null;\r\n    let state = {next}\r\n    // @ts-ignore\r\n    map[list[i]] = state;\r\n  }\r\n\r\n  return new ListStateMachine(list[0], map, opts);\r\n}*/\r\n","// Easings from https://easings.net/\r\nimport {clamp} from '../util.js';\r\n\r\nconst sqrt = Math.sqrt;\r\nconst pow = Math.pow;\r\nconst cos = Math.cos;\r\nconst PI = Math.PI;\r\nconst sin = Math.sin;\r\n\r\ntype RelativeTimer = {\r\n  reset(): void\r\n  elapsed(): number\r\n  isDone(): boolean\r\n}\r\n\r\ntype TimerSource = (upperBound: number) => RelativeTimer;\r\n\r\nconst msRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    elapsed: () => clamp((performance.now() - start) / upperBound),\r\n    isDone: () => (performance.now() - start) >= upperBound,\r\n  };\r\n};\r\n\r\nconst tickRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => clamp(start++ / upperBound),\r\n    isDone: () => start >= upperBound,\r\n  };\r\n};\r\n\r\ntype EasingFn = (x: number) => number;\r\n/**\r\n * Creates an easing based on clock time\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} durationMs Duration in milliseconds\r\n * @returns Easing\r\n */\r\nexport const timer = function (easingName: string, durationMs: number):Easing {\r\n  return create(easingName, durationMs, msRelativeTimer);\r\n};\r\n/**\r\n * Creates an easing based on ticks\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} durationTicks Duration in ticks\r\n * @returns {Easing}\r\n */\r\nexport const tick = function (easingName: string, durationTicks: number):Easing {\r\n  return create(easingName, durationTicks, tickRelativeTimer);\r\n};\r\n\r\nexport type Easing = {\r\n  /**\r\n   * Computes the current value of the easing\r\n   *\r\n   * @returns {number}\r\n   */\r\n  compute(): number\r\n\r\n  /**\r\n   * Reset the easing\r\n   *\r\n   */\r\n  reset(): void\r\n  /**\r\n   * Returns true if the easing is complete\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  isDone(): boolean\r\n};\r\n\r\n/**\r\n * Creates a new easing by name\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} duration Duration (meaning depends on timer source)\r\n * @param {TimerSource} timerSource Timer source: use timer() or tick()\r\n * @returns {Easing}\r\n */\r\nconst create = function (easingName: string, duration: number, timerSource: TimerSource): Easing {\r\n  const fn = resolveEasing(easingName);\r\n  const timer = timerSource(duration);\r\n\r\n  return {\r\n    isDone: () => timer.isDone(),\r\n    compute: () => {\r\n      const relative = timer.elapsed();\r\n      return fn(relative);\r\n    },\r\n    reset: () => {\r\n      timer.reset();\r\n    }\r\n  };\r\n};\r\n\r\nconst resolveEasing = function (easingName: string): EasingFn {\r\n  const name = easingName.toLowerCase();\r\n  for (const [k, v] of Object.entries(easings)) {\r\n    if (k.toLowerCase() === name) {\r\n      return v as EasingFn;\r\n    }\r\n  }\r\n  throw Error(`Easing '${easingName}' not found.`);\r\n};\r\n/**\r\n * Return list of available easings\r\n *\r\n * @returns {string[]}\r\n */\r\nexport const getEasings = function ():string[] {\r\n  return Array.from(Object.keys(easings));\r\n};\r\n\r\nconst easeOutBounce = function (x:number): number {\r\n  const n1 = 7.5625;\r\n  const d1 = 2.75;\r\n\r\n  if (x < 1 / d1) {\r\n    return n1 * x * x;\r\n  } else if (x < 2 / d1) {\r\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\r\n  } else if (x < 2.5 / d1) {\r\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\r\n  } else {\r\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\r\n  }\r\n};\r\n\r\nconst easings = {\r\n  easeInSine: (x: number): number => 1 - cos((x * PI) / 2),\r\n  easeOutSine: (x: number): number => sin((x * PI) / 2),\r\n  easeInQuad: (x: number): number => x * x,\r\n  easeOutQuad: (x: number): number => 1 - (1 - x) * (1 - x),\r\n  easeInOutSine: (x: number): number => -(cos(PI * x) - 1) / 2,\r\n  easeInOutQuad: (x: number): number => (x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2),\r\n  easeInCubic: (x: number): number => x * x * x,\r\n  easeOutCubic: (x: number): number => 1 - pow(1 - x, 3),\r\n  easeInQuart: (x: number): number => x * x * x * x,\r\n  easeOutQuart: (x: number): number => 1 - pow(1 - x, 4),\r\n  easeInQuint: (x: number): number => x * x * x * x * x,\r\n  easeOutQuint: (x: number): number => 1 - pow(1 - x, 5),\r\n  easeInExpo: (x: number): number => (x === 0 ? 0 : pow(2, 10 * x - 10)),\r\n  easeOutExpo: (x: number): number => (x === 1 ? 1 : 1 - pow(2, -10 * x)),\r\n  easeInOutQuint: (x: number): number => (x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2),\r\n  easeInOutExpo: (x: number): number => (x === 0\r\n    ? 0\r\n    : x === 1\r\n      ? 1\r\n      : x < 0.5 ? pow(2, 20 * x - 10) / 2\r\n        : (2 - pow(2, -20 * x + 10)) / 2),\r\n  easeInCirc: (x: number): number => 1 - sqrt(1 - pow(x, 2)),\r\n  easeOutCirc: (x: number): number => sqrt(1 - pow(x - 1, 2)),\r\n  easeInBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return c3 * x * x * x - c1 * x * x;\r\n  },\r\n  easeOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\r\n  },\r\n  easeInOutCirc: (x: number): number => (x < 0.5\r\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\r\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2),\r\n  easeInOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c2 = c1 * 1.525;\r\n\r\n    return x < 0.5\r\n      ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\r\n      : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\r\n  },\r\n  easeInElastic: (x: number): number => {\r\n    const c4 = (2 * PI) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);\r\n  },\r\n  easeOutElastic: (x: number): number => {\r\n    const c4 = (2 * PI) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;\r\n  },\r\n  easeInBounce: (x: number): number => 1 - easeOutBounce(1 - x),\r\n  easeOutBounce: easeOutBounce,\r\n  easeInOutElastic: (x: number): number => {\r\n    const c5 = (2 * PI) / 4.5;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : x < 0.5\r\n          ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\r\n          : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\r\n  },\r\n  easeInOutBounce: (x: number): number => (x < 0.5\r\n    ? (1 - easeOutBounce(1 - 2 * x)) / 2\r\n    : (1 + easeOutBounce(2 * x - 1)) / 2)\r\n};"],"mappings":"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","names":[]}