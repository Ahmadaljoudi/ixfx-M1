{"version":3,"sources":["../src/flow/StateMachine.ts"],"sourcesContent":["// âœ” UNIT TESTED\r\n\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\nimport { isStringArray } from \"../Guards.js\";\r\n\r\nexport interface Options {\r\n  readonly debug?: boolean\r\n}\r\n\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\nexport interface StopEvent {\r\n  readonly state: string;\r\n}\r\n\r\nexport type StateMachineEventMap = {\r\n  readonly change: StateChangeEvent\r\n  readonly stop: StopEvent\r\n};\r\n\r\nexport type StateEvent = (args: unknown, sender: StateMachine) => void;\r\nexport type StateHandler = string | StateEvent | null;\r\n\r\nexport interface State {\r\n  readonly [event: string]: StateHandler;\r\n}\r\n\r\nexport interface MachineDescription {\r\n  readonly [key: string]: string | readonly string[] | null;\r\n}\r\n\r\n/**\r\n * Returns a machine description based on a list of strings. The final string is the final\r\n * state.\r\n * \r\n * ```js\r\n * const states = [`one`, `two`, `three`];\r\n * const sm = StateMachine.create(states[0], descriptionFromList(states));\r\n * ```\r\n * @param states List of states\r\n * @return MachineDescription\r\n */\r\nexport const descriptionFromList = (...states:readonly string[]):MachineDescription => {\r\n  const t = {};\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i=0;i<states.length; i++) {\r\n    if (i === states.length - 1) {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data \r\n      t[states[i]] = null;\r\n    } else {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data\r\n      t[states[i]] = states[i+1];\r\n    }\r\n  }\r\n  return t;\r\n};\r\n\r\n/**\r\n * Returns a state machine based on a list of strings. The first string is used as the initial state,\r\n * the last string is considered the final. To just generate a description, use {@link descriptionFromList}.\r\n * \r\n * ```js\r\n * const states = [`one`, `two`, `three`];\r\n * const sm = StateMachine.fromList(states);\r\n * ```\r\n */\r\nexport const fromList = (...states:readonly string[]):StateMachine => new StateMachine(states[0], descriptionFromList(...states));\r\n\r\n/**\r\n * Creates a new state machine\r\n * @param initial Initial state\r\n * @param m Machine description\r\n * @param opts Options\r\n * @returns State machine instance\r\n */\r\nexport const create = (initial: string, m: MachineDescription, opts: Options = {debug: false}):StateMachine =>  new StateMachine(initial, m, opts);\r\n\r\n/**\r\n * State machine\r\n *\r\n * Machine description is a simple object of possible state names to allowed state(s). Eg. the following\r\n * has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `Sleep` can only transition to the `wakeup`\r\n * state, while `wakeup` can transition to either `coffee` or `breakfast`. \r\n * \r\n * Use `null` to signify the final state. Multiple states can terminate the machine if desired.\r\n * ```\r\n * const description = { \r\n *  sleep: 'wakeup',\r\n *  wakeup: ['coffee', 'breakfast'],\r\n *  coffee: `bike`,\r\n *  breakfast: `bike`,\r\n *  bike: null\r\n * }\r\n * ```\r\n * Create the machine with the starting state (`sleep`)\r\n * ```\r\n * const machine = StateMachine.create(`sleep`, description);\r\n * ```\r\n * \r\n * Change the state by name:\r\n * ```\r\n * machine.state = `wakeup`\r\n * ```\r\n * \r\n * Or request an automatic transition (will use first state if there are several options)\r\n * ```\r\n * machine.next();\r\n * ```\r\n * \r\n * Check status\r\n * ```\r\n * if (machine.state === `coffee`) ...;\r\n * if (machine.isDone()) ...\r\n * ```\r\n * \r\n * Listen for state changes\r\n * ```\r\n * machine.addEventListener(`change`, (evt) => {\r\n *  const {priorState, newState} = evt;\r\n *  console.log(`State change from ${priorState} -> ${newState}`);\r\n * });\r\n * ```\r\n * @export\r\n * @class StateMachine\r\n * @extends {SimpleEventEmitter<StateMachineEventMap>}\r\n */\r\nexport class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #state: string;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #debug: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #m: MachineDescription;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #isDone: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #initial: string;\r\n\r\n  /**\r\n   * Create a state machine with initial state, description and options\r\n   * @param string initial Initial state\r\n   * @param MachineDescription m Machine description\r\n   * @param Options Options for machine (defaults to `{debug:false}`)\r\n   * @memberof StateMachine\r\n   */\r\n  constructor(initial: string, m: MachineDescription, opts: Options = {debug: false}) {\r\n    super();\r\n    const [isValid, errorMsg] = StateMachine.validate(initial, m);\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    this.#initial = initial;\r\n    this.#m = m;\r\n    this.#debug = opts.debug ?? false;\r\n    this.#state = initial;\r\n    this.#isDone = false;\r\n  }\r\n\r\n  get states():readonly string[] {\r\n    return Object.keys(this.#m);\r\n  }\r\n\r\n  static validate(initial:string, m:MachineDescription):readonly [boolean, string]  {\r\n    // Check that object is structured properly\r\n    const keys = Object.keys(m);\r\n    // eslint-disable-next-line functional/prefer-readonly-type\r\n    const finalStates:string[] = [];\r\n    const seenKeys = new Set();\r\n    const seenVals = new Set();\r\n\r\n    // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n    for (let i=0;i<keys.length;i++) {\r\n      const key = keys[i];\r\n      if (seenKeys.has(key)) return [false, `Key ${key} is already used`];\r\n      seenKeys.add(key);\r\n\r\n      if (typeof keys[i] !== `string`) return [false, `Key[${i}] is not a string`];\r\n      const val = m[key];\r\n      if (val === undefined) return [false, `Key ${key} value is undefined`];\r\n      if (typeof val === `string`) {\r\n        seenVals.add(val);\r\n        if (val === key) return [false, `Loop present for ${key}`];\r\n      } else if (Array.isArray(val)) {\r\n        if (!isStringArray(val)) return [false, `Key ${key} value is not an array of strings`];\r\n        val.forEach(v => seenVals.add(v));\r\n        if (val.find(v => v === key)) return [false, `Loop present for ${key}`];\r\n      } else if (val === null) {\r\n        // eslint-disable-next-line functional/immutable-data\r\n        finalStates.push(key);\r\n      } else {\r\n        return [false, `Key ${key} has a value that is neither null, string or array`];\r\n      }\r\n    }\r\n\r\n    // Check that all values have a top-level state\r\n    const seenValsArray = Array.from(seenVals);\r\n    const missing = seenValsArray.find(v => !seenKeys.has(v));\r\n    if (missing) return [false, `Potential state '${missing}' does not exist as a top-level state`];\r\n\r\n    // Check machine contains intial state\r\n    if (m[initial] === undefined) return [false, `Initial state ${initial} not present`];\r\n    return [true, ``];\r\n  }\r\n\r\n  /**\r\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\r\n   * If machine is finalised, no error is thrown and null is returned.\r\n   * \r\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\r\n   * @memberof StateMachine\r\n   */\r\n  next(): string | null {\r\n    // Get possible transitions for current state\r\n    const r = this.#m[this.#state];\r\n    if (r === null) return null; // At the end\r\n\r\n    // If there are multiple options, use the first\r\n    if (Array.isArray(r)) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      if (typeof r[0] === `string`) this.state = r[0];\r\n      else throw new Error(`Error in machine description. Potential state array does not contain strings`);\r\n    } else if (typeof r === `string`) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.state = r; // Just one option\r\n    } else throw new Error(`Error in machine description. Potential state is neither array nor string`);\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Returns true if state machine is in its final state\r\n   *\r\n   * @returns\r\n   * @memberof StateMachine\r\n   */\r\n  get isDone():boolean {\r\n    return this.#isDone;\r\n  }\r\n\r\n  /**\r\n   * Resets machine to initial state\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  reset() {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#isDone = false;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = this.#initial;\r\n  }\r\n\r\n  /**\r\n   * Checks whether a state change is valid.\r\n   *\r\n   * @static\r\n   * @param priorState From state\r\n   * @param newState To state\r\n   * @param description Machine description\r\n   * @returns If valid: [true,''], if invalid: [false, 'Error msg here']\r\n   * @memberof StateMachine\r\n   */\r\n  static isValid(priorState:string, newState:string, description:MachineDescription):readonly [boolean, string] {\r\n    // Does state exist?\r\n    if (description[newState] === undefined) return [false, `Machine cannot change to non-existent state ${newState}`];\r\n\r\n    // Is transition allowed?\r\n    const rules = description[priorState];\r\n    if (Array.isArray(rules)) {\r\n      if (!rules.includes(newState)) return [false, `Machine cannot change '${priorState} -> ${newState}'. Allowed transitions: ${rules.join(`, `)}`];\r\n    } else {\r\n      if (newState !== rules && rules !== `*`) return [false, `Machine cannot '${priorState} -> ${newState}'. Allowed transition: ${rules}`];\r\n    }\r\n    return [true, `ok`];\r\n  }\r\n\r\n  isValid(newState:string):readonly [boolean, string] {\r\n    return StateMachine.isValid(this.state, newState, this.#m);\r\n  }\r\n\r\n  /**\r\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\r\n   * Use `StateMachine.isValid` to check validity without changing.\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  set state(newState: string) {\r\n    const priorState = this.#state;\r\n\r\n    const [isValid, errorMsg] = StateMachine.isValid(priorState, newState, this.#m);\r\n\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);\r\n\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = newState;\r\n\r\n    const rules = this.#m[newState];\r\n    if (rules === null) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#isDone = true;\r\n    }\r\n    setTimeout(() => {\r\n      this.fireEvent(`change`, {newState: newState, priorState: priorState});\r\n      if (this.isDone) this.fireEvent(`stop`, {state: newState });\r\n    }, 1);\r\n  }\r\n\r\n  get state(): string {\r\n    return this.#state;\r\n  }\r\n}"],"mappings":"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","names":[]}