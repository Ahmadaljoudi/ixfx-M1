{"version":3,"sources":["../src/collections/index.ts","../src/collections/Queue.ts"],"sourcesContent":["\r\n//export {randomElement} from './Arrays.js';\r\n//export {MutableStringSet, mutableStringSet};\r\n\r\n// import {stack, stackMutable,  OverflowPolicy as StackOverflowPolicy} from './Stack.js';\r\n// import {queue, queueMutable, OverflowPolicy as QueueOverflowPolicy} from './Queue.js';\r\n// export {stack, stackMutable, StackOverflowPolicy};\r\n// export {queue, queueMutable, QueueOverflowPolicy};\r\nexport {mutableMapSet, mutableMapCircular, mutableMapArray} from './MutableMapMulti.js';\r\nexport {mutableCircularArray} from './MutableCircularArray.js';\r\nexport {simpleMutableMapArray} from './SimpleMutableMapArray.js';\r\nexport {MutableStringSet, mutableStringSet} from './Set.js';\r\nexport {stack, stackMutable} from './Stack.js';\r\nexport {queue, queueMutable} from './Queue.js';\r\nexport * from './Arrays.js';\r\nexport * from './NumericArrays.js';\r\nexport * from './Map.js';\r\n\r\nexport * as Sets from './Set.js';\r\nexport * as Queues from './Queue.js';\r\nexport * as Maps from './Map.js';\r\n","// âœ” UNIT TESTED\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\n\r\nexport interface QueueOpts  {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  /**\r\n   * Default is DiscardAdditions, meaning new items are discarded\r\n   *\r\n   * @type {OverflowPolicy}\r\n   */\r\n  readonly overflowPolicy?: OverflowPolicy\r\n}\r\n\r\nconst debug = (opts: QueueOpts, msg:string):void => {\r\n  /* eslint-disable-next-line functional/no-expression-statement */\r\n  opts.debug ? console.log(`queue:${msg}`) : null;\r\n};\r\n\r\nconst trimQueue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = queue.length + toAdd.length;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n  debug(opts, `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n \r\n  switch (policy) {\r\n  // Only add what we can from toAdd\r\n  case OverflowPolicy.DiscardAdditions:\r\n    debug(opts, `enqueue:DiscardAdditions: queueLen: ${queue.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (queue.length === opts.capacity) {\r\n      return queue; // Completely full\r\n    } else {\r\n      // Only add some from the new array (from the front)  \r\n      return [...queue, ...toAdd.slice(0, toRemove-1)];\r\n    }\r\n  // Remove from rear of queue (last index) before adding new things\r\n  case OverflowPolicy.DiscardNewer:\r\n    if (toRemove >= queue.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old\r\n      debug(opts, ` from orig: ${queue.slice(0, toRemove-1)}`);\r\n      return [...queue.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  // Remove from the front of the queue (0 index). ie. older items are discarded\r\n  case OverflowPolicy.DiscardOlder:\r\n    // If queue is A, B and toAdd is C, D this yields A, B, C, D\r\n    return [...queue, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Adds to the back of the queue (last array index)\r\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @param {...V[]} toAdd\r\n * @returns {V[]}\r\n */\r\nconst enqueue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n\r\n  const potentialLength = queue.length + toAdd.length;\r\n  const overSize = opts.capacity && potentialLength > opts.capacity;\r\n\r\n  const toReturn = overSize ? trimQueue(opts, queue, toAdd) : [...queue, ...toAdd];\r\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\r\n  if (!opts.capacity && toReturn.length !== potentialLength) throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\r\n  \r\n  return toReturn;\r\n};\r\n\r\n// Remove from front of queue (0 index)\r\nconst dequeue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (queue.length === 0) throw new Error(`Queue is empty`);\r\n  return queue.slice(1);\r\n};\r\n\r\n/**\r\n * Returns front of queue (oldest item), or undefined if queue is empty\r\n *\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): V | undefined => queue[0];\r\n\r\nconst isEmpty = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean => queue.length === 0;\r\n\r\nconst isFull = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return queue.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------------\r\n// Immutable\r\n// -------------------------------\r\nclass Queue<V> {\r\n  readonly opts: QueueOpts;\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  /**\r\n   * Creates an instance of Queue.\r\n   * @param {QueueOpts} opts Options foor queue\r\n   * @param {V[]} data Initial data. Index 0 is front of queue\r\n   * @memberof Queue\r\n   */\r\n  constructor(opts: QueueOpts, data: ReadonlyArray<V>) {\r\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: ReadonlyArray<V>): Queue<V> {\r\n    return new Queue<V>(this.opts, enqueue(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  dequeue(): Queue<V> {\r\n    return new Queue<V>(this.opts, dequeue(this.opts, this.data));\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  /**\r\n   * Returns front of queue (oldest item), or undefined if queue is empty\r\n   *\r\n   * @readonly\r\n   * @type {(V | undefined)}\r\n   * @memberof Queue\r\n   */\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an immutable queue\r\n *\r\n * ```js\r\n * let q = queue();           // Create\r\n * q = q.enqueue(`a`, `b`);   // Add two strings\r\n * const front = q.peek();    // `a` is at the front of queue (oldest)\r\n * q = q.dequeue();           // q now just consists of `b`  \r\n * ```\r\n * @template V\r\n * @param {QueueOpts} [opts={}] Options\r\n * @param {...V[]} startingItems Index 0 is the front of the queue\r\n * @returns {Queue<V>} A new queue\r\n */\r\nexport const queue = <V>(opts: QueueOpts = {}, ...startingItems: ReadonlyArray<V>): Queue<V> => {\r\n  opts = {...opts}; // Make a copy of options\r\n  return new Queue(opts, [...startingItems]); // Make a copy of array so it can't be modified\r\n};\r\n\r\nexport type MutableQueue<V> = {\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get isEmpty ():boolean\r\n  readonly dequeue: () => V|undefined\r\n  readonly enqueue: (...toAdd:ReadonlyArray<V>) => number\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get peek():V|undefined\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get length():number\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get isFull():boolean\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get data():readonly V[]\r\n}\r\n\r\n// -------------------------------\r\n// Mutable\r\n// -------------------------------\r\nclass MutableQueueImpl<V> implements MutableQueue<V> {\r\n  readonly opts: QueueOpts;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts:QueueOpts, data:ReadonlyArray<V>) {\r\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = enqueue(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  dequeue(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = dequeue(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  /**\r\n   * Returns front of queue (oldest item), or undefined if queue is empty\r\n   *\r\n   * @readonly\r\n   * @type {(V | undefined)}\r\n   * @memberof Queue\r\n   */\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a mutable queue\r\n * \r\n * ```js\r\n * const q = queue();       // Create\r\n * q.enqueue(`a`, `b`);     // Add two strings\r\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\r\n * ```\r\n *\r\n * @template V\r\n * @param {QueueOpts} [opts={}]\r\n * @param {...ReadonlyArray<V>} startingItems\r\n */\r\nexport const queueMutable = <V>(opts: QueueOpts = {}, ...startingItems: ReadonlyArray<V>):MutableQueue<V> => new MutableQueueImpl({...opts}, [...startingItems]);"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEO,IAAK,iBAAL,kBAAK,oBAAL;AAIL;AAIA;AAIA;AAZU;AAAA;AA2BZ,IAAM,QAAQ,CAAC,MAAiB,QAAoB;AAElD,OAAK,QAAQ,QAAQ,IAAI,SAAS,SAAS;AAAA;AAG7C,IAAM,YAAY,CAAI,MAAiB,QAAyB,UAA8C;AAC5G,QAAM,kBAAkB,OAAM,SAAS,MAAM;AAC7C,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,WAAW,kBAAkB;AACnC,QAAM,SAAS,KAAK,kBAAkB;AACtC,QAAM,MAAM,aAAa,OAAM,wBAAwB,6BAA6B,oBAAoB,eAAe;AAEvH,UAAQ;AAAA,SAEH;AACH,YAAM,MAAM,uCAAuC,OAAM,iBAAiB,kBAAgB,sBAAsB,MAAM;AACtH,UAAI,OAAM,WAAW,KAAK,UAAU;AAClC,eAAO;AAAA,aACF;AAEL,eAAO,CAAC,GAAG,QAAO,GAAG,MAAM,MAAM,GAAG,WAAS;AAAA;AAAA,SAG5C;AACH,UAAI,YAAY,OAAM,QAAQ;AAE5B,eAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAO,WAAW,KAAK,IAAI,MAAM,QAAQ,YAAU;AAAA,aACnF;AAEL,cAAM,MAAM,eAAe,OAAM,MAAM,GAAG,WAAS;AACnD,eAAO,CAAC,GAAG,OAAM,MAAM,GAAG,WAAS,IAAI,GAAG,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAS,WAAS;AAAA;AAAA,SAGjG;AAEH,aAAO,CAAC,GAAG,QAAO,GAAG,OAAO,MAAM;AAAA;AAElC,YAAM,IAAI,MAAM,2BAA2B;AAAA;AAAA;AAa/C,IAAM,UAAU,CAAI,MAAiB,WAA4B,UAA8C;AAC7G,MAAI,SAAS;AAAW,UAAM,IAAI,MAAM;AAExC,QAAM,kBAAkB,OAAM,SAAS,MAAM;AAC7C,QAAM,WAAW,KAAK,YAAY,kBAAkB,KAAK;AAEzD,QAAM,WAAW,WAAW,UAAU,MAAM,QAAO,SAAS,CAAC,GAAG,QAAO,GAAG;AAC1E,MAAI,KAAK,YAAY,SAAS,WAAW,KAAK,YAAY;AAAU,UAAM,IAAI,MAAM,uDAAuD,SAAS,oBAAoB,KAAK,kBAAkB,KAAK,UAAU;AAC9M,MAAI,CAAC,KAAK,YAAY,SAAS,WAAW;AAAiB,UAAM,IAAI,MAAM,gDAAgD,SAAS,oBAAoB,yBAAyB,KAAK,UAAU;AAEhM,SAAO;AAAA;AAIT,IAAM,UAAU,CAAI,MAAiB,WAA8C;AACjF,MAAI,OAAM,WAAW;AAAG,UAAM,IAAI,MAAM;AACxC,SAAO,OAAM,MAAM;AAAA;AAWrB,IAAM,OAAO,CAAI,MAAiB,WAA2C,OAAM;AAEnF,IAAM,UAAU,CAAI,MAAiB,WAAqC,OAAM,WAAW;AAE3F,IAAM,SAAS,CAAI,MAAiB,WAAqC;AACvE,MAAI,KAAK,UAAU;AACjB,WAAO,OAAM,UAAU,KAAK;AAAA;AAE9B,SAAO;AAAA;AAMT,kBAAe;AAAA,EAUb,YAAY,MAAiB,MAAwB;AAT5C;AACA;AASP,QAAI,SAAS;AAAW,YAAM,IAAI,MAAM;AAExC,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA;AAAA,EAGd,WAAW,OAAmC;AAC5C,WAAO,IAAI,MAAS,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAK,MAAM,GAAG;AAAA;AAAA,EAGlE,UAAoB;AAClB,WAAO,IAAI,MAAS,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAGrD,UAAmB;AACrB,WAAO,QAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAG7B,SAAkB;AACpB,WAAO,OAAO,KAAK,MAAM,KAAK;AAAA;AAAA,MAG5B,SAAgB;AAClB,WAAO,KAAK,KAAK;AAAA;AAAA,MAUf,OAAsB;AACxB,WAAO,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA;AAkBzB,IAAM,QAAQ,CAAI,OAAkB,OAAO,kBAA8C;AAC9F,SAAO,KAAI;AACX,SAAO,IAAI,MAAM,MAAM,CAAC,GAAG;AAAA;AAqB7B,6BAAqD;AAAA,EAKnD,YAAY,MAAgB,MAAuB;AAJ1C;AAET;AAGE,QAAI,SAAS;AAAW,YAAM,IAAI,MAAM;AACxC,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA;AAAA,EAGd,WAAW,OAAiC;AAE1C,SAAK,OAAO,QAAQ,KAAK,MAAM,KAAK,MAAM,GAAG;AAC7C,WAAO,KAAK,KAAK;AAAA;AAAA,EAGnB,UAAuB;AACrB,UAAM,IAAI,KAAK,KAAK,MAAM,KAAK;AAE/B,SAAK,OAAO,QAAQ,KAAK,MAAM,KAAK;AACpC,WAAO;AAAA;AAAA,MAGL,UAAmB;AACrB,WAAO,QAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAG7B,SAAkB;AACpB,WAAO,OAAO,KAAK,MAAM,KAAK;AAAA;AAAA,MAG5B,SAAgB;AAClB,WAAO,KAAK,KAAK;AAAA;AAAA,MAUf,OAAsB;AACxB,WAAO,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA;AAiBzB,IAAM,eAAe,CAAI,OAAkB,OAAO,kBAAoD,IAAI,iBAAiB,KAAI,QAAO,CAAC,GAAG;","names":[]}