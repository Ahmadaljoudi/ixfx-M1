{"version":3,"sources":["../src/flow/index.ts","../src/flow/Timer.ts","../src/data/Clamp.ts","../src/flow/Timeout.ts","../src/flow/UpdateOutdated.ts","../src/flow/Continuously.ts","../src/flow/Debounce.ts","../src/flow/Throttle.ts","../src/flow/WaitFor.ts","../src/flow/Every.ts"],"sourcesContent":["import { number as guardNumber } from \"../Guards.js\";\nimport { sleep } from \"./Sleep.js\";\n\nimport * as StateMachine from './StateMachine.js';\nimport * as Timer from './Timer.js';\n\n/**\n * State Machine\n * See [here for usage](../classes/Flow.StateMachine.StateMachine.html).\n */\nexport { StateMachine };\nexport * from './Timer.js';\n\nexport * from './Interval.js';\nexport * from './Timeout.js';\nexport * from './UpdateOutdated.js';\nexport * from './Continuously.js';\nexport * from './Debounce.js';\nexport * from './Throttle.js';\nexport * from './Sleep.js';\nexport * from './WaitFor.js';\nexport * from './Delay.js';\nexport * from './Every.js';\n\nexport type HasCompletion = {\n  get isDone():boolean;\n}\n\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels. \n * \n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n * \n * @example\n * ```js\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n * \n * Use {@link forEachAsync} if you want to use an async `iterator` and async `fn`.\n * @param iterator Iterable or array\n * @typeParam V Type of iterable\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport const forEach = <V>(iterator:IterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>boolean|void) => {\n  for (const x of iterator) {\n    const r = fn(x);\n    if (typeof r === `boolean` && !r) break;\n  }\n};\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n * \n * Use {@link forEach} for a synchronous version.\n * \n * ```\n * // Prints items from array every second\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\n * ```\n * \n * @example Retry `doSomething` up to five times, with 5 seconds between each attempt\n * ```\n * await forEachAsync(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @typeParam V Type of iterable\n */\nexport const forEachAsync = async function <V> (iterator:AsyncIterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>Promise<boolean>|Promise<void>, intervalMs?:number) {\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  }\n};\n\nexport type RepeatPredicate = (repeats:number, valuesProduced:number)=>boolean;\n/**\n * Runs `fn` a certain number of times, accumulating result into an array.\n * If `fn` returns undefined, the result is ignored.\n * \n * ```js\n * // Results will be an array with five random numbers\n * const results = repeat(5, () => Math.random());\n * ```\n * \n * Repeats can be specified as an integer (eg. 5 for five repeats), or a function\n * that gives _false_ when repeating should stop.\n * \n * ```js\n * // Keep running `fn` until we've accumulated 10 values\n * // Useful if `fn` sometimes returns _undefined_\n * const results = repeat((repeats, valuesProduced) => valuesProduced < 10, fn);\n * ```\n * \n * If you don't need to accumulate return values, consider {@link Generators.count | Generators.count} with {@link Flow.forEach | Flow.forEach}.\n * \n * @param countOrPredicate Number of repeats or function returning false when to stop \n * @param fn Function to run, must return a value to accumulate into array or _undefined_\n * @returns Array of accumulated results\n */\nexport const repeat = <V>(countOrPredicate:number|RepeatPredicate, fn:()=>V|undefined):readonly V[] => {\n  // Unit tested: expected return array length\n  //eslint-disable-next-line functional/no-let\n  let repeats, valuesProduced;\n  repeats = valuesProduced = 0;\n  const ret = [];\n\n  if (typeof countOrPredicate === `number`) {\n    guardNumber(countOrPredicate, `positive`, `countOrPredicate`);\n    while (countOrPredicate-- > 0) {\n      repeats++;\n      const v = fn();\n      if (v === undefined) continue;\n      //eslint-disable-next-line functional/immutable-data\n      ret.push(v);\n      valuesProduced++;\n    }\n  } else {\n    while (countOrPredicate(repeats, valuesProduced)) {\n      repeats++;\n      const v = fn();\n      if (v === undefined) continue;\n      //eslint-disable-next-line functional/immutable-data\n      ret.push(v);\n      valuesProduced++;\n    }\n  }\n  return ret;\n};\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n * \n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n * \n * // Multiplies random values against eachother 10 times\n * repeatReduce(10, () => Math.random(), (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate \n * @param fn \n * @param initial \n * @param reduce \n * @returns \n */\nexport const repeatReduce = <V>(countOrPredicate:number|RepeatPredicate, fn:()=>V|undefined, initial:V, reduce:(acc:V, value:V)=>V):V => {\n  if (typeof countOrPredicate === `number`) {\n    guardNumber(countOrPredicate, `positive`, `countOrPredicate`);\n    while (countOrPredicate-- > 0) {\n      const v = fn();\n      if (v === undefined) continue;\n      initial = reduce(initial, v);    \n    }\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let repeats, valuesProduced;\n    repeats = valuesProduced = 0;\n    while (countOrPredicate(repeats, valuesProduced)) {\n      repeats++;\n      const v = fn();\n      if (v === undefined) continue;\n      initial = reduce(initial, v);\n      valuesProduced++;\n    }\n  }\n  return initial;\n};\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = { ...(window as any).ixfx, Flow: { StateMachine, Timer, forEach, forEachAsync, repeat } };\n  }\n} catch { /* no-op */ }\n","import { clamp } from '../data/Clamp.js';\nimport { HasCompletion } from './index.js';\n/**\n * Creates a timer\n */\nexport type TimerSource = ()=>Timer;\n \n/**\n * A timer instance\n */\nexport type Timer = {\n  reset():void\n  get elapsed():number\n}\n\nexport type ModTimer = Timer & {\n  mod(amt:number):void\n}\n\n/**\n * Returns a function that returns true if timer is complete\n * \n * ```js\n * const timer = hasElapsedMs(1000);\n * timer(); // Returns true if timer is done\n * ```\n * \n * See also {@link completionMs}.\n * @param totalMs \n * @returns \n */\nexport function hasElapsedMs(totalMs:number):()=>boolean {\n  const t = relativeTimer(totalMs, msElapsedTimer());\n  return () => t.isDone;\n}\n\n/**\n * Returns a function that returns the percentage of timer completion\n * \n * ```js\n * const timer = completionMs(1000);\n * timer(); // Returns 0..1\n * ```\n * \n * See also {@link hasElapsedMs}.\n * @param totalMs \n * @returns \n */\nexport function completionMs(totalMs:number):()=>number {\n  const t = relativeTimer(totalMs, msElapsedTimer());\n  return () => t.elapsed;\n}\n\nexport const frequencyTimerSource = (frequency:number):TimerSource => () => frequencyTimer(frequency, msElapsedTimer());\n\n/**\n * Wraps a timer, returning a relative elapsed value.\n * \n * ```js\n * let t = relativeTimer(1000, msElapsedTimer());\n * \n * t.isDone;  // true if total has elapsed\n * t.reset(); // reset timer to 0\n * t.elapsed; // 0..1 scale of how close to completion\n * ```\n * \n * Use `relativeTimerMs` if you want to have a millisecond-based total\n * @private\n * @param total Total\n * @param timer Timer\n * @param clampValue If true, returned value never exceeds 1.0 \n * @returns Timer\n */\nexport const relativeTimer = (total:number, timer:Timer, clampValue = true):ModTimer & HasCompletion => {\n  //eslint-disable-next-line functional/no-let\n  let done = false;\n  //eslint-disable-next-line functional/no-let\n  let modAmt = 1;\n\n  return {\n    mod(amt:number) {\n      modAmt = amt;\n    },\n    get isDone() {\n      return done;\n    },\n    reset:() => {\n      done = false;\n      timer.reset();\n    },\n    get elapsed() {\n      //eslint-disable-next-line functional/no-let\n      let v = timer.elapsed / (total * modAmt);\n      if (clampValue) v = clamp(v);\n      if (v >= 1) done = true;\n      return v;\n    }\n  };\n};\n\n/**\n * Wraps a timer, returning a relative elapsed value.\n * \n * ```js\n * // Timer that counts to 1,000 milliseconds\n * let t = relativeTimerMs(1000);\n * \n * t.isDone;  // true if total milliseconds has elapsed\n * t.reset(); // reset timer to 0\n * t.elapsed; // 0..1 scale of how close to completion\n * ```\n * @param total Total\n * @param timer Timer\n * @param clampValue If true, returned value never exceeds 1.0 \n * @returns Timer\n */\nexport const relativeTimerMs = (total:number, clampValue = true) => relativeTimer(total, msElapsedTimer(), clampValue);\n\n/**\n * Wraps a tick-based 'timer', returning a relative value (0..1).\n * A value of 1 indicates the timer has completed.\n * \n * ```js\n * // Timer that counts 20 ticks\n * let t = relativeTimerTicks(20);\n * \n * t.isDone;  // true if total ticks has elapsed\n * t.reset(); // reset timer to 0\n * t.elapsed; // 0..1 scale of how close to completion\n * ```\n * \n * Example:\n * ```js\n * const t = relativeTimerTicks(10);\n * while (!t.isDone) {\n *  const progress = t.elapsed; \n *  // Yields: 0.1, 0.2, ... 1\n * }\n * ```\n * @param total \n * @param clampValue \n * @returns \n */\nexport const relativeTimerTicks = (total:number, clampValue = true) => relativeTimer(total, ticksElapsedTimer(), clampValue);\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n * \n * In practice, timers are used to 'drive' something like an Oscillator.\n * \n * @example Init a spring oscillator, with a half a cycle per second\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * Oscillators.spring({}, frequencyTimer(0.5));\n * ```\n * \n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n * \n * It returns a `ModTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n * \n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency \n * @param timer \n * @returns \n */\nexport const frequencyTimer = (frequency:number, timer:Timer = msElapsedTimer()):ModTimer => {\n  const cyclesPerSecond = frequency/1000;\n  //eslint-disable-next-line functional/no-let\n  let modAmt = 1;\n  return {\n    mod:(amt:number) => {\n      modAmt = amt;\n    },\n    reset:() => {\n      timer.reset();\n    },\n    get elapsed() {\n      // Get position in a cycle\n      const v = timer.elapsed * (cyclesPerSecond * modAmt);\n\n      // Get fractional part\n      const f = v - Math.floor(v);\n      if (f < 0) throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v} f: ${f}`);\n      if (f > 1) throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v} f: ${f}`);\n      return f;\n    }\n  };\n};\n\n/**\n * A timer that uses clock time\n * @private\n * @returns {Timer}\n */\nexport const msElapsedTimer = ():Timer => {\n  // eslint-disable-next-line functional/no-let\n  let start = performance.now();\n  return {\n    reset: () => {\n      start = performance.now();\n    },\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n * \n * The first call to elapsed will return 1.\n * @private\n * @returns {Timer}\n */\nexport const ticksElapsedTimer = ():Timer => {\n  // eslint-disable-next-line functional/no-let\n  let start = 0;\n  return {\n    reset: () => {\n      start = 0;\n    },\n    get elapsed() { return ++start; }\n  };\n};\n\n","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n * \n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);         \n * // 1 - above default max of 1\n * clamp(1.5);         \n * // 0 - below range\n * clamp(-50, 0, 100); \n * // 50 - within range\n * clamp(50, 0, 50);   \n * ```\n * \n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\n * \n * @param v Value to clamp\n * @param Minimum value (inclusive)\n * @param Maximum value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (v: number, min = 0, max = 1) => {\n  // ✔ UNIT TESTED\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\n\n  if (v < min) return min;\n  if (v > max) return max;\n  return v;\n};\n\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n * \n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(4, myArray);    // 3\n * clampIndex(-1, myArray);   // 0\n * \n * clampIndex(5, 3); // 2\n * ```\n * \n * Throws an error if `v` is not an integer.\n * \n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n * \n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const clampIndex = (v: number, arrayOrLength: number|readonly any[]):number => {\n  // ✔ UNIT TESTED\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\n  const length = (Array.isArray(arrayOrLength)) ?  arrayOrLength.length : arrayOrLength as number;\n\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\n  v = Math.round(v);\n  if (v < 0) return 0;\n  if (v >= length) return length - 1;\n  return v;\n};","import {integer as guardInteger} from '../Guards.js';\nimport {HasCompletion} from './index.js';\n\nexport type TimeoutSyncCallback = (elapsedMs?:number, ...args:readonly unknown[]) => void\nexport type TimeoutAsyncCallback = (elapsedMs?:number, ...args:readonly unknown[]) => Promise<void>\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  start(altTimeoutMs?: number, args?:readonly unknown[]): void;\n  cancel(): void;\n  get isDone(): boolean;\n}\n\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset\n *  \n * Once `start()` is called, `callback` will be scheduled to execute after `timeoutMs`.\n * If `start()` is called again, the waiting period will be reset to `timeoutMs`.\n * \n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000); \n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n * \n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * t.isDone;    // True if a scheduled event is pending\n * ```\n * \n * Callback function receives any additional parameters passed in from start.\n * This can be useful for passing through event data:\n * \n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n * \n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n * \n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback \n * @param timeoutMs \n * @returns {@link Timeout}\n */\nexport const timeout = (callback:TimeoutSyncCallback|TimeoutAsyncCallback, timeoutMs:number):Timeout => {\n  if (callback === undefined) throw new Error(`callback parameter is undefined`);\n  guardInteger(timeoutMs, `aboveZero`, `timeoutMs`);\n\n  //eslint-disable-next-line functional/no-let\n  let timer = 0;\n  //eslint-disable-next-line functional/no-let\n  let startedAt = 0;\n  const start = async (altTimeoutMs:number = timeoutMs, args:unknown[]):Promise<void> => {\n    \n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      try {\n        guardInteger(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      } catch (e) {\n        reject(e);\n        return;\n      }\n      if (timer !== 0) cancel();\n      timer = window.setTimeout(async () => {\n        await callback(performance.now() - startedAt, ...args);\n        timer = 0;\n        resolve(undefined); \n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (timer === 0) return;\n    startedAt = 0;\n    window.clearTimeout(timer);\n  };\n\n  return {\n    start,\n    cancel,\n    get isDone() {\n      return timer !== 0;\n    },\n  };\n};\n","\nexport type UpdateFailPolicy = `fast` | `slow` | `backoff`; \n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `intervalMs` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n * \n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n * \n * Callback `fn` is passed how many milliseconds have elapsed since last update. It's\n * minimum value will be `intervalMs`.\n * \n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n * \n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `intervalMs` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n * \n * @param fn Async function to call. Must return a value.\n * @param intervalMs Maximum age of cached result\n * @param updateFail `slow` by default\n * @returns Value\n */\nexport const updateOutdated = <V>(fn:(elapsedMs?:number)=>Promise<V>, intervalMs:number, updateFail:UpdateFailPolicy = `slow`):()=>Promise<V> => {\n  //eslint-disable-next-line functional/no-let\n  let lastRun = 0;\n  //eslint-disable-next-line functional/no-let\n  let lastValue:V|undefined;\n  //eslint-disable-next-line functional/no-let\n  let intervalMsCurrent = intervalMs;\n\n  //eslint-disable-next-line no-async-promise-executor\n  return () => (new Promise(async (resolve, reject) => {\n    const elapsed = performance.now() - lastRun;\n    if (lastValue === undefined || elapsed > intervalMsCurrent) {\n      try {\n        lastRun = performance.now();\n        lastValue = await fn(elapsed);\n        intervalMsCurrent = intervalMs;\n      } catch (ex) {\n        if (updateFail === `fast`) {\n          lastValue = undefined;\n          lastRun = 0;\n        } else if (updateFail === `backoff`) {\n          intervalMsCurrent = Math.floor(intervalMsCurrent*1.2);\n        }\n        reject(ex);\n        return;\n      }\n    } \n    resolve(lastValue);\n  }));\n};","import {integer as guardInteger} from '../Guards.js';\nimport {HasCompletion} from './index.js';\n\n/**\n * Runs a function continuously, returned by {@link Continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, it is reset\n   */\n  start(): void\n  /**\n   * How many milliseconds since start() was last called\n   */\n  get elapsedMs(): number\n  /**\n   * How many iterations of the loop since start() was last called\n   */\n  get ticks(): number\n  /**\n   * Whether loop has finished\n   */\n  get isDone(): boolean\n  /**\n   * Stops loop\n   */\n  cancel(): void\n\n  set intervalMs(ms:number);\n  get intervalMs():number\n}\n\nexport type ContinuouslySyncCallback = (ticks?:number, elapsedMs?:number) => boolean|void\nexport type ContinuouslyAsyncCallback = (ticks?:number, elapsedMs?:number) => Promise<boolean|void>\n\nconst raf = typeof window !== `undefined` ? (cb:()=>void) => window.requestAnimationFrame(cb) : (cb:()=>void) => setTimeout(cb, 1);\n\n/**\n * Returns a {@link Continuously} that continuously executes `callback`. \n * If callback returns _false_, loop exits.\n * \n * Call `start` to begin/reset loop. `cancel` stops loop.\n * \n * @example Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n * \n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();  \n * ```\n * \n * @example With delay\n * ```js\n * const fn = () => {\n *  console.log(`1 minute`);\n * }\n * const c = continuously(fn, 60*1000);\n * c.start(); // Runs `fn` every minute\n * ```\n * \n * @example Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * ```\n * \n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n * \n * The `callback` function can receive a few arguments:\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n * \n * And if `callback` explicitly returns _false_, the loop will exit:\n * ```js\n * continuously((ticks) => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n * @param callback Function to run. If it returns false, loop exits.\n * @param resetCallback Callback when/if loop is reset. If it returns false, loop exits\n * @param intervalMs \n * @returns \n */\nexport const continuously = (callback:ContinuouslyAsyncCallback|ContinuouslySyncCallback, intervalMs?:number, resetCallback?:((ticks?:number, elapsedMs?:number) => boolean|void)):Continuously => {\n  if (intervalMs !== undefined) guardInteger(intervalMs, `positive`, `intervalMs`);\n\n  //eslint-disable-next-line functional/no-let\n  let running = false;\n  //eslint-disable-next-line functional/no-let\n  let ticks = 0;\n  //eslint-disable-next-line functional/no-let\n  let startedAt = performance.now();\n  //eslint-disable-next-line functional/no-let\n  let iMs = (intervalMs === undefined) ? 0 : intervalMs;\n\n  const schedule = (iMs === 0) ? raf : (cb:()=>void) => setTimeout(cb, iMs);\n  \n  const cancel = () => {\n    if (!running) return;\n    running = false;\n    ticks = 0;\n  };\n\n  const loop = async () => {\n    if (!running) return;\n    const valOrPromise = callback(ticks++, performance.now() - startedAt);\n    //eslint-disable-next-line functional/no-let\n    let val;\n    if (typeof valOrPromise === `object`) {\n      val = await valOrPromise;\n    } else {\n      val = valOrPromise;\n    }\n    if (val !== undefined && !val) {\n      cancel();\n      return;\n    }\n\n    schedule(loop);\n  };\n\n  const start = () => {\n    // Already running, but theres a resetCallback to check if we should keep going\n    if (running && resetCallback !== undefined) {\n      const r = resetCallback(ticks, performance.now() - startedAt);\n      startedAt = performance.now();\n      if (r !== undefined && !r) {\n        // Reset callback tells us to stop\n        cancel();\n        return; // Skip starting again\n      } \n    } else if (running) {\n      return; // already running\n    }\n\n    // Start running\n    running = true;\n    schedule(loop);\n  };\n\n  return {\n    start,\n    get intervalMs() {\n      return iMs;\n    },\n    set intervalMs(ms:number) {\n      guardInteger(ms, `positive`, `ms`);\n      iMs = ms;\n    },\n    get isDone() {\n      return !running;\n    },\n    get ticks() {\n      return ticks;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n    cancel\n  };\n};","import {timeout, TimeoutSyncCallback, TimeoutAsyncCallback} from \"./Timeout.js\";\n\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n * \n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n * \n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n * \n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n * \n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n * \n * // Don't do this if we want to benefit from the debounce\n * fn();\n * \n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n * \n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n * \n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n * \n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n * \n * Arguments can be passed to the debounced function:\n * \n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n * \n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n * \n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param timeoutMs Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (callback:TimeoutSyncCallback|TimeoutAsyncCallback, timeoutMs:number):DebouncedFunction => {\n  const t = timeout(callback, timeoutMs);\n  return (...args:unknown[]) => t.start(undefined, args);\n};\n\n/**\n * Debounced function\n */\nexport type DebouncedFunction = (...args:readonly unknown[]) =>void\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n * \n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n * \n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n * \n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n * \n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (callback:(elapsedMs:number, ...args:readonly unknown[]) => void|Promise<unknown>, intervalMinMs:number) => {\n  //eslint-disable-next-line functional/no-let\n  let trigger = 0;\n\n  return async (...args:unknown[]) => {\n    const elapsed = performance.now()-trigger; \n    if (elapsed >= intervalMinMs) {\n      const r = callback(elapsed, ...args);\n      if (typeof r === `object`) await r;\n      trigger = performance.now();\n    }\n  };\n};","\n/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n * \n * \n * @example Verbose example\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n * \n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n * \n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n * \n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n * \n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n * \n * The completion handler is useful for removing event handlers.\n * \n * @example Compact example\n * ```js\n * const done = waitFor(1000, \n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  },\n *  (success) => {\n *    console.log(`Completed. Success: ${success ?? `Yes!` : `No`}`)\n *  });\n * \n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n * @param timeoutMs \n * @param onAborted \n * @param onComplete \n * @returns \n */\nexport const waitFor = (timeoutMs:number, onAborted:(reason:string)=>void, onComplete?:(success:boolean)=>void) => {\n  //eslint-disable-next-line functional/no-let\n  let success = false;\n  const done = (error?:string) => {\n    if (t !== 0) {\n      window.clearTimeout(t);\n      t = 0;\n    }\n    if (error) {\n      onAborted(error); \n    } else {\n      success = true;\n    }\n    if (onComplete !== undefined) onComplete(success);\n  };\n  \n  //eslint-disable-next-line functional/no-let\n  let t = window.setTimeout(() => {\n    t = 0;\n    try {\n      onAborted(`Timeout after ${timeoutMs}ms`);\n    } finally {\n      if (onComplete !== undefined) onComplete(success);\n    }\n  }, timeoutMs);\n\n  return done;\n};","import {  integer as guardInteger } from \"../Guards.js\";\n\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n * \n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n * \n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n * \n * });\n * ```\n * \n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback \n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = (nth:number, callback?:(...args:readonly unknown[])=>void) => {\n  guardInteger(nth, `positive`, `nth`);\n  \n  //eslint-disable-next-line functional/no-let\n  let counter = 0;\n  return (...args:unknown[]):boolean => {\n    if (++counter === nth) {\n      counter = 0;\n      if (callback) callback(...args);\n      return true;\n    }\n    return false;\n  };\n};"],"mappings":"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","names":[]}