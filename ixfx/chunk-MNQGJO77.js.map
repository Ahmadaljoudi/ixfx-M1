{"version":3,"sources":["../src/Util.ts"],"sourcesContent":["import { number as guardNumber} from \"./Guards.js\";\r\n\r\n/**\r\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\r\n * If _end_ is omitted, the the `start` value will be used.\r\n * \r\n * ```js\r\n * startsEnds(`This is a string`, `This`, `string`); // True\r\n * startsEnds(`This is a string`, `is`, `a`); // False\r\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\r\n * ```\r\n * @param source String to search within \r\n * @param start Start\r\n * @param end End (if omitted, start will be looked for at end as well)\r\n * @returns True if source starts and ends with provided values.\r\n */\r\nexport const startsEnds = (source:string, start:string, end:string = start):boolean => source.startsWith(start) && source.endsWith(end);\r\n\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * @example Usage\r\n * ```js\r\n * // 0.5 - just fine, within default of 0 to 1\r\n * clamp(0.5);         \r\n * // 1 - above default max of 1\r\n * clamp(1.5);         \r\n * // 0 - below range\r\n * clamp(-50, 0, 100); \r\n * // 50 - within range\r\n * clamp(50, 0, 50);   \r\n * ```\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * \r\n * @param v Value to clamp\r\n * @param Minimum value (inclusive)\r\n * @param Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Scales `v` from an input range to an output range (aka `map`)\r\n * \r\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\r\n * ```js\r\n * scale(sensorReading, 100, 500, 0, 1);\r\n * ```\r\n * \r\n * `scale` defaults to a percentage-range output, so you can get away with:\r\n * ```js\r\n * scale(sensorReading, 100, 500);\r\n * ```\r\n * @param v Value to scale\r\n * @param inMin Input minimum\r\n * @param inMax Input maximum\r\n * @param outMin Output minimum. If not specified, 0\r\n * @param outMax Output maximum. If not specified, 1.\r\n * @returns Scaled value\r\n */\r\nexport const scale = (\r\n  v:number, \r\n  inMin:number, inMax:number, \r\n  outMin?:number, outMax?:number\r\n):number => {\r\n  if (outMax === undefined) outMax = 1;\r\n  if(outMin === undefined) outMin = 0;\r\n\r\n  return (v - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\r\n};\r\n\r\n/**\r\n * Scales an input percentage to a new percentage range.\r\n * \r\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\r\n * _output_ percentage of `outMin`-`outMax`.\r\n * \r\n * ```js\r\n * // Scales 50% to a range of 0-10%\r\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\r\n * ```\r\n * \r\n * An error is thrown if any parameter is outside of percentage range. This added\r\n * safety is useful for catching bugs. Otherwise, you could just as well call\r\n * `scale(percentage, 0, 1, outMin, outMax)`.\r\n * \r\n * @param percentage Input value, within percentage range\r\n * @param outMin Output minimum, between 0-1\r\n * @param outMax Output maximum, between 0-1\r\n * @returns Scaled value between outMin-outMax.\r\n */\r\nexport const scalePercentages = (percentage:number, outMin:number, outMax:number = 1):number => {\r\n  guardNumber(percentage, `percentage`, `v`);\r\n  guardNumber(outMin, `percentage`, `outMin`);\r\n  guardNumber(outMax, `percentage`, `outMax`);\r\n  return scale(percentage, 0, 1, outMin, outMax);\r\n};\r\n\r\n/**\r\n * Scales an input percentage value  to an output range\r\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\r\n * ```js\r\n * scalePercent(0.5, 10, 20); // 15\r\n * ```\r\n * \r\n * @param v Value to scale\r\n * @param outMin Minimum for output\r\n * @param outMax Maximum for output\r\n * @returns \r\n */\r\nexport const scalePercent = (v:number, outMin:number, outMax:number):number => {\r\n  guardNumber(v, `percentage`, `v`);\r\n  return scale(v, 0, 1, outMin, outMax);\r\n};\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\r\n * Returns value then will always be at least zero, and a valid array index.\r\n * \r\n * @example Usage\r\n * ```js\r\n * // Array of length 4\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampIndex(0, myArray);    // 0\r\n * clampIndex(4, myArray);    // 3\r\n * clampIndex(-1, myArray);   // 0\r\n * \r\n * clampIndex(5, 3); // 2\r\n * ```\r\n * \r\n * Throws an error if `v` is not an integer.\r\n * @param v Value to clamp (must be an interger)\r\n * @param arrayOrLength Array, or length of bounds (must be an integer)\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const clampIndex = (v: number, arrayOrLength: number|readonly any[]):number => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  const length = (Array.isArray(arrayOrLength)) ?  arrayOrLength.length : arrayOrLength as number;\r\n\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\r\n * \r\n * @example Get the halfway point between 30 and 60\r\n * ```js\r\n * interpolate(0.5, 30, 60);\r\n * ````\r\n * \r\n * Interpolation is often used for animation. In that case, `amount`\r\n * would start at 0 and you would keep interpolating up to `1`\r\n * @example\r\n * ```js\r\n * // Go back and forth between 0 and 1 by 0.1\r\n * let pp = percentPingPong(0.1);\r\n * continuously(() => {\r\n *  // Get position in ping-pong\r\n *  const amt = pp.next().value;\r\n *  // interpolate between xStart and xEnd\r\n *  let v = interpolate(amt, xStart, xEnd); \r\n *  // do something with v...\r\n * }).start();\r\n * ```\r\n * \r\n * See also {@link Colour.interpolate}, {@link Points.interpolate}.\r\n * @param amount Interpolation amount, between 0 and 1 inclusive\r\n * @param a Start (ie when `amt` is 0)\r\n * @param b End (ie. when `amt` is 1)\r\n * @returns Interpolated value which will be betewen `a` and `b`.\r\n */\r\nexport const interpolate =(amount:number, a:number, b:number):number => {\r\n  const v = (1-amount) * a + amount * b;\r\n  return v;\r\n};\r\n\r\n\r\n/**\r\n * @private\r\n */\r\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\r\n\r\n/**\r\n * @private\r\n */\r\nexport type IsEqual<V> = (a:V, b:V) => boolean;\r\n\r\n/**\r\n * Default comparer function is equiv to checking `a === b`\r\n * @private\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqualDefault = <V>(a:V, b:V):boolean => a === b;\r\n\r\n/**\r\n * Comparer returns true if string representation of `a` and `b` are equal.\r\n * Uses `toStringDefault` to generate a string representation (`JSON.stringify`)\r\n * @private\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean} True if the contents of `a` and `b` are equal\r\n */\r\nexport const isEqualValueDefault = <V>(a:V, b:V):boolean => {\r\n  // ✔ UNIT TESTED\r\n  if (a === b) return true; // Object references are the same, or string values are the same\r\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\r\n};\r\n\r\n/**\r\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\r\n * @private\r\n * @template V\r\n * @param {V} itemToMakeStringFor\r\n * @returns {string}\r\n */\r\nexport const toStringDefault = <V>(itemToMakeStringFor:V):string => ((typeof itemToMakeStringFor === `string`) ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor));\r\n\r\n/**\r\n * Wraps a number within a specified range.\r\n * See {@link wrapDegrees} to wrap within 0-360.\r\n * \r\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\r\n * Eg: to add 200 to 200, we don't want 400, but 40. \r\n * ```js\r\n * const v = wrapped(200+200, 0, 360); // 40\r\n * ```\r\n * \r\n * Or if we minus 100 from 10, we don't want -90 but 270\r\n * ```js\r\n * const v = wrapped(10-100, 0, 360); // 270\r\n * ```\r\n * \r\n * Non-zero starting points can be used. A range of 20-70: \r\n * ```js\r\n * const v = wrapped(-20, 20, 70); // 50 \r\n * ```\r\n * @param v Value to wrap\r\n * @param min Minimum of range\r\n * @param max Maximum of range\r\n * @returns \r\n */\r\nexport const wrap = (v:number, min:number, max:number) => {\r\n  if (v === min) return min;\r\n  if (v === max) return max;\r\n  v -= min; \r\n  max -= min;\r\n  v = v%max; \r\n  if (v < 0) v = max - Math.abs(v) + min;\r\n  return v + min;\r\n};\r\n\r\n/**\r\n * Wraps the given `degrees` to within 0-360, using {@link wrap}.\r\n * \r\n * Eg\r\n * ```\r\n * wrapDegrees(150); // 150 - fine, within range\r\n * wrapDegrees(400); // 40  - wraps around\r\n * wrapDegrees(-20); // 340 - wraps around\r\n * @param v\r\n * @returns \r\n */\r\nexport const wrapDegrees = (degrees:number) => wrap(degrees, 0, 360);\r\n\r\n/**\r\n * Performs a calculation within a wrapping number range. This is a lower-level function.\r\n * See also: {@link wrap} for simple wrapping within a range.\r\n * \r\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\r\n * `a` and `b` is the range you want to work in. \r\n * \r\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\r\n * ```js\r\n * wrapRange(0,360, (distance) => {\r\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\r\n *  return distance * 0.5; // eg return middle point \r\n * }, 30, 330);\r\n * ```\r\n * \r\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\r\n * conform it to the `min` and `max` range before it's returned to the caller.\r\n * \r\n * @param a Output start (eg. 60)\r\n * @param b Output end (eg 300)\r\n * @param min Range start (eg 0)\r\n * @param max Range end (eg 360)\r\n * @param fn Returns a computed value from 0 to `distance`.\r\n * @returns \r\n */\r\nexport const wrapRange = (min:number, max:number, fn:(distance:number)=>number, a:number, b:number) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let r = 0;\r\n  // No wrapping\r\n  const distF = Math.abs(b - a);\r\n  // When b is wrapped forwards\r\n  const distFwrap = Math.abs(max-a + b);\r\n  // When b is wrapped backwards (10, 300)\r\n  const distBWrap = Math.abs(a + (360-b));\r\n  \r\n  const distMin = Math.min(distF, distFwrap, distBWrap);\r\n  if (distMin === distBWrap) {\r\n    // (10, 300) = 70\r\n    r = a - fn(distMin);\r\n  } else if (distMin === distFwrap) {\r\n    // (300, 60) = 120\r\n    r = a + fn(distMin);\r\n  } else {\r\n    // Forwards or backwards without wrapping\r\n    if (a > b) {\r\n      // (240,120) -- backwards\r\n      r = a - fn(distMin);\r\n    } else {\r\n      // (120,240) -- forwards\r\n      r = a + fn(distMin);\r\n    }\r\n  }\r\n  return wrap(r, min, max); \r\n};"],"mappings":";;;;;AAgBO,IAAM,aAAa,CAAC,QAAe,OAAc,MAAa,UAAkB,OAAO,WAAW,UAAU,OAAO,SAAS;AAyB5H,IAAM,QAAQ,CAAC,GAAW,MAAM,GAAG,MAAM,MAAM;AAEpD,MAAI,OAAO,MAAM;AAAI,UAAM,IAAI,MAAM;AACrC,MAAI,OAAO,MAAM;AAAM,UAAM,IAAI,MAAM;AACvC,MAAI,OAAO,MAAM;AAAM,UAAM,IAAI,MAAM;AAEvC,MAAI,IAAI;AAAK,WAAO;AACpB,MAAI,IAAI;AAAK,WAAO;AACpB,SAAO;AAAA;AAsBF,IAAM,QAAQ,CACnB,GACA,OAAc,OACd,QAAgB,WACN;AACV,MAAI,WAAW;AAAW,aAAS;AACnC,MAAG,WAAW;AAAW,aAAS;AAElC,SAAQ,KAAI,SAAU,UAAS,UAAW,SAAQ,SAAS;AAAA;AAuBtD,IAAM,mBAAmB,CAAC,YAAmB,QAAe,SAAgB,MAAa;AAC9F,SAAY,YAAY,cAAc;AACtC,SAAY,QAAQ,cAAc;AAClC,SAAY,QAAQ,cAAc;AAClC,SAAO,MAAM,YAAY,GAAG,GAAG,QAAQ;AAAA;AAelC,IAAM,eAAe,CAAC,GAAU,QAAe,WAAyB;AAC7E,SAAY,GAAG,cAAc;AAC7B,SAAO,MAAM,GAAG,GAAG,GAAG,QAAQ;AAAA;AAwBzB,IAAM,aAAa,CAAC,GAAW,kBAAgD;AAEpF,MAAI,CAAC,OAAO,UAAU;AAAI,UAAM,IAAI,MAAM,mCAAmC;AAC7E,QAAM,SAAU,MAAM,QAAQ,iBAAmB,cAAc,SAAS;AAExE,MAAI,CAAC,OAAO,UAAU;AAAS,UAAM,IAAI,MAAM,wCAAwC,WAAW,OAAO;AACzG,MAAI,KAAK,MAAM;AACf,MAAI,IAAI;AAAG,WAAO;AAClB,MAAI,KAAK;AAAQ,WAAO,SAAS;AACjC,SAAO;AAAA;AAgCF,IAAM,cAAa,CAAC,QAAe,GAAU,MAAoB;AACtE,QAAM,IAAK,KAAE,UAAU,IAAI,SAAS;AACpC,SAAO;AAAA;AAsBF,IAAM,iBAAiB,CAAI,GAAK,MAAgB,MAAM;AAWtD,IAAM,sBAAsB,CAAI,GAAK,MAAgB;AAE1D,MAAI,MAAM;AAAG,WAAO;AACpB,SAAO,gBAAgB,OAAO,gBAAgB;AAAA;AAUzC,IAAM,kBAAkB,CAAI,wBAAmC,OAAO,wBAAwB,WAAY,sBAAsB,KAAK,UAAU;AA0B/I,IAAM,OAAO,CAAC,GAAU,KAAY,QAAe;AACxD,MAAI,MAAM;AAAK,WAAO;AACtB,MAAI,MAAM;AAAK,WAAO;AACtB,OAAK;AACL,SAAO;AACP,MAAI,IAAE;AACN,MAAI,IAAI;AAAG,QAAI,MAAM,KAAK,IAAI,KAAK;AACnC,SAAO,IAAI;AAAA;AAcN,IAAM,cAAc,CAAC,YAAmB,KAAK,SAAS,GAAG;AA2BzD,IAAM,YAAY,CAAC,KAAY,KAAY,IAA8B,GAAU,MAAa;AAErG,MAAI,IAAI;AAER,QAAM,QAAQ,KAAK,IAAI,IAAI;AAE3B,QAAM,YAAY,KAAK,IAAI,MAAI,IAAI;AAEnC,QAAM,YAAY,KAAK,IAAI,IAAK,OAAI;AAEpC,QAAM,UAAU,KAAK,IAAI,OAAO,WAAW;AAC3C,MAAI,YAAY,WAAW;AAEzB,QAAI,IAAI,GAAG;AAAA,aACF,YAAY,WAAW;AAEhC,QAAI,IAAI,GAAG;AAAA,SACN;AAEL,QAAI,IAAI,GAAG;AAET,UAAI,IAAI,GAAG;AAAA,WACN;AAEL,UAAI,IAAI,GAAG;AAAA;AAAA;AAGf,SAAO,KAAK,GAAG,KAAK;AAAA;","names":[]}