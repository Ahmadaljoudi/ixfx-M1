{"version":3,"sources":["../src/flow/Timer.ts"],"sourcesContent":["import {integer as guardInteger} from '../Guards.js';\r\nimport {clamp} from '../Util.js';\r\n\r\n/**\r\n * Creates a timer\r\n * @private\r\n */\r\nexport type TimerSource = () => Timer;\r\n \r\n/**\r\n * A timer instance\r\n * @private\r\n */\r\nexport type Timer = {\r\n  reset(): void\r\n  get elapsed(): number\r\n}\r\n\r\nexport type ModTimer = Timer & {\r\n  mod(amt:number):void\r\n}\r\n/**\r\n * @private\r\n */\r\nexport type HasCompletion = {\r\n  get isDone(): boolean;\r\n}\r\n\r\n/**\r\n * A resettable timeout, returned by {@link timeout}\r\n */\r\nexport type Timeout = HasCompletion & {\r\n  start(altTimeoutMs?: number, args?:readonly unknown[]): void;\r\n  cancel(): void;\r\n  get isDone(): boolean;\r\n}\r\n\r\n/**\r\n * Creates a debounce function\r\n * ```js\r\n * // Create\r\n * const d = debounce(fn, 1000);\r\n * \r\n * // Use\r\n * d(); // Only calls fn after 1000s\r\n * ```\r\n * \r\n * @example Handle most recent pointermove event after 1000ms\r\n * ```js\r\n * // Set up debounced handler\r\n * const moveDebounced = debounce((elapsedMs, evt) => {\r\n *    // Handle event\r\n * }, 500);\r\n * \r\n * // Wire up event\r\n * el.addEventListener(`pointermove`, moveDebounced);\r\n * ```\r\n * \r\n * Debounced function can be awaited:\r\n * ```js\r\n * const d = debounce(fn, 1000);\r\n * await d();\r\n * ```\r\n * @param callback \r\n * @param timeoutMs \r\n * @returns \r\n */\r\nexport const debounce = (callback:TimeoutSyncCallback|TimeoutAsyncCallback, timeoutMs:number):DebouncedFunction => {\r\n  const t = timeout(callback, timeoutMs);\r\n  return (...args:unknown[]) => t.start(undefined, args);\r\n};\r\n\r\n/**\r\n * Debounced function\r\n * @private\r\n */\r\nexport type DebouncedFunction = (...args:readonly unknown[]) =>void\r\n\r\n/***\r\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\r\n * \r\n * @example Only handle move event every 500ms\r\n * ```js\r\n * const moveThrottled = throttle( (elapsedMs, args) => {\r\n *  // Handle ar\r\n * }, 500);\r\n * el.addEventListener(`pointermove`, moveThrottled)\r\n * ```\r\n * \r\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\r\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\r\n * that the return function from `throttle` is repeatedly called, such as the case for handling\r\n * a stream of data/events.\r\n * \r\n * @example Manual trigger\r\n * ```js\r\n * // Set up once\r\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\r\n * \r\n * // Later, trigger throttle. Sometimes the callback will run,\r\n * // with data passed in to args[0]\r\n * t(data);\r\n * ```\r\n */\r\nexport const throttle = (callback:(elapsedMs:number, ...args:readonly unknown[]) => void|Promise<unknown>, intervalMinMs:number) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let trigger = 0;\r\n\r\n  return async (...args:unknown[]) => {\r\n    const elapsed = performance.now()-trigger; \r\n    if (elapsed >= intervalMinMs) {\r\n      const r = callback(elapsed, ...args);\r\n      if (typeof r === `object`) await r;\r\n      trigger = performance.now();\r\n    }\r\n  };\r\n};\r\n\r\nexport type IntervalAsync<V> = (() => V|Promise<V>) | Generator<V>;\r\n/**\r\n * Generates values from `produce` with `intervalMs` time delay. \r\n * `produce` can be a simple function that returns a value, an async function, or a generator.\r\n * \r\n * @example Produce a random number every 500ms:\r\n * ```\r\n * const randomGenerator = interval(() => Math.random(), 1000);\r\n * for await (const r of randomGenerator) {\r\n *  // Random value every 1 second\r\n *  // Warning: does not end by itself, a `break` statement is needed\r\n * }\r\n * ```\r\n *\r\n * @example Return values from a generator every 500ms:\r\n * ```js\r\n * // Make a generator that counts to 10\r\n * const counter = count(10);\r\n * for await (const v of interval(counter, 1000)) {\r\n *  // Do something with `v`\r\n * }\r\n * ```\r\n * @template V Returns value of `produce` function\r\n * @param intervalMs Interval between execution\r\n * @param produce Function to call\r\n * @template V Data type\r\n * @returns\r\n */\r\nexport const interval = async function*<V>(produce: IntervalAsync<V>, intervalMs: number) {\r\n  //eslint-disable-next-line functional/no-let\r\n  let cancelled = false;\r\n  //eslint-disable-next-line functional/no-try-statement\r\n  try {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (!cancelled) {\r\n      await sleep(intervalMs);\r\n      if (cancelled) return;\r\n      if (typeof produce === `function`) {\r\n        // Returns V or Promise<V>\r\n        const result = await produce();\r\n        yield result;\r\n      } else if (typeof produce === `object`) {\r\n        // Generator, perhaps?\r\n        if (`next` in produce && `return` in produce && `throw` in produce) {\r\n          const result = await produce.next();\r\n          if (result.done) return;\r\n          yield result.value; \r\n        } else {\r\n          throw new Error(`interval: produce param does not seem to be a generator?`);\r\n        }\r\n      } else {\r\n        throw new Error(`produce param does not seem to return a value/Promise and is not a generator?`);\r\n      }\r\n    }\r\n  } finally {\r\n    cancelled = true;\r\n  }\r\n};\r\n\r\nexport type TimeoutSyncCallback = (elapsedMs?:number, ...args:readonly unknown[]) => void\r\n\r\nexport type TimeoutAsyncCallback = (elapsedMs?:number, ...args:readonly unknown[]) => Promise<void>\r\n\r\n/**\r\n * Returns a {@link Timeout} that can be triggered, cancelled and reset\r\n *  \r\n * Once `start()` is called, `callback` will be scheduled to execute after `timeoutMs`.\r\n * If `start()` is called again, the waiting period will be reset to `timeoutMs`.\r\n * \r\n * @example Essential functionality\r\n * ```js\r\n * const fn = () => {\r\n *  console.log(`Executed`);\r\n * };\r\n * const t = timeout(fn, 60*1000); \r\n * t.start();   // After 1 minute `fn` will run, printing to the console\r\n * ```\r\n * \r\n * @example Control execution functionality\r\n * ```\r\n * t.cancel();  // Cancel it from running\r\n * t.start();   // Schedule again after 1 minute\r\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\r\n * t.isDone;    // True if a scheduled event is pending\r\n * ```\r\n * \r\n * Callback function receives any additional parameters passed in from start.\r\n * This can be useful for passing through event data:\r\n * \r\n * @example\r\n * ```js\r\n * const t = timeout( (elapsedMs, ...args) => {\r\n *  // args contains event data\r\n * }, 1000);\r\n * el.addEventListener(`click`, t.start);\r\n * ```\r\n * \r\n * Asynchronous callbacks can be used as well:\r\n * ```js\r\n * timeout(async () => {...}, 100);\r\n * ```\r\n * \r\n * @param callback \r\n * @param timeoutMs \r\n * @returns {@link Timeout}\r\n */\r\nexport const timeout = (callback:TimeoutSyncCallback|TimeoutAsyncCallback, timeoutMs:number):Timeout => {\r\n  if (callback === undefined) throw new Error(`callback parameter is undefined`);\r\n  guardInteger(timeoutMs, `aboveZero`, `timeoutMs`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let timer = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let startedAt = 0;\r\n  const start = async (altTimeoutMs:number = timeoutMs, args:unknown[]):Promise<void> => {\r\n    \r\n    const p = new Promise<void>((resolve, reject) => {\r\n      startedAt = performance.now();\r\n      //eslint-disable-next-line functional/no-try-statement\r\n      try {\r\n        guardInteger(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\r\n      } catch (e) {\r\n        reject(e);\r\n        return;\r\n      }\r\n      if (timer !== 0) cancel();\r\n      timer = window.setTimeout(async () => {\r\n        await callback(performance.now() - startedAt, ...args);\r\n        timer = 0;\r\n        resolve(undefined); \r\n      }, altTimeoutMs);\r\n    });\r\n    return p;\r\n  };\r\n\r\n  const cancel = () => {\r\n    if (timer === 0) return;\r\n    startedAt = 0;\r\n    window.clearTimeout(timer);\r\n  };\r\n\r\n  return {\r\n    start,\r\n    cancel,\r\n    get isDone() {\r\n      return timer !== 0;\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Runs a function continuously, returned by {@link Continuously}\r\n */\r\nexport type Continuously = HasCompletion & {\r\n  /**\r\n   * Starts loop. If already running, it is reset\r\n   */\r\n  start(): void\r\n  /**\r\n   * How many milliseconds since start() was last called\r\n   */\r\n  get elapsedMs(): number\r\n  /**\r\n   * How many iterations of the loop since start() was last called\r\n   */\r\n  get ticks(): number\r\n  /**\r\n   * Whether loop has finished\r\n   */\r\n  get isDone(): boolean\r\n  /**\r\n   * Stops loop\r\n   */\r\n  cancel(): void\r\n}\r\n\r\nexport type ContinuouslySyncCallback = (ticks?:number, elapsedMs?:number) => boolean|void\r\nexport type ContinuouslyAsyncCallback = (ticks?:number, elapsedMs?:number) => Promise<boolean|void>\r\n\r\n/**\r\n * Returns a {@link Continuously} that continuously executes `callback`. If callback returns _false_, loop exits.\r\n * \r\n * Call `start` to begin/reset loop. `cancel` stops loop.\r\n * \r\n * @example Animation loop\r\n * ```js\r\n * const draw = () => {\r\n *  // Draw on canvas\r\n * }\r\n * continuously(draw).start(); // Run draw as fast as possible using `window.requestAnimationFrame` \r\n * ```\r\n * \r\n * @example With delay\r\n * ```js\r\n * const fn = () => {\r\n *  console.log(`1 minute`);\r\n * }\r\n * const c = continuously(fn, 60*1000);\r\n * c.start(); // Runs `fn` every minute\r\n * ```\r\n * \r\n * ```js\r\n * c.cancel();\r\n * c.elapsedMs;  // How many milliseconds have elapsed since start\r\n * c.ticks;      // How many iterations of loop since start\r\n * ```\r\n * \r\n * Asynchronous callback functions are supported too:\r\n * ```js\r\n * continuously(async () => { ..});\r\n * ```\r\n * @param callback Function to run. If it returns false, loop exits.\r\n * @param resetCallback Callback when/if loop is reset. If it returns false, loop exits\r\n * @param intervalMs \r\n * @returns \r\n */\r\nexport const continuously = (callback:ContinuouslyAsyncCallback|ContinuouslySyncCallback, intervalMs?:number, resetCallback?:((ticks?:number, elapsedMs?:number) => boolean|void)):Continuously => {\r\n  if (intervalMs !== undefined) guardInteger(intervalMs, `positive`, `intervalMs`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let running = false;\r\n  //eslint-disable-next-line functional/no-let\r\n  let ticks = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let startedAt = performance.now();\r\n  const schedule = (intervalMs === undefined || intervalMs === 0) ? (cb:()=>void) => window.requestAnimationFrame(cb) : (cb:()=>void) => window.setTimeout(cb, intervalMs);\r\n  const cancel = () => {\r\n    if (!running) return;\r\n    running = false;\r\n    ticks = 0;\r\n  };\r\n\r\n  const loop = async () => {\r\n    if (!running) return;\r\n    const valOrPromise = callback(ticks++, performance.now() - startedAt);\r\n    //eslint-disable-next-line functional/no-let\r\n    let val;\r\n    if (typeof valOrPromise === `object`) {\r\n      val = await valOrPromise;\r\n    } else {\r\n      val = valOrPromise;\r\n    }\r\n    if (val !== undefined && !val) {\r\n      cancel();\r\n      return;\r\n    }\r\n\r\n    schedule(loop);\r\n  };\r\n\r\n  const start = () => {\r\n    // Already running, but theres a resetCallback to check if we should keep going\r\n    if (running && resetCallback !== undefined) {\r\n      const r = resetCallback(ticks, performance.now() - startedAt);\r\n      startedAt = performance.now();\r\n      if (r !== undefined && !r) {\r\n        // Reset callback tells us to stop\r\n        cancel();\r\n        return; // Skip starting again\r\n      } \r\n    } else if (running) {\r\n      return; // already running\r\n    }\r\n\r\n    // Start running\r\n    running = true;\r\n    schedule(loop);\r\n  };\r\n\r\n  return {\r\n    start,\r\n    get isDone() {\r\n      return running;\r\n    },\r\n    get ticks() {\r\n      return ticks;\r\n    },\r\n    get elapsedMs() {\r\n      return performance.now() - startedAt;\r\n    },\r\n    cancel\r\n  };\r\n};\r\n\r\n/**\r\n * Pauses execution for `timeoutMs`.\r\n * \r\n * @example\r\n * ```js\r\n * console.log(`Hello`);\r\n * await sleep(1000);\r\n * console.log(`There`); // Prints one second after\r\n * ```\r\n * @param timeoutMs\r\n * @return\r\n */\r\nexport const sleep = <V>(timeoutMs: number): Promise<V> => new Promise<V>(resolve => setTimeout(resolve, timeoutMs));\r\n\r\n/**\r\n * Pauses execution for `timeoutMs` after which the asynchronous `callback` is executed and awaited.\r\n * \r\n * @example\r\n * ```js\r\n * const result = await delay(async () => Math.random(), 1000);\r\n * console.log(result); // Prints out result after one second\r\n * ```\r\n * @template V\r\n * @param callback\r\n * @param timeoutMs\r\n * @return\r\n */\r\nexport const delay = async <V>(callback:() => Promise<V>, timeoutMs: number): Promise<V> =>  {\r\n  guardInteger(timeoutMs, `aboveZero`, `timeoutMs`);\r\n  await sleep(timeoutMs);\r\n  return Promise.resolve(await callback());\r\n};\r\n\r\n\r\n/**\r\n * Wraps a timer, returning a relative elapsed value.\r\n * \r\n * ```js\r\n * let t = relativeTimer(1000, msElapsedTimer());\r\n * ```\r\n * \r\n * @private\r\n * @param total \r\n * @param timer \r\n * @param clampValue If true, returned value never exceeds 1.0 \r\n * @returns \r\n */\r\nexport const relativeTimer = (total:number, timer: Timer, clampValue = true):ModTimer & HasCompletion => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let done = false;\r\n  //eslint-disable-next-line functional/no-let\r\n  let modAmt = 1;\r\n\r\n  return {\r\n    mod(amt:number) {\r\n      modAmt = amt;\r\n    },\r\n    get isDone() {\r\n      return done;\r\n    },\r\n    reset:() => {\r\n      done = false;\r\n      timer.reset();\r\n    },\r\n    get elapsed() {\r\n      //eslint-disable-next-line functional/no-let\r\n      let v = timer.elapsed / (total * modAmt);\r\n      if (clampValue) v = clamp(v);\r\n      if (v >= 1) done = true;\r\n      return v;\r\n    }\r\n  };\r\n};\r\n\r\n\r\nexport const frequencyTimerSource = (frequency:number):TimerSource => () => frequencyTimer(frequency, msElapsedTimer());\r\n  \r\nexport const frequencyTimer = (frequency:number, timer:Timer = msElapsedTimer()):ModTimer => {\r\n  const cyclesPerSecond = frequency/1000;\r\n  //eslint-disable-next-line functional/no-let\r\n  let modAmt = 1;\r\n  return {\r\n    mod:(amt:number) => {\r\n      modAmt = amt;\r\n    },\r\n    reset:() => {\r\n      timer.reset();\r\n    },\r\n    get elapsed() {\r\n      // Get position in a cycle\r\n      const v = timer.elapsed * (cyclesPerSecond * modAmt);\r\n\r\n      // Get fractional part\r\n      const f = v - Math.floor(v);\r\n      if (f < 0) throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v} f: ${f}`);\r\n      if (f > 1) throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v} f: ${f}`);\r\n      return f;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * A timer that uses clock time\r\n * @private\r\n * @returns {Timer}\r\n */\r\nexport const msElapsedTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    get elapsed() {\r\n      return performance.now() - start;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * A timer that progresses with each call\r\n * @private\r\n * @returns {Timer}\r\n */\r\nexport const ticksElapsedTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    get elapsed() { return start++; }\r\n  };\r\n};\r\n\r\nexport type UpdateFailPolicy = `fast` | `slow` | `backoff`; \r\n/**\r\n * Calls the async `fn` to generate a value if there is no prior value or\r\n * `intervalMs` has elapsed since value was last generated.\r\n * @example\r\n * ```js\r\n * const f = updateOutdated(async () => {\r\n *  const r = await fetch(`blah`);\r\n *  return await r.json();\r\n * }, 60*1000);\r\n * \r\n * // Result will be JSON from fetch. If fetch happened already in the\r\n * // last 60s, return cached result. Otherwise it will fetch data\r\n * const result = await f();\r\n * ```\r\n * \r\n * Callback `fn` is passed how many milliseconds have elapsed since last update. It's\r\n * minimum value will be `intervalMs`.\r\n * \r\n * ```js\r\n * const f = updateOutdated(async elapsedMs => {\r\n *  // Do something with elapsedMs?\r\n * }, 60*1000;\r\n * ```\r\n * \r\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\r\n * * `fast`: Invocation will happen immediately on next attempt\r\n * * `slow`: Next invocation will wait `intervalMs` as if it was successful\r\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\r\n * \r\n * @param fn Async function to call. Must return a value.\r\n * @param intervalMs Maximum age of cached result\r\n * @param updateFail `slow` by default\r\n * @returns Value\r\n */\r\nexport const updateOutdated = <V>(fn:(elapsedMs?:number)=>Promise<V>, intervalMs:number, updateFail:UpdateFailPolicy = `slow`):()=>Promise<V> => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let lastRun = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let lastValue:V|undefined;\r\n  //eslint-disable-next-line functional/no-let\r\n  let intervalMsCurrent = intervalMs;\r\n\r\n  return () => (new Promise(async (resolve, reject) => {\r\n    const elapsed = performance.now() - lastRun;\r\n    if (lastValue === undefined || elapsed > intervalMsCurrent) {\r\n      //eslint-disable-next-line functional/no-try-statement\r\n      try {\r\n        lastRun = performance.now();\r\n        lastValue = await fn(elapsed);\r\n        intervalMsCurrent = intervalMs;\r\n      } catch (ex) {\r\n        if (updateFail === `fast`) {\r\n          lastValue = undefined;\r\n          lastRun = 0;\r\n        } else if (updateFail === `backoff`) {\r\n          intervalMsCurrent = Math.floor(intervalMsCurrent*1.2);\r\n        }\r\n        reject(ex);\r\n        return;\r\n      }\r\n    } \r\n    resolve(lastValue);\r\n  }));\r\n};\r\n\r\n// const counterG = count(5);\r\n// const inter = interval(counterG, 1000);\r\n// let loops = 0;\r\n// for await (const r of inter) {\r\n//   console.log(r);\r\n//   loops++;\r\n//   if (loops === 5) break;\r\n// }"],"mappings":"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","names":[]}