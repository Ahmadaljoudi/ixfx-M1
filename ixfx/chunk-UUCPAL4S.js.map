{"version":3,"sources":["../src/util.ts"],"sourcesContent":["\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * Usage:\r\n *  clamp(0.5);         // 0.5 - just fine, within default of 0 to 1\r\n *  clamp(1.5);         // 1 - above default max of 1\r\n *  clamp(-50, 0, 100); // 0 - below range\r\n *  clamp(50, 0, 50);   // 50 - within range\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * @param {number} v Value to clamp\r\n * @param {number} [min=0] Minimum value (inclusive)\r\n * @param {number} [max=1] Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Returns a bezier interpolated value, using the given ranges\r\n * @param {number} value  Value to be interpolated\r\n * @param {number} s1 Source range start\r\n * @param {number} s2  Source range end\r\n * @param {number} t1  Target range start\r\n * @param {number} t2  Target range end\r\n * @param {number} [slope]  Weight of the curve (0.5 = linear, 0.1 = weighted near target start, 0.9 = weighted near target end)\r\n * @returns {number} Interpolated value\r\n */\r\n//      var interpolate = function (value, s1, s2, t1, t2, slope) {\r\n// //https://stackoverflow.com/questions/25752572/non-linear-interpolation-of-a-range-to-another-range\r\n\r\n//       //Default to linear interpolation\r\n//       slope = slope || 0.5;\r\n  \r\n//       //If the value is out of the source range, floor to min/max target values\r\n//       if(value < Math.min(s1, s2)) {\r\n//           return Math.min(s1, s2) === s1 ? t1 : t2;\r\n//       }\r\n  \r\n//       if(value > Math.max(s1, s2)) {\r\n//           return Math.max(s1, s2) === s1 ? t1 : t2;\r\n//       }\r\n  \r\n//       //Reverse the value, to make it correspond to the target range (this is a side-effect of the bezier calculation)\r\n//       value = s2-value;\r\n  \r\n//       var C1 = {x: s1, y:t1}; //Start of bezier curve\r\n//       var C3 = {x: s2, y:t2}; //End of bezier curve\r\n//       var C2 = {              //Control point\r\n//           x: C3.x,\r\n//           y: C1.y + Math.abs(slope) * (C3.y - C1.y)\r\n//       };\r\n  \r\n//       //Find out how far the value is on the curve\r\n//       var percent = value / (C3.x-C1.x);\r\n  \r\n//       return C1.y*b1(percent) + C2.y*b2(percent) + C3.y*b3(percent);\r\n  \r\n//       function b1(t) { return t*t }\r\n//       function b2(t) { return 2*t*(1 - t)  }\r\n//       function b3(t) { return (1 - t)*(1 - t) }\r\n//   };\r\n\r\nexport const map = (\r\n  v:number, \r\n  inMin:number, inMax:number, \r\n  outMin:number, outMax:number\r\n) => (v - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and length (exclusive)\r\n * This is useful for clamping an array range, because the largest allowed number will\r\n * be one less than length\r\n * \r\n * ```js\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampZeroBounds(0, myArray.length); // 0\r\n * clampZeroBounds(1.2, myArray.length); // 1\r\n * clampZeroBounds(4, myArray.length); // 4\r\n * clampZeroBounds(5, myArray.length); // 4\r\n * clampZeroBounds(-1, myArray.length); // 0 \r\n * ```\r\n * @param {number} v Integer value to clamp\r\n * @param {number} length Length of bounds\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\nexport const clampZeroBounds = (v: number, length: number) => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\nexport const lerp =(amt:number, a:number, b:number) => (1-amt) * a + amt * b;\r\n\r\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\r\nexport type IsEqual<V> = (a:V, b:V) => boolean;\r\n\r\n/**\r\n * Default comparer function is equiv to checking `a === b`\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqualDefault = <V>(a:V, b:V):boolean => a === b;\r\n\r\n/**\r\n * Comparer returns true if string representation of `a` and `b` are equal.\r\n * Uses `toStringDefault` to generate a string representation (`JSON.stringify`)\r\n *\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean} True if the contents of `a` and `b` are equal\r\n */\r\nexport const isEqualValueDefault = <V>(a:V, b:V):boolean => {\r\n  // ✔ UNIT TESTED\r\n  if (a === b) return true; // Object references are the same, or string values are the same\r\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\r\n};\r\n\r\n/**\r\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} itemToMakeStringFor\r\n * @returns {string}\r\n */\r\nexport const toStringDefault = <V>(itemToMakeStringFor:V):string => ((typeof itemToMakeStringFor === `string`) ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor));\r\n\r\n"],"mappings":";AAiBO,IAAM,QAAQ,CAAC,GAAW,MAAM,GAAG,MAAM,MAAM;AAEpD,MAAI,OAAO,MAAM;AAAI,UAAM,IAAI,MAAM;AACrC,MAAI,OAAO,MAAM;AAAM,UAAM,IAAI,MAAM;AACvC,MAAI,OAAO,MAAM;AAAM,UAAM,IAAI,MAAM;AAEvC,MAAI,IAAI;AAAK,WAAO;AACpB,MAAI,IAAI;AAAK,WAAO;AACpB,SAAO;AAAA;AAgDF,IAAM,MAAM,CACjB,GACA,OAAc,OACd,QAAe,WACX,KAAI,SAAU,UAAS,UAAW,SAAQ,SAAS;AAmBlD,IAAM,kBAAkB,CAAC,GAAW,WAAmB;AAE5D,MAAI,CAAC,OAAO,UAAU;AAAI,UAAM,IAAI,MAAM,mCAAmC;AAC7E,MAAI,CAAC,OAAO,UAAU;AAAS,UAAM,IAAI,MAAM,wCAAwC,WAAW,OAAO;AACzG,MAAI,KAAK,MAAM;AACf,MAAI,IAAI;AAAG,WAAO;AAClB,MAAI,KAAK;AAAQ,WAAO,SAAS;AACjC,SAAO;AAAA;AAGF,IAAM,OAAM,CAAC,KAAY,GAAU,MAAc,KAAE,OAAO,IAAI,MAAM;AAapE,IAAM,iBAAiB,CAAI,GAAK,MAAgB,MAAM;AAWtD,IAAM,sBAAsB,CAAI,GAAK,MAAgB;AAE1D,MAAI,MAAM;AAAG,WAAO;AACpB,SAAO,gBAAgB,OAAO,gBAAgB;AAAA;AAUzC,IAAM,kBAAkB,CAAI,wBAAmC,OAAO,wBAAwB,WAAY,sBAAsB,KAAK,UAAU;","names":[]}