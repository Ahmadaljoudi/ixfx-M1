{"version":3,"sources":["../src/Generators.ts","../src/modulation/PingPong.ts","../src/IterableSync.ts"],"sourcesContent":["import {number as guardNumber, integer as guardInteger} from \"./Guards.js\";\nexport {pingPong, pingPongPercent} from './modulation/PingPong.js';\nexport * as Async from './IterableAsync.js';\nexport * as Sync from './IterableSync.js';\n\nexport {interval} from './flow/Interval.js';\nexport {delayLoop} from './flow/Delay.js';\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n * \n * Unlike {@link numericRange}, numbers might contain rounding errors\n * \n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n * \n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n * \n * let percentResult = percent.next().value;\n * ```\n * \n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n * \n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\n  guardNumber(interval,  `nonZero`);\n  \n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\n    if (!negativeInterval && start > end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    //eslint-disable-next-line functional/no-let\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n\n  } while (repeating);\n};\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n * \n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => console.log(`Hi`));\n * ```\n * \n * If you want to accumulate return values, consider using\n * {@link Flow.repeat}.\n * @param amount Number of integers to yield \n * @param offset Added to result\n */\nexport const count = function* (amount:number, offset:number = 0) {\n  // Unit tested.\n  guardInteger(amount, ``, `amount`);\n  guardInteger(offset, ``, `offset`);\n\n  if (amount === 0) return;\n  \n  //eslint-disable-next-line functional/no-let\n  let i = 0;\n  do {\n    if (amount < 0) yield -i + offset;\n    else yield i + offset;\n  } while (i++ < Math.abs(amount) - 1);\n};\n\n/**\n * Returns a number range between 0.0-1.0. \n * \n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n * \n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n * \n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns \n */\nexport const numericPercent = function (interval:number = 0.01, repeating:boolean = false, start:number = 0, end = 1) {\n  guardNumber(interval, `percentage`, `interval`);\n  guardNumber(start, `percentage`, `start`);\n  guardNumber(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};","import {number as guardNumber} from \"../Guards.js\";\n\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n * \n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n * \n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * \n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (interval: number = 0.1, lower?: number, upper?: number, start?: number, rounding?: number) {\n  if (lower === undefined) lower = 0;\n  if (upper === undefined) upper = 1;\n  if (start === undefined) start = lower;\n\n  guardNumber(interval, `bipolar`, `interval`);\n  guardNumber(upper, `bipolar`, `end`);\n  guardNumber(start, `bipolar`, `offset`);\n  guardNumber(lower, `bipolar`, `start`);\n  return pingPong(interval, lower, upper, start, rounding);\n};\n\n/**\n * Ping-pongs continually back and forth `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n * \n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (interval: number, lower: number, upper: number, start?: number, rounding?: number) {\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\n  if (interval === undefined) throw new Error(`Parameter 'interval' is undefined`);\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\n\n  if (rounding === undefined && (interval <=1 && interval >= 0)) rounding = 10 / interval;\n  else if (rounding === undefined) rounding = 1234;\n\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\n\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\n  const distance = upper - lower;\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\n\n  //eslint-disable-next-line functional/no-let\n  let incrementing = interval > 0;\n\n  // Scale up values by rounding factor\n  upper = Math.floor(upper * rounding);\n  lower = Math.floor(lower * rounding);\n  interval = Math.floor(Math.abs(interval * rounding));\n\n  if (interval === 0) throw new Error(`Interval is zero (rounding: ${rounding})`);\n  if (start === undefined) start = lower;\n  else start = Math.floor(start * rounding);\n  if (start > upper || start < lower) throw new Error(`Start (${start/rounding}) must be within lower (${lower/rounding}) and upper (${upper/rounding})`);\n\n  //eslint-disable-next-line functional/no-let\n  let v = start;\n  yield v / rounding;\n  //eslint-disable-next-line functional/no-let\n  let firstLoop = true;\n  while (true) {\n    //console.log(`v: ${v} incrementing: ${incrementing} interval: ${interval}`);\n    v = v + (incrementing ? interval : -interval);\n    if (incrementing && v >= upper) {\n      incrementing = false;\n      v = upper;\n      if (v === upper && firstLoop) {\n        // Edge case where we start at upper bound and increment\n        v = lower; incrementing = true;\n      }\n    } else if (!incrementing && v <= lower) {\n      incrementing = true;\n      v = lower;\n      if (v === lower && firstLoop) {\n        // Edge case where we start at lower bound and decrement\n        v = upper; incrementing = false;\n      }\n    }\n    yield v / rounding;\n    firstLoop = false;\n  }\n};\n","/**\n * Return `it` broken up into chunks of `size`\n * \n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it \n * @param size \n * @returns \n */\n\nimport { IsEqual } from \"./Util\";\n\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n * \n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n * \n * \n * @param it \n * @param size \n * @returns \n */\nexport function* chunksOverlapping<V>(it:Iterable<V>, size:number) {\n  if (size <= 1) throw new Error(`Size should be at least 2`);\n\n  //eslint-disable-next-line functional/no-let\n  let buffer:V[] = [];\n  \n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      buffer = [buffer.at(-1)!];\n    }\n  }\n  if (buffer.length <= 1) return;\n\n  if (buffer.length > 0) yield buffer;\n}\n\n/**\n * Breaks an iterable into array chunks\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it \n * @param size \n */\n//eslint-disable-next-line func-style\nexport function* chunks<V>(it:Iterable<V>, size:number) {\n  //eslint-disable-next-line functional/no-let\n  let buffer = [];\n  \n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n/**\n * Return concatenation of iterators\n * @param its \n */\n//eslint-disable-next-line func-style\nexport function* concat<V>(...its:readonly Iterable<V>[]) {\n  \n  for (const it of its) yield* it;\n}\n\n/**\n * Drops elements that do not meet the predicate `f`.\n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport function* dropWhile<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  \n  for (const v of it) { \n    if (!f(v)) {\n      yield v;\n      break;\n    }\n  }\n  yield* it;\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1 \n * @param it2 \n * @param equality \n * @returns \n */\n//eslint-disable-next-line func-style\nexport function equals<V>(it1:IterableIterator<V>, it2:IterableIterator<V>, equality?:IsEqual<V>) {\n  //it1 = it1[Symbol.iterator]();\n  //it2 = it2[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const i1 = it1.next(), i2 = it2.next();\n    if (equality !== undefined) {\n      if (!equality(i1.value, i2.value)) return false;\n    } else if (i1.value !== i2.value) return false;\n    if (i1.done || i2.done) return i1.done && i2.done;\n  }\n}\n\n/**\n * Returns true if `f` returns true for \n * every item in iterable\n * @param it \n * @param f \n * @returns \n */\n//eslint-disable-next-line func-style\nexport function every<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  let ok = true;\n  \n  for (const v of it) ok = ok && f(v);\n  return ok;\n}\n\n/**\n * Yields `v` for each item within `it`.\n * \n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n * @param it \n * @param v \n */\n//eslint-disable-next-line func-style\nexport function* fill<V>(it:Iterable<V>, v:V) {\n  // https://surma.github.io/underdash/\n  \n  for (const _ of it) yield v;\n}\n\n/**\n * Execute function `f` for each item in iterable\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport function forEach<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) f(v);\n}\n\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport function* filter<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n * @param it \n * @param f \n * @returns \n */\n//eslint-disable-next-line func-style\nexport  function find<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) { \n    if (f(v)) return v;\n  } \n}\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it \n */\n//eslint-disable-next-line func-style\nexport function* flatten<V>(it:Iterable<V>) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) {\n    if (Symbol.iterator in v) { \n      // @ts-ignore\n      yield* v;\n    } else {\n      yield v;\n    }\n  }\n}\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport function* map<V, X>(it:Iterable<V>, f:(v:V)=>X) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) { \n    yield f(v);\n  }\n}\n\n/**\n * Returns the maximum seen of an iterable\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:1, v:-9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function max<V>(it:Iterable<V>, gt = (a:V, b:V) => a > b) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  let max;\n  \n  for (const v of it) {\n    if(!max) {\n      max = v;\n      continue;\n    }\n    max = gt(max, v)?max:v;\n  }\n  return max;\n}\n\n/**\n * Returns the minimum seen of an iterable\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function min<V>(it:Iterable<V>, gt = (a:V, b:V) => a > b) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  let min;\n  \n  for (const v of it) {\n    if(!min) {\n      min = v;\n      continue;\n    }\n    min = gt(min, v)?v:min;\n  }\n  return min;\n}\n\n/**\n * Returns count from `start` for a given length\n * ```js\n * range(-5, 10);\n * // Yields: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n * ```\n * @param start \n * @param len \n */\n//eslint-disable-next-line func-style\nexport function* range(start:number, len:number) {\n  // https://surma.github.io/underdash/\n  //eslint-disable-next-line functional/no-let\n  for (let i=0;i<len;i++) {\n    yield start++;\n  }\n  //for (let i=len;len > 0; len--) yield start++;\n}\n\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function reduce<V>(it:Iterable<V>, f:(acc:V, current:V)=>V, start:V) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Returns a section from an iterable\n * @param it Iterable\n * @param start Start index\n * @param end End index (or until completion)\n */\n//eslint-disable-next-line func-style\nexport function* slice<V>(it:Iterable<V>, start = 0, end = Number.POSITIVE_INFINITY) {\n  // https://surma.github.io/underdash/\n  const iit = it[Symbol.iterator]();\n  \n  for(; start > 0; start--, end--) iit.next();\n  \n  for (const v of it) { \n    if (end-- > 0) { \n      yield v;\n    } else { \n      break; \n    } \n  }\n}\n\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly \n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function some<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) { \n    if (f(v)) return true;\n  }\n  return false;\n}\n\n/**\n * Returns items for which the filter function returns _true_\n * ```js\n * takeWhile([ 1, 2, 3, 4 ], e => e < 3);\n * // Yields: [ 1, 2 ]\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function* takeWhile<V>(it:Iterable<V>, f:(v:V)=>boolean) {\n  // https://surma.github.io/underdash/\n  \n  for (const v of it) {\n    if (!f(v)) return;\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from several iterables\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields: returns [{i:0,v:2},{i:1,v:3}]\n *\n * @param it \n * @param f \n */\n//eslint-disable-next-line func-style\nexport function* unique<V>(it:Iterable<V>, f:((id:V)=>V) = id => id) {\n  // https://surma.github.io/underdash/\n  const buffer = [];\n  \n  for (const v of it) {\n    const fv = f(v);\n    if (buffer.indexOf(fv) !== -1) continue;\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(fv);\n    yield v;\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its \n * @returns \n */\n//eslint-disable-next-line func-style\nexport function* zip<V>(...its:readonly Iterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map(it => it[Symbol.iterator]());\n\n  \n  while(true) {\n    const vs = iits.map(it => it.next());\n    if (vs.some(v => v.done)) return;\n    yield vs.map(v => v.value);\n  }\n}"],"mappings":"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","names":["interval","max","min","interval"]}