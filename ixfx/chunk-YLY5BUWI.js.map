{"version":3,"sources":["../src/modulation/index.ts","../src/modulation/Easing.ts","../src/modulation/Envelope.ts"],"sourcesContent":["// import * as Easing from './Easing.js';\r\n// import * as Envelope from './Envelope.js';\r\n// export {Easing, Envelope};\r\nexport * from './Easing.js';\r\nexport * from './Envelope.js';\r\n","// Easings from https://easings.net/\r\nimport {msElapsedTimer, HasCompletion, relativeTimer, ticksElapsedTimer, TimerSource} from '~/Timer.js';\r\n\r\nconst sqrt = Math.sqrt;\r\nconst pow = Math.pow;\r\nconst cos = Math.cos;\r\n//eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst pi = Math.PI;\r\nconst sin = Math.sin;\r\n/*\r\ntype RelativeTimer = {\r\n  reset(): void\r\n  elapsed(): number\r\n  isDone(): boolean\r\n}\r\n\r\ntype TimerSource = (upperBound: number) => RelativeTimer;\r\n\r\nconst msRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    elapsed: () => clamp((performance.now() - start) / upperBound),\r\n    isDone: () => (performance.now() - start) >= upperBound,\r\n  };\r\n};\r\n\r\nconst tickRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => clamp(start++ / upperBound),\r\n    isDone: () => start >= upperBound,\r\n  };\r\n};\r\n*/\r\n\r\ntype EasingFn = (x: number) => number;\r\n\r\n/**\r\n * Creates an easing based on clock time\r\n * @inheritdoc Easing\r\n * @example Time based easing\r\n * ```\r\n * const t = timer(`easeIn`, 5*1000); // Will take 5 seconds to complete\r\n * ...\r\n * t.compute(); // Get current value of easing\r\n * t.reset();   // Reset to 0\r\n * t.isDone;    // _True_ if finished\r\n * ```\r\n * @param name Name of easing\r\n * @param durationMs Duration in milliseconds\r\n * @returns Easing\r\n */\r\nexport const easeOverTime = function (name: EasingName, durationMs: number):Easing {\r\n  return create(name, durationMs, msElapsedTimer);\r\n};\r\n\r\n/**\r\n * Creates an easing based on ticks\r\n * \r\n * @inheritdoc Easing\r\n * @example Tick-based easing\r\n * ```\r\n * const t = tick(`easeOut`, 1000);   // Will take 1000 ticks to complete\r\n * t.compute(); // Each call to `compute` progresses the tick count\r\n * t.reset();   // Reset to 0\r\n * t.isDone;    // _True_ if finished\r\n * ```\r\n * @param name Name of easing\r\n * @param durationTicks Duration in ticks\r\n * @returns Easing\r\n */\r\nexport const easeOverTicks = function (name: EasingName, durationTicks: number):Easing {\r\n  return create(name, durationTicks, ticksElapsedTimer);\r\n};\r\n\r\n/**\r\n * 'Ease' from `0` to `1` over a delicious curve. Used commonly for animation\r\n * and basic modelling of phyical motion. \r\n * \r\n * Create via {@link easeOverTicks} or {@link easeOverTime}, call `compute` to calculate the next\r\n * value in the progression, until you reach `1` or `isDone` returns true.\r\n * \r\n * For [demos of functions](https://easings.net/)\r\n * \r\n */\r\nexport type Easing = HasCompletion & {\r\n/**\r\n * Computes the current value of the easing\r\n *\r\n * @returns {number}\r\n */\r\n  compute(): number\r\n\r\n/**\r\n * Reset the easing\r\n */\r\n  reset(): void\r\n/**\r\n * Returns true if the easing is complete\r\n *\r\n * @returns {boolean}\r\n */\r\n  get isDone(): boolean\r\n};\r\n\r\n/**\r\n * Creates a new easing by name\r\n *\r\n * @param name Name of easing\r\n * @param duration Duration (meaning depends on timer source)\r\n * @param timerSource Timer source. Eg {@link tickRelativeTimer}, {@link msRelativeTimer}\r\n * @returns\r\n */\r\nconst create = function (name: EasingName, duration: number, timerSource: TimerSource): Easing {\r\n  const fn = resolveEasing(name);\r\n\r\n  // Get a relative version of timer\r\n  const timer = relativeTimer(duration, timerSource(), true);\r\n\r\n  return {\r\n    get isDone() {\r\n      return timer.isDone;\r\n    },\r\n    compute: () => {\r\n      const relative = timer.elapsed;\r\n      return fn(relative);\r\n    },\r\n    reset: () => {\r\n      timer.reset();\r\n    }\r\n  };\r\n};\r\n\r\nexport type EasingName = keyof typeof easings;\r\n\r\nconst resolveEasing = function (name: string): EasingFn {\r\n  name = name.toLocaleLowerCase();\r\n  const found = Object\r\n    .entries(easings)\r\n    .find(([k, _v]) => k.toLocaleLowerCase() === name);\r\n\r\n  if (found === undefined) throw new Error(`Easing '${name}' not found.`);\r\n  return found[1];\r\n};\r\n\r\n/**\r\n * @private\r\n * @returns Returns list of available easing names\r\n */\r\nexport const getEasings = function ():readonly string[] {\r\n  return Array.from(Object.keys(easings));\r\n};\r\n\r\nconst easeOutBounce = function (x:number): number {\r\n  const n1 = 7.5625;\r\n  const d1 = 2.75;\r\n\r\n  if (x < 1 / d1) {\r\n    return n1 * x * x;\r\n  } else if (x < 2 / d1) {\r\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\r\n  } else if (x < 2.5 / d1) {\r\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\r\n  } else {\r\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\r\n  }\r\n};\r\n\r\nconst easings = {\r\n  easeInSine: (x: number): number => 1 - cos((x * pi) / 2),\r\n  easeOutSine: (x: number): number => sin((x * pi) / 2),\r\n  easeInQuad: (x: number): number => x * x,\r\n  easeOutQuad: (x: number): number => 1 - (1 - x) * (1 - x),\r\n  easeInOutSine: (x: number): number => -(cos(pi * x) - 1) / 2,\r\n  easeInOutQuad: (x: number): number => (x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2),\r\n  easeInCubic: (x: number): number => x * x * x,\r\n  easeOutCubic: (x: number): number => 1 - pow(1 - x, 3),\r\n  easeInQuart: (x: number): number => x * x * x * x,\r\n  easeOutQuart: (x: number): number => 1 - pow(1 - x, 4),\r\n  easeInQuint: (x: number): number => x * x * x * x * x,\r\n  easeOutQuint: (x: number): number => 1 - pow(1 - x, 5),\r\n  easeInExpo: (x: number): number => (x === 0 ? 0 : pow(2, 10 * x - 10)),\r\n  easeOutExpo: (x: number): number => (x === 1 ? 1 : 1 - pow(2, -10 * x)),\r\n  easeInOutQuint: (x: number): number => (x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2),\r\n  easeInOutExpo: (x: number): number => (x === 0\r\n    ? 0\r\n    : x === 1\r\n      ? 1\r\n      : x < 0.5 ? pow(2, 20 * x - 10) / 2\r\n        : (2 - pow(2, -20 * x + 10)) / 2),\r\n  easeInCirc: (x: number): number => 1 - sqrt(1 - pow(x, 2)),\r\n  easeOutCirc: (x: number): number => sqrt(1 - pow(x - 1, 2)),\r\n  easeInBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return c3 * x * x * x - c1 * x * x;\r\n  },\r\n  easeOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\r\n  },\r\n  easeInOutCirc: (x: number): number => (x < 0.5\r\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\r\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2),\r\n  easeInOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c2 = c1 * 1.525;\r\n\r\n    return x < 0.5\r\n      ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\r\n      : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\r\n  },\r\n  easeInElastic: (x: number): number => {\r\n    const c4 = (2 * pi) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);\r\n  },\r\n  easeOutElastic: (x: number): number => {\r\n    const c4 = (2 * pi) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;\r\n  },\r\n  easeInBounce: (x: number): number => 1 - easeOutBounce(1 - x),\r\n  easeOutBounce: easeOutBounce,\r\n  easeInOutElastic: (x: number): number => {\r\n    const c5 = (2 * pi) / 4.5;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : x < 0.5\r\n          ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\r\n          : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\r\n  },\r\n  easeInOutBounce: (x: number): number => (x < 0.5\r\n    ? (1 - easeOutBounce(1 - 2 * x)) / 2\r\n    : (1 + easeOutBounce(2 * x - 1)) / 2)\r\n};","import {SimpleEventEmitter} from \"../Events.js\";\r\nimport { msElapsedTimer, TimerSource} from \"../Timer.js\";\r\nimport { Timer } from \"../Timer.js\";\r\nimport { StateMachine } from \"../StateMachine.js\";\r\nimport {Path} from \"~/geometry/Path.js\";\r\nimport * as Bezier from '../geometry/Bezier.js';\r\nimport {scale} from \"../util.js\";\r\n\r\n/**\r\n * @returns Returns a full set of default ADSR options\r\n */\r\nexport const defaultAdsrOpts = ():EnvelopeOpts => ({\r\n  attackBend: -1,\r\n  decayBend: -.3,\r\n  releaseBend: -.3,\r\n  peakLevel: 1,\r\n  initialLevel: 0,\r\n  sustainLevel: 0.6,\r\n  releaseLevel: 0,\r\n  attackDuration: 600,\r\n  decayDuration: 200,\r\n  releaseDuration: 800,\r\n  shouldLoop: false\r\n});\r\n\r\nexport type EnvelopeOpts = AdsrOpts & AdsrTimingOpts;\r\n/**\r\n * Options for the ADSR envelope. \r\n * \r\n * Use {@link defaultAdsrOpts} to get an initial default:\r\n * @example\r\n * ```js\r\n * let env = adsr({\r\n *  ...defaultAdsrOpts(),\r\n *  attackDuration: 2000,\r\n *  releaseDuration: 5000,\r\n *  sustainLevel: 1,\r\n *  retrigger: false\r\n * });\r\n * ```\r\n */\r\nexport type AdsrOpts = {\r\n  /**\r\n   * Attack bezier 'bend'. Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly attackBend: number\r\n  /**\r\n   * Decay bezier 'bend'. Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly decayBend: number\r\n  /**\r\n   * Release bezier 'bend'. Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly releaseBend: number\r\n\r\n   /**\r\n    * Peak level (maximum of attack stage)\r\n    */\r\n   readonly peakLevel:number\r\n\r\n  /**\r\n   * Starting level (usually 0)\r\n   */\r\n   readonly initialLevel?:number\r\n/**\r\n * Sustain level. Only valid if trigger and hold happens\r\n */ \r\n   readonly sustainLevel:number\r\n/**\r\n * Release level, when envelope is done (usually 0)\r\n */\r\n   readonly releaseLevel?:number\r\n\r\n  /**\r\n   * When _false_, envelope starts from it's current level when being triggered.\r\n   * _True_ by default.\r\n   */\r\n  readonly retrigger?: boolean\r\n}\r\n\r\nexport type AdsrTimingOpts = {\r\n  /**\r\n   * If true, envelope indefinately returns to attack stage after release\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  readonly shouldLoop: boolean\r\n\r\n  /**\r\n   * Duration for attack stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly attackDuration: number\r\n  /**\r\n   * Duration for decay stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly decayDuration: number\r\n  /**\r\n   * Duration for release stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly releaseDuration: number\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface CompleteEvent { /* no-op */}\r\n\r\ntype Events = {\r\n  readonly change: StateChangeEvent\r\n  readonly complete: CompleteEvent\r\n};\r\n\r\nclass AdsrBase extends SimpleEventEmitter<Events> {\r\n  readonly #sm:StateMachine;\r\n  readonly #timeSource:TimerSource;\r\n  #timer:Timer|undefined;\r\n\r\n  #holding:boolean;\r\n  #holdingInitial:boolean;\r\n\r\n  attackDuration:number;\r\n  decayDuration:number;\r\n  releaseDuration:number;\r\n  decayDurationTotal:number;\r\n  shouldLoop:boolean;\r\n  constructor(opts:AdsrTimingOpts) {\r\n    super();\r\n    \r\n    this.attackDuration = opts.attackDuration ?? 300;\r\n    this.decayDuration = opts.decayDuration ?? 500;\r\n    this.releaseDuration = opts.releaseDuration ?? 1000;\r\n    this.shouldLoop = opts.shouldLoop ?? false;\r\n\r\n    const descr ={\r\n      attack: [`decay`, `release`],\r\n      decay: [`sustain`, `release`],\r\n      sustain: [`release`],\r\n      release: [`complete`],\r\n      complete: null\r\n    };\r\n    \r\n    this.#sm = new StateMachine(`attack`, descr);\r\n    this.#sm.addEventListener(`change`, (ev => {\r\n      // Reset timer on release\r\n      if (ev.newState === `release` && this.#holdingInitial) {\r\n        this.#timer?.reset();\r\n      }\r\n      super.fireEvent(`change`, ev);\r\n    }));\r\n    this.#sm.addEventListener(`stop`, (ev => {\r\n      super.fireEvent(`complete`, ev);\r\n    }));\r\n    \r\n    this.#timeSource = msElapsedTimer;\r\n    this.#holding = this.#holdingInitial = false;\r\n\r\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\r\n  }\r\n\r\n  protected switchState():boolean {\r\n    if (this.#timer === undefined) return false;\r\n    // eslint-disable-next-line functional/no-let\r\n    let elapsed = this.#timer.elapsed;\r\n    const wasHeld = this.#holdingInitial && !this.#holding;\r\n\r\n    // Change through states for as long as needed\r\n    // eslint-disable-next-line functional/no-let\r\n    let hasChanged = false;\r\n    // eslint-disable-next-line functional/no-loop-statement\r\n    do {\r\n      hasChanged = false;\r\n      switch (this.#sm.state) {\r\n      case `attack`:\r\n        // console.log(`switchState - attack ${wasHeld}`);\r\n\r\n        if (elapsed > this.attackDuration || wasHeld) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `decay`:\r\n        // console.log(`switchState - decay ${wasHeld}`);\r\n\r\n        if (elapsed > this.decayDurationTotal || wasHeld) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `sustain`:\r\n        // console.log(`switchState - sustain ${wasHeld}`);\r\n        if (!this.#holding || wasHeld) {\r\n          elapsed = 0;\r\n          this.#sm.next();\r\n          this.#timer?.reset();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `release`:\r\n        // console.log(`switchState - release`);\r\n        if (elapsed > this.releaseDuration) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `complete`:\r\n        if (this.shouldLoop) {\r\n          this.trigger(this.#holdingInitial);\r\n        }\r\n      }\r\n    } while (hasChanged);\r\n    return hasChanged;\r\n  }\r\n\r\n  /**\r\n   * Computes a stage progress from 0-1\r\n   * @param allowStateChange \r\n   * @returns \r\n   */\r\n  protected computeRaw(allowStateChange = true):[stage:string|undefined, amount:number, prevStage:string] {\r\n    if (this.#timer === undefined) return [undefined, 0, this.#sm.state];\r\n  \r\n    // Change state if necessary based on elapsed time\r\n    if (allowStateChange) this.switchState();\r\n    \r\n    const prevStage = this.#sm.state;\r\n\r\n    const elapsed = this.#timer.elapsed;\r\n    // eslint-disable-next-line functional/no-let\r\n    let relative = 0;\r\n    const state = this.#sm.state;\r\n    switch (state) {\r\n    case `attack`:\r\n      relative = elapsed / this.attackDuration;\r\n      break;\r\n    case `decay`:\r\n      relative = (elapsed - this.attackDuration) / this.decayDuration;\r\n      break;\r\n    case `sustain`:\r\n      relative = 1;\r\n      break;\r\n    case `release`:\r\n      relative = Math.min(elapsed / this.releaseDuration, 1);\r\n      break;\r\n    case `complete`:\r\n      return [undefined, 1, prevStage];\r\n    default:\r\n      throw new Error(`State machine in unknown state: ${state}`);\r\n    }\r\n    return [state, relative, prevStage];\r\n  }\r\n\r\n  get isDone():boolean {\r\n    return this.#sm.isDone;\r\n  }\r\n\r\n  onTrigger():void {\r\n    /* no op */\r\n  }\r\n\r\n  trigger(hold:boolean = false) {\r\n    this.onTrigger();\r\n\r\n    this.#sm.reset();\r\n    this.#timer = this.#timeSource();\r\n    this.#holding = hold;\r\n    this.#holdingInitial = hold;\r\n  }\r\n\r\n  compute(): void {\r\n    /* no-op */\r\n  }\r\n\r\n  release() {\r\n    if (this.isDone || !this.#holdingInitial) return; // Was never holding or done\r\n  \r\n    // Setting holding flag to false, computeRaw will change state\r\n    this.#holding = false;\r\n    this.compute();\r\n  }\r\n}\r\n\r\n/**\r\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\r\n * usually in response to an intial trigger.\r\n * \r\n * Created with the {@link adsr} function.\r\n * \r\n * @example Setup\r\n * ```js\r\n * const opts = {\r\n *  ...defaultAdsrOpts(),\r\n *  attackDuration: 1000,\r\n *  decayDuration: 200,\r\n *  sustainDuration: 100\r\n * }\r\n * const env = adsr(opts);\r\n * ```\r\n * \r\n * @example Using\r\n * ```js\r\n * env.trigger(); // Start envelop\r\n * ...\r\n * // Get current value of envelope\r\n * const [state, scaled, raw] = env.compute();\r\n * ```\r\n * \r\n * * `state` is string: `attack`, `decay`, `sustain`, `release`, `complete \r\n * * `scaled` is a value scaled according to stage _levels_\r\n * * `raw` is the progress from 0 to 1 within a stage\r\n * \r\n * ...normally you'd just want:\r\n * ```js\r\n * const value = env.compute()[1]; // Get scaled \r\n * ```\r\n * \r\n * @example Hold & release\r\n * ```js\r\n * env.trigger(true); // Pass in true to hold\r\n * ...envelope will stop at sustain stage...\r\n * env.relese();      // Release into decay\r\n * ```\r\n * \r\n * Check if it's done:\r\n * ```js\r\n * env.isDone; // True if envelope is completed\r\n * ```\r\n * \r\n * Envelope has events to track activity: `change` and `complete`:\r\n * \r\n * ```\r\n * env.addEventListener(`change`, ev => {\r\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\r\n * })\r\n * ```\r\n */\r\nexport interface Adsr extends SimpleEventEmitter<Events> {\r\n  /**\r\n   * Compute value of envelope at this point in time.\r\n   * \r\n   * Returns an array of [stage, scaled, raw]. Most likely you want the scaled value:\r\n   * ```\r\n   * const v = env.compute()[1];\r\n   * ```\r\n   * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  compute(allowStateChange?:boolean):readonly [stage:string|undefined, scaled:number, raw:number]\r\n /**\r\n  * Releases a held envelope. Has no effect if envelope was not held or is complete.\r\n  */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  release():void\r\n  /**\r\n   * Triggers envelope.\r\n   * \r\n   * If event is already trigged,\r\n   * it will be _retriggered_. If`opts.retriggered` is false (default)\r\n   * envelope starts again at `opts.initialValue`. Otherwise it starts at\r\n   * the current value.\r\n   * \r\n   * @param hold If _true_ envelope will hold at sustain stage\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  trigger(hold?:boolean):void\r\n  /** \r\n   * _True_ if envelope is completed\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get isDone():boolean;\r\n}\r\n\r\nclass AdsrImpl extends AdsrBase implements Adsr {\r\n  readonly attackPath:Path;\r\n  readonly decayPath:Path;\r\n  readonly releasePath:Path;\r\n\r\n  readonly initialLevel;\r\n  readonly peakLevel;\r\n  readonly releaseLevel;\r\n  readonly sustainLevel;\r\n\r\n  readonly attackBend;\r\n  readonly decayBend;\r\n  readonly releaseBend;\r\n\r\n  protected initialLevelOverride:number|undefined;\r\n  readonly retrigger:boolean;\r\n  private releasedAt:number|undefined;\r\n\r\n  constructor(opts:EnvelopeOpts) {\r\n    super(opts);\r\n    this.initialLevel = opts.initialLevel ?? 0;\r\n    this.peakLevel = opts.peakLevel ?? 1;\r\n    this.releaseLevel = opts.releaseLevel ?? 0;\r\n    this.sustainLevel = opts.sustainLevel ?? 0.75;\r\n    this.retrigger = opts.retrigger ?? true;\r\n    \r\n    this.attackBend = opts.attackBend ?? 0;\r\n    this.releaseBend = opts.releaseBend ?? 0;\r\n    this.decayBend = opts.decayBend ?? 0;\r\n    \r\n    const max = 1;\r\n    this.attackPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.initialLevel}, \r\n      {x: max, y: this.peakLevel}, \r\n      -this.attackBend\r\n    ));\r\n    this.decayPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.peakLevel}, \r\n      {x: max, y: this.sustainLevel}, \r\n      -this.decayBend\r\n    ));\r\n    this.releasePath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.sustainLevel},\r\n      {x: max, y: this.releaseLevel}, \r\n      -this.releaseBend\r\n    ));\r\n  }\r\n\r\n  onTrigger() {\r\n    this.initialLevelOverride = undefined;\r\n    if (!this.retrigger) {      \r\n      const [_stage, scaled, _raw] = this.compute();\r\n      if (!Number.isNaN(scaled) && scaled > 0) {\r\n        console.log(`Retrigger. Last value was: ${scaled}`);\r\n        this.initialLevelOverride = scaled;\r\n      }\r\n    }\r\n  }\r\n\r\n  compute(allowStateChange = true):[stage:string|undefined, scaled:number, raw:number] {\r\n    const [stage, amt] = super.computeRaw(allowStateChange);\r\n    if (stage === undefined) return [undefined, NaN, NaN];\r\n    // eslint-disable-next-line functional/no-let\r\n    let v;\r\n    switch (stage) {\r\n    case `attack`:\r\n      v = this.attackPath.compute(amt).y;\r\n      if (this.initialLevelOverride !== undefined) {\r\n        v = scale(v, 0, this.initialLevel, this.initialLevelOverride, this.initialLevel);\r\n      }\r\n      this.releasedAt = v;\r\n      break;\r\n    case `decay`:\r\n      //Bezier.computeQuadraticSimple(start, end, bend, amt);\r\n      v = this.decayPath.compute(amt).y;\r\n      this.releasedAt = v;\r\n      break;\r\n    case `sustain`:\r\n      v = this.sustainLevel;\r\n      this.releasedAt = v;\r\n      break;\r\n    case `release`:\r\n      v = this.releasePath.compute(amt).y;\r\n      // Bound release level to the amp level that we released at.\r\n      // ie. when release happens before a stage completes\r\n      if (this.releasedAt !== undefined) v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\r\n      break;\r\n    case `complete`:\r\n      v = this.releaseLevel;\r\n      this.releasedAt = undefined;\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown state: ${stage}`);\r\n    }\r\n    return [stage, v, amt];\r\n  }\r\n}\r\n\r\n/**\r\n * @inheritdoc Adsr\r\n * @param opts \r\n * @returns New {@link Adsr} Envelope\r\n */\r\nexport const adsr = (opts:EnvelopeOpts):Adsr => new AdsrImpl(opts);"],"mappings":"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","names":[]}