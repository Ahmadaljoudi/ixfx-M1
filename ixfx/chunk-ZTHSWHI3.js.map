{"version":3,"sources":["../src/geometry/index.ts","../src/geometry/Arc.ts","../src/geometry/Point.ts","../src/geometry/Line.ts","../src/geometry/Bezier.ts","../node_modules/bezier-js/src/utils.js","../node_modules/bezier-js/src/poly-bezier.js","../node_modules/bezier-js/src/bezier.js","../src/geometry/Circle.ts","../src/geometry/CompoundPath.ts","../src/geometry/Grid.ts","../src/geometry/Path.ts","../src/geometry/Rect.ts","../src/geometry/Ellipse.ts","../src/geometry/Polar.ts"],"sourcesContent":["import * as Arcs from './Arc.js';\r\nimport * as Beziers from './Bezier.js';\r\nimport * as Circles from './Circle.js';\r\nimport * as Compound from './CompoundPath.js';\r\nimport * as Grids from './Grid.js';\r\nimport * as Lines from './Line.js';\r\nimport * as Paths from './Path.js';\r\nimport * as Points from './Point.js';\r\nimport * as Rects from './Rect.js';\r\nimport * as Ellipses from './Ellipse.js';\r\n\r\nexport {Circles, Arcs, Lines, Rects, Points, Paths, Grids, Beziers, Compound, Ellipses};\r\n\r\nexport * as Polar from './Polar.js';\r\n\r\n/**\r\n * Convert angle in degrees to angle in radians.\r\n * @param angleInDegrees \r\n * @returns \r\n */\r\nexport const degreeToRadian = (angleInDegrees:number) => (angleInDegrees) * (Math.PI / 180.0);\r\n\r\n/**\r\n * Convert angle in radians to angle in degrees\r\n * @param angleInRadians\r\n * @returns \r\n */\r\nexport const radianToDegree = (angleInRadians:number) => angleInRadians * 180 / Math.PI;\r\n\r\nexport const radiansFromAxisX = (point:Points.Point):number => Math.atan2(point.x, point.y);\r\n","import {degreeToRadian, Polar} from './index.js';\r\nimport {guard as guardPoint, isPoint} from './Point.js';\r\nimport {Path} from './Path.js';\r\nimport {Lines, Points, Rects} from './index.js';\r\n\r\n/**\r\n * Returns true if parameter is an arc\r\n * @param p Arc or number\r\n * @returns \r\n */\r\nexport const isArc = (p: Arc|number|unknown): p is Arc => (p as Arc).startRadian !== undefined && (p as Arc).endRadian !== undefined;\r\n\r\n/**\r\n * Returns true if parameter has a positioned (x,y) \r\n * @param p Point, Arc or ArcPositiond\r\n * @returns \r\n */\r\nexport const isPositioned = (p: Points.Point | Arc| ArcPositioned): p is Points.Point => (p as Points.Point).x !== undefined && (p as Points.Point).y !== undefined;\r\n\r\n/**\r\n * Arc, defined by radius, start and end point in radians, and whether it is counter-clockwise.\r\n */\r\nexport type Arc = {\r\n/**\r\n * Radius of arc\r\n */\r\n  readonly radius:number\r\n/**\r\n * Start radian\r\n */\r\n  readonly startRadian:number\r\n/**\r\n * End radian\r\n */\r\n  readonly endRadian:number\r\n/**\r\n * If true, arc is counter-clockwise\r\n */\r\n  readonly counterClockwise?:boolean\r\n}\r\n\r\n/**\r\n * An {@link Arc} that also has a position, given in x, y\r\n */\r\nexport type ArcPositioned = Points.Point & Arc;\r\n\r\nconst piPi = Math.PI *2;\r\n\r\n/**\r\n * Returns an arc from degrees, rather than radians\r\n * @param radius Radius of arc\r\n * @param startDegrees Start angle in degrees\r\n * @param endDegrees End angle in degrees\r\n * @param origin Optional center of arc\r\n * @returns Arc\r\n */\r\nexport function fromDegrees(radius:number, startDegrees:number, endDegrees:number):Arc;\r\nexport function fromDegrees(radius:number, startDegrees:number, endDegrees:number, origin:Points.Point):ArcPositioned\r\n\r\n//eslint-disable-next-line func-style\r\nexport function fromDegrees(radius:number, startDegrees:number, endDegrees:number, origin?:Points.Point):Arc|ArcPositioned  {\r\n  const a:Arc = {\r\n    radius,\r\n    startRadian:degreeToRadian(startDegrees),\r\n    endRadian:degreeToRadian(endDegrees)\r\n  };\r\n  if (isPoint(origin)) {\r\n    guardPoint(origin);\r\n    const ap:ArcPositioned = {\r\n      ...a,\r\n      x: origin.x,\r\n      y: origin.y\r\n    };\r\n    return Object.freeze(ap);\r\n  } else {\r\n    return Object.freeze(a);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a {@link Line} linking the start and end points of an {@link ArcPositioned}.\r\n *\r\n * @param arc\r\n * @returns Line from start to end of arc\r\n */\r\nexport const toLine = (arc:ArcPositioned):Lines.Line => Lines.fromPoints(\r\n  point(arc, arc.startRadian),\r\n  point(arc, arc.endRadian)\r\n);\r\n\r\n/**\r\n * Calculates a coordinate on an arc, based on an angle\r\n * @param arc Arc\r\n * @param angleRadian Angle of desired coordinate \r\n * @param origin Origin of arc (0,0 used by default)\r\n * @returns Coordinate\r\n */\r\nexport const point = (arc:Arc|ArcPositioned, angleRadian:number, origin?:Points.Point): Points.Point => {\r\n  if (angleRadian > arc.endRadian) throw new Error(`angleRadian beyond end angle of arc`);\r\n  if (angleRadian < arc.startRadian) throw new Error(`angleRadian beyond start angle of arc`);\r\n\r\n  if (origin === undefined) {\r\n    if (isPositioned(arc)) {\r\n      origin = arc;\r\n    } else {\r\n      origin = {x:0, y:0};\r\n    }\r\n  }\r\n  return {\r\n    x: (Math.cos(angleRadian) * arc.radius) + origin.x,\r\n    y: (Math.sin(angleRadian) * arc.radius) + origin.y\r\n  };\r\n};\r\n\r\n/**\r\n * Throws an error if arc instance is invalid\r\n * @param arc \r\n */\r\nexport const guard = (arc:Arc|ArcPositioned) => {\r\n  if (arc === undefined) throw new Error(`Arc is undefined`);\r\n  if (isPositioned(arc)) {\r\n    guardPoint(arc, `arc`);\r\n  }\r\n  if (arc.radius === undefined) throw new Error(`Arc radius is undefined (${JSON.stringify(arc)})`);\r\n  if (typeof arc.radius !== `number`) throw new Error(`Radius must be a number`);\r\n  if (Number.isNaN(arc.radius)) throw new Error(`Radius is NaN`);\r\n  if (arc.radius <= 0) throw new Error(`Radius must be greater than zero`);\r\n\r\n  if (arc.startRadian === undefined) throw new Error(`Arc is missing 'startRadian' field`);\r\n  if (arc.endRadian === undefined) throw new Error(`Arc is missing 'startRadian' field`);\r\n  if (Number.isNaN(arc.endRadian)) throw new Error(`Arc endRadian is NaN`);\r\n  if (Number.isNaN(arc.startRadian)) throw new Error(`Arc endRadian is NaN`);\r\n\r\n  if (arc.startRadian >= arc.endRadian) throw new Error(`startRadian is expected to be les than endRadian`);  \r\n};\r\n\r\n\r\ntype Interpolate = {\r\n  (amount:number, arc:Arc, origin:Points.Point):Points.Point;\r\n  (amount:number, arc:ArcPositioned):Points.Point;\r\n};\r\n\r\n/**\r\n * Compute relative position on arc\r\n * @param arc Arc\r\n * @param amount Relative position 0-1\r\n * @param origin If arc is not positioned, pass in an origin\r\n * @returns \r\n */\r\nexport const interpolate:Interpolate = (amount:number, arc:ArcPositioned|Arc, origin?:Points.Point):Points.Point => {\r\n  guard(arc);\r\n  return point(arc, arc.startRadian + ((arc.endRadian-arc.startRadian)*amount), origin);\r\n};\r\n\r\n/**\r\n * Creates a {@link Path} instance from the arc. This wraps up some functions for convienence.\r\n * @param arc \r\n * @returns Path\r\n */\r\nexport const toPath = (arc:ArcPositioned): Path => {\r\n  guard(arc);\r\n\r\n  return Object.freeze({\r\n    ...arc,\r\n    interpolate:(amount:number) => interpolate(amount, arc),\r\n    bbox:() => bbox(arc) as Rects.RectPositioned,\r\n    length: () => length(arc),\r\n    toSvgString:() => toSvg(arc),\r\n    kind: `arc`\r\n  });\r\n};\r\n\r\n/**\r\n * Calculates the length of the arc\r\n * @param arc \r\n * @returns Length\r\n */\r\nexport const length = (arc:Arc):number =>  piPi*arc.radius*((arc.startRadian-arc.endRadian)/piPi);\r\n\r\n/**\r\n * Calculates a {@link Rects.Rect|Rect} bounding box for arc.\r\n * @param arc \r\n * @returns Rectangle encompassing arc.\r\n */\r\nexport const bbox = (arc:ArcPositioned|Arc):Rects.RectPositioned|Rects.Rect => {\r\n  if (isPositioned(arc)) {\r\n    const middle = interpolate(0.5, arc);\r\n    const asLine = toLine(arc);\r\n    return Points.bbox(middle, asLine.a, asLine.b);\r\n  } else {\r\n    return {\r\n      width: arc.radius*2,\r\n      height: arc.radius*2\r\n    };\r\n  }\r\n};\r\n\r\n\r\ntype ToSvg = {\r\n  /**\r\n   * SVG path for arc description\r\n   * @param origin Origin of arc\r\n   * @param radius Radius\r\n   * @param startRadian Start\r\n   * @param endRadian End\r\n   */\r\n  (origin:Points.Point, radius:number, startRadian:number, endRadian:number, opts?:SvgOpts): readonly string[];\r\n  /**\r\n   * SVG path for non-positioned arc\r\n   */\r\n  (arc:Arc, origin:Points.Point, opts?:SvgOpts): readonly string[];\r\n/**\r\n * SVG path for positioned arc\r\n */\r\n  (arc:ArcPositioned, opts?:SvgOpts): readonly string[];\r\n};\r\n\r\n\r\n/**\r\n * Creates an SV path snippet for arc\r\n * @returns \r\n */\r\nexport const toSvg:ToSvg = (a:Points.Point|Arc|ArcPositioned, b?:number|Points.Point|SvgOpts, c?:number|SvgOpts, d?:number, e?:SvgOpts) => {\r\n  if (isArc(a)) {\r\n    if (isPositioned(a)) {\r\n      return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b as SvgOpts);\r\n    } else {\r\n      if (isPoint(b)) {\r\n        return toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as SvgOpts);\r\n      } else {\r\n        return toSvgFull({x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\r\n      }\r\n    }\r\n  } else {\r\n    if (c === undefined) throw new Error(`startAngle undefined`);\r\n    if (d === undefined) throw new Error(`endAngle undefined`);\r\n   \r\n    if (isPoint(a)) {\r\n      if (typeof b === `number` && typeof c ===  `number` && typeof d === `number`) {\r\n        return toSvgFull(a, b, c, d, e);\r\n      } else {\r\n        throw new Error(`Expected (point, number, number, number). Missing a number param.`);\r\n      }\r\n    } else {\r\n      throw new Error(`Expected (point, number, number, number). Missing first point.`);\r\n    }\r\n  } \r\n};\r\n\r\ntype SvgOpts = {\r\n  \r\n  /**\r\n   * \"If the arc should be greater or less than 180 degrees\"\r\n   * ie. tries to maximise arc length\r\n   */\r\n  readonly largeArc?:boolean\r\n  \r\n  /**\r\n   * \"If the arc should begin moving at positive angles\"\r\n   * ie. the kind of bend it makes to reach end point\r\n   */\r\n  readonly sweep?:boolean\r\n}\r\n\r\nconst toSvgFull = (origin:Points.Point, radius:number, startRadian:number, endRadian:number, opts?:SvgOpts):readonly string[] => {\r\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\r\n  // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n  // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\r\n\r\n  if (opts === undefined || typeof opts !== `object`) opts = {};\r\n\r\n  const isFullCircle = endRadian - startRadian === 360;\r\n  const start = Polar.toCartesian(radius, endRadian - 0.01, origin);\r\n  const end = Polar.toCartesian(radius, startRadian, origin);\r\n  \r\n  const {largeArc = false, sweep = false} = opts;\r\n\r\n  const d = [`\r\n    M ${start.x} ${start.y}\r\n    A ${radius} ${radius} 0 ${largeArc ? `1` : `0`} ${sweep ? `1` : `0`} ${end.x} ${end.y},\r\n  `];\r\n\r\n  //eslint-disable-next-line functional/immutable-data\r\n  if (isFullCircle) d.push(`z`);\r\n\r\n  return d;\r\n};\r\n\r\n/**\r\n * Calculates the distance between the centers of two arcs\r\n * @param a\r\n * @param b \r\n * @returns Distance \r\n */\r\nexport const distanceCenter = (a:ArcPositioned, b:ArcPositioned):number => Points.distance(a, b);\r\n\r\n/**\r\n * Returns true if the two arcs have the same values\r\n *\r\n * @param a\r\n * @param b\r\n * @returns {boolean}\r\n */\r\nexport const isEquals = (a:Arc|ArcPositioned, b:Arc|ArcPositioned):boolean => {\r\n  if (a.radius !== b.radius) return false;\r\n\r\n  if (isPositioned(a) && isPositioned(b)) {\r\n    if (a.x !== b.x) return false;\r\n    if (a.y !== b.y) return false;\r\n    if (a.z !== b.z) return false;\r\n    return true;\r\n  } else if (!isPositioned(a) && !isPositioned(b)) {\r\n    // no-op\r\n  } else return false; // one is positioned one not\r\n\r\n  if (a.endRadian !== b.endRadian) return false;\r\n  if (a.startRadian !== b.startRadian) return false;\r\n  return true;\r\n};","import { Polar, Rects} from \"./index.js\";\r\nimport {interpolate as lineInterpolate} from './Line';\r\nimport {number as guardNumber} from '../Guards';\r\nimport {clamp as clampNumber, wrapInteger as wrapNumber} from '../Util';\r\n\r\n//const piPi =Math.PI*2;\r\n\r\n/**\r\n * A point, consisting of x, y and maybe z fields.\r\n */\r\nexport type Point = {\r\n  readonly x: number\r\n  readonly y: number\r\n  readonly z?: number\r\n};\r\n\r\n/**\r\n * An empty point of {x:0, y:0}\r\n */\r\n//eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const Empty = Object.freeze({ x:0, y: 0});\r\n\r\n/**\r\n * Returns the 'minimum' point from an array of points, using a comparison function.\r\n * \r\n * @example Find point closest to a coordinate\r\n * ```js\r\n * const points = [...];\r\n * const center = {x: 100, y: 100};\r\n * \r\n * const closestToCenter = findMinimum((a, b) => {\r\n *  const aDist = distance(a, center);\r\n *  const bDist = distance(b, center);\r\n *  if (aDistance < bDistance) return a;\r\n *  return b;\r\n * }, points);\r\n * ```\r\n * @param compareFn Compare function returns the smallest of `a` or `b`\r\n * @param points \r\n * @returns \r\n */\r\nexport const findMinimum = (compareFn:(a:Point, b:Point)=>Point, ...points:readonly Point[]):Point => {\r\n  if (points.length === 0) throw new Error(`No points provided`);\r\n  //eslint-disable-next-line functional/no-let\r\n  let min = points[0];\r\n  points.forEach(p => {\r\n    min = compareFn(min, p);\r\n  });\r\n  return min;\r\n};\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param a \r\n * @param b \r\n * @returns \r\n */\r\nexport const distance = (a:Point, b:Point):number => {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return Math.hypot(b.x-a.x, b.y-a.y);\r\n};\r\n\r\n/**\r\n * Throws an error if point is invalid\r\n * @param p \r\n * @param name \r\n */\r\nexport const guard = (p: Point, name = `Point`) => {\r\n  if (p === undefined) throw new Error(`'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p === null) throw new Error(`'${name}' is null. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p.x === undefined) throw new Error(`'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p.y === undefined) throw new Error(`'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (typeof p.x !== `number`) throw new Error(`'${name}.x' must be a number`);\r\n  if (typeof p.y !== `number`) throw new Error(`'${name}.y' must be a number`);\r\n \r\n  if (Number.isNaN(p.x)) throw new Error(`'${name}.x' is NaN`);\r\n  if (Number.isNaN(p.y)) throw new Error(`'${name}.y' is NaN`);\r\n};\r\n\r\n/**\r\n * Throws if parameter is not a valid point, or either x or y is 0\r\n * @param pt\r\n * @returns \r\n */\r\nexport const guardNonZeroPoint = (pt: Point, name = `pt`) => {\r\n  guard(pt, name);\r\n  guardNumber(pt.x, `nonZero`, `${name}.x`);\r\n  guardNumber(pt.y, `nonZero`, `${name}.y`);\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Returns the angle in radians between `a` and `b`.\r\n * Eg if `a` is the origin, and `b` is another point,\r\n * in degrees one would get 0 to -180 when `b` was above `a`.\r\n *  -180 would be `b` in line with `a`.\r\n * Same for under `a`.\r\n * @param a \r\n * @param b \r\n * @returns \r\n */\r\nexport const angleBetween = (a: Point, b: Point) => Math.atan2(b.y - a.y, b.x - a.x);\r\n\r\n/**\r\n * Returns the minimum rectangle that can enclose all provided points\r\n * @param points\r\n * @returns \r\n */\r\nexport const bbox = (...points:readonly Point[]):Rects.RectPositioned => {\r\n  const leftMost = findMinimum((a, b) => {\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const rightMost = findMinimum((a, b) => {\r\n    if (a.x > b.x) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const topMost = findMinimum((a, b) => {\r\n    if (a.y < b.y) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const bottomMost = findMinimum((a, b) => {\r\n    if (a.y > b.y) return a;\r\n    else return b;\r\n  }, ...points);\r\n\r\n  const topLeft = {x:leftMost.x, y:topMost.y};\r\n  const topRight = {x:rightMost.x, y:topMost.y};\r\n  const bottomRight = {x:rightMost.x, y:bottomMost.y};\r\n  const bottomLeft = {x:leftMost.x, y:bottomMost.y};\r\n  return Rects.maxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\r\n};\r\n\r\n/**\r\n * Returns _true_ if the parameter has x and y fields\r\n * @param p \r\n * @returns \r\n */\r\nexport const isPoint = (p: number|unknown): p is Point => {\r\n  if (p === undefined) return false;\r\n  if ((p as Point).x === undefined) return false;\r\n  if ((p as Point).y === undefined) return false;\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\r\n * that expect points in array form.\r\n * \r\n * ```\r\n * const p = {x: 10, y:5};\r\n * const p2 = toArray(p); // yields [10,5]\r\n * ```\r\n * @param p\r\n * @returns\r\n */\r\nexport const toArray = (p: Point): readonly number[] => ([p.x, p.y]);\r\n\r\n/**\r\n * Returns a human-friendly string representation `(x, y)`\r\n * @param p\r\n * @returns \r\n */\r\nexport const toString = (p: Point): string => {\r\n  if (p.z !== undefined) {\r\n    return `(${p.x},${p.y},${p.z})`;\r\n  } else {\r\n    return `(${p.x},${p.y})`;\r\n  }\r\n};\r\n\r\n/**\r\n * Returns _true_ if the two points have identical values\r\n * \r\n * ```js\r\n * const a = {x: 10, y: 10};\r\n * const b = {x: 10, y: 10;};\r\n * a === b        // False, because a and be are different objects\r\n * equals(a, b)   // True, because a and b are same value\r\n * ```\r\n * @param a\r\n * @param b\r\n * @returns _True_ if points are equal\r\n */\r\nexport const equals = (a: Point, b: Point): boolean =>  a.x === b.x && a.y === b.y;\r\n\r\n/**\r\n * Returns true if two points are within a specified range.\r\n * Provide a point for the range to set different x/y range, or pass a number\r\n * to use the same range for both axis.\r\n *\r\n * @example\r\n * ```js\r\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\r\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True \r\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far \r\n * ```\r\n * @param a\r\n * @param b\r\n * @param maxRange\r\n * @returns \r\n */\r\nexport const withinRange = (a:Point, b:Point, maxRange:Point|number):boolean =>  {\r\n  if (typeof maxRange === `number`) {\r\n    maxRange = {x:maxRange, y:maxRange};\r\n  }\r\n  const x = Math.abs(b.x - a.x);\r\n  const y = Math.abs(b.y - a.y);\r\n  return (x <= maxRange.x && y<= maxRange.y);\r\n};\r\n\r\n/**\r\n * Returns a relative point between two points\r\n * ```js\r\n * interpolate(0.5, a, b); // Halfway point between a and b\r\n * ```\r\n * \r\n * Alias for Lines.interpolate(amount, a, b);\r\n * \r\n * @param amount Relative amount, 0-1\r\n * @param a \r\n * @param b \r\n * @returns {@link Point}\r\n */\r\nexport const interpolate =(amount:number, a:Point, b:Point):Point => lineInterpolate(amount, a, b); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\r\n\r\n/**\r\n * Returns a point from two coordinates or an array of [x,y]\r\n * @example\r\n * ```js\r\n * let p = from([10, 5]); // yields {x:10, y:5}\r\n * let p = from(10, 5);   // yields {x:10, y:5}\r\n * let p = from(10);      // yields {x:10, y:0} 0 is used for default y\r\n * let p = from();        // yields {x:0, y:0}  0 used for default x & y\r\n * ```\r\n * @param xOrArray\r\n * @param [y]\r\n * @returns Point\r\n */\r\nexport const from = (xOrArray?: number | readonly number[], y?: number): Point => {\r\n  if (Array.isArray(xOrArray)) {\r\n    if (xOrArray.length !== 2) throw new Error(`Expected array of length two, got ` + xOrArray.length);\r\n    return Object.freeze({\r\n      x: xOrArray[0],\r\n      y: xOrArray[1]\r\n    });\r\n  } else {\r\n    if (xOrArray === undefined) xOrArray = 0;\r\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\r\n    if (y === undefined) y = 0;\r\n    else if (Number.isNaN(y)) throw new  Error(`y is NaN`);\r\n    return Object.freeze({x: xOrArray as number, y: y});\r\n  }\r\n};\r\n\r\n/**\r\n * Returns an array of points from an array of numbers. \r\n * \r\n * Array can be a continuous series of x, y values:\r\n * ```\r\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\r\n * ```\r\n * \r\n * Or it can be an array of arrays:\r\n * ```\r\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\r\n * ```\r\n * @param coords \r\n * @returns \r\n */\r\nexport const fromNumbers = (...coords:readonly ReadonlyArray<number>[]|readonly number[]): readonly Point[] => {\r\n  const pts:Point[] = [];\r\n\r\n  if (Array.isArray(coords[0])) {\r\n    // [[x,y],[x,y]...]\r\n    (coords as number[][]).forEach(coord => {\r\n      if (!(coord.length % 2 === 0)) throw new Error(`coords array should be even-numbered`);\r\n      //eslint-disable-next-line  functional/immutable-data\r\n      pts.push(Object.freeze({x: coord[0], y: coord[1]}));    \r\n    });\r\n  } else {\r\n    if (coords.length !== 2) throw new Error(`Expected two elements: [x,y]`);\r\n    // [x,y]\r\n    //eslint-disable-next-line  functional/immutable-data\r\n    pts.push(Object.freeze({x: coords[0] as number, y: coords[1] as number}));\r\n  }\r\n  return pts;\r\n};\r\n\r\n/**\r\n * Returns `a` minus `b`\r\n * \r\n * ie.\r\n * ```js\r\n * return {\r\n *   x: a.x - b.x,\r\n *   y: a.y - b.y\r\n * };\r\n * ```\r\n * @param a Point a\r\n * @param b Point b\r\n * @returns Point\r\n */\r\nexport function subtract(a: Point, b: Point): Point;\r\n\r\n/**\r\n * Returns `a` minus the given coordinates.\r\n * \r\n * ie:\r\n * ```js\r\n * return {\r\n *  x: a.x - x,\r\n *  y: a.y - y\r\n * }\r\n * ```\r\n * @param a Point\r\n * @param x X coordinate\r\n * @param y Y coordinate\r\n */\r\nexport function subtract (a:Point, x:number, y:number):Point;\r\n\r\n/**\r\n * Subtracts two sets of x,y pairs\r\n * @param x1 \r\n * @param y1 \r\n * @param x2 \r\n * @param y2 \r\n */\r\nexport function subtract (x1:number, y1:number, x2:number, y2:number):Point;\r\n\r\n//eslint-disable-next-line func-style\r\nexport function subtract(a:Point|number, b:Point|number, c?:number, d?:number):Point {\r\n  if (isPoint(a)) {\r\n    guard(a, `a`);\r\n    if (isPoint(b)) {\r\n      guard(b, `b`);\r\n      return {\r\n        x: a.x - b.x,\r\n        y: a.y - b.y\r\n      };\r\n    } else {\r\n      if (c === undefined) c = 0;\r\n      return {\r\n        x: a.x - b,\r\n        y: a.y - c\r\n      };\r\n    }\r\n  } else {\r\n    guardNumber(a, ``, `a`);\r\n    if (typeof b !== `number`) throw new Error(`Second parameter is expected to by y value`);\r\n    guardNumber(b, ``, `b`);\r\n    if (c === undefined) c = 0;\r\n    if (d === undefined) d = 0;\r\n    return {\r\n      x: a - c,\r\n      y: b - d\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Applies `fn` on `x` and `y` fields, returning all other fields as well\r\n * ```js\r\n * const p = {x:1.234, y:4.9};\r\n * const p2 = apply(p, Math.round);\r\n * // Yields: {x:1, y:5}\r\n * ```\r\n * @param pt \r\n * @param fn \r\n * @returns \r\n */\r\nexport const apply = (pt:Point, fn:(v:number)=>number):Point => ({\r\n  ...pt,\r\n  x: fn(pt.x),\r\n  y: fn(pt.y)\r\n});\r\n\r\ntype Sum = {\r\n  /**\r\n   * Adds two sets of coordinates\r\n   */\r\n  (aX:number, aY:number, bX:number, bY:number):Point;\r\n  /**\r\n   * Add x,y to a\r\n   */\r\n  (a:Point, x:number, y?:number):Point;\r\n  /**\r\n   * Add two points\r\n   */\r\n  (a:Point, b?:Point):Point;\r\n};\r\n\r\n/**\r\n * Returns `a` plus `b`\r\n * ie.\r\n * ```js\r\n * return {\r\n *   x: a.x + b.x,\r\n *   y: a.y + b.y\r\n * };\r\n * ```\r\n */\r\nexport const sum:Sum = function (a: Point|number, b: Point|number|undefined, c?:number, d?:number): Point {\r\n  // ✔️ Unit tested\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let ptA:Point|undefined;\r\n  //eslint-disable-next-line functional/no-let\r\n  let ptB:Point|undefined;\r\n  if (isPoint(a)) {\r\n    ptA = a;\r\n    if (b === undefined) b = Empty;\r\n    if (isPoint(b)) {\r\n      ptB = b;\r\n    } else {\r\n      if (b === undefined) throw new Error(`Expects x coordinate`);\r\n      ptB = {x: b, y: (c === undefined ? 0 : c)};    \r\n    }\r\n  } else if (!isPoint(b)) {\r\n    // Neither of first two params are points\r\n    if (b === undefined) throw new Error(`Expected number as second param`);\r\n    ptA = {x: a, y: b};\r\n    if (c === undefined) throw new Error(`Expects x coordiante`);\r\n    ptB = {x: c, y: (d === undefined ? 0 : d)};    \r\n  }\r\n\r\n  if (ptA === undefined) throw new Error(`ptA missing`);\r\n  if (ptB === undefined) throw new Error(`ptB missing`);\r\n  guard(ptA, `a`);\r\n  guard(ptB, `b`);\r\n  return {\r\n    x: ptA.x + ptB.x,\r\n    y: ptA.y + ptB.y\r\n  };\r\n};\r\n\r\n/**\r\n * Returns `a` multiplied by `b`\r\n * \r\n * ie.\r\n * ```js\r\n * return {\r\n *  x: a.x * b.x,\r\n*   y: a.y * b.y\r\n * }\r\n * ```\r\n * @param a\r\n * @param b\r\n * @returns\r\n */\r\nexport function multiply(a: Point, b: Point): Point;\r\n\r\n/**\r\n * Returns `a` multipled by some x and/or y scaling factor\r\n * \r\n * ie.\r\n * ```js\r\n * return {\r\n *  x: a.x * x\r\n*   y: a.y * y\r\n * }\r\n * ```\r\n * @export\r\n * @parama Point to scale\r\n * @param x Scale factor for x axis\r\n * @param [y] Scale factor for y axis (defaults to no scaling)\r\n * @returns Scaled point\r\n */\r\nexport function multiply(a: Point, x: number, y?: number): Point;\r\n\r\n/**\r\n * Returns `a` multiplied by `b` point, or given x and y.\r\n * ie.\r\n * ```js\r\n * return {\r\n *   x: a.x * b.x,\r\n *   y: a.y * b.y\r\n * };\r\n * ```\r\n * @param a \r\n * @param bOrX \r\n * @param y \r\n * @returns \r\n */\r\n/* eslint-disable func-style */\r\nexport function multiply(a: Point, bOrX: Point | number, y?: number):Point {\r\n  // ✔️ Unit tested\r\n\r\n  guard(a, `a`);\r\n  if (typeof bOrX === `number`) {\r\n    if (typeof y === `undefined`) y = 1;\r\n    guardNumber(y, ``, `y`);\r\n    guardNumber(bOrX, ``, `x`);\r\n\r\n    return {x: a.x * bOrX, y: a.y * y};\r\n  } else if (isPoint(bOrX)) {\r\n    guard(bOrX, `b`);\r\n    return {\r\n      x: a.x * bOrX.x,\r\n      y: a.y * bOrX.y\r\n    };\r\n  } else throw new Error(`Invalid arguments`);\r\n}\r\n\r\n/**\r\n * Divides a / b\r\n * @param a \r\n * @param b \r\n */\r\nexport function divide(a: Point, b:Point):Point;\r\n\r\n/**\r\n * Divides a point by x,y.\r\n * ie: a.x / x, b.y / y\r\n * @param a Point\r\n * @param x X divisor\r\n * @param y Y divisor\r\n */\r\nexport function divide(a:Point, x:number, y:number):Point;\r\nexport function divide(x1:number, y1:number, x2?:number, y2?:number):Point;\r\n\r\nexport function divide(a: Point|number, b: Point | number, c?: number, d?:number):Point {\r\n  // ✔️ Unit tested\r\n\r\n  if (isPoint(a)) {\r\n    if (isPoint(b)) {\r\n      guard(a);\r\n      guardNonZeroPoint(b);\r\n      \r\n      return {\r\n        x: a.x / b.x,\r\n        y: a.y / b.y\r\n      };\r\n    } else {\r\n      if (c === undefined) c = 1;\r\n      guard(a);\r\n      guardNumber(b, `nonZero`, `x`);\r\n      guardNumber(c, `nonZero`, `y`);\r\n      return {\r\n        x: a.x / b,\r\n        y: a.y / c\r\n      };\r\n    }\r\n  } else {\r\n    if (typeof b !== `number`) throw new Error(`expected second parameter to be y1 coord`);\r\n    guardNumber(a, `positive`, `x1`);\r\n    guardNumber(b, `positive`, `y1`);\r\n    if (c === undefined) c = 1;\r\n    if (d === undefined) d = 1;\r\n    guardNumber(c, `nonZero`, `x2`);\r\n    guardNumber(d, `nonZero`, `y2`);\r\n\r\n    return {\r\n      x: a / c,\r\n      y: b / d\r\n    };\r\n  }\r\n}\r\n\r\nexport const rotate = (pt:Point, amountRadian:number, origin?:Point):Point => {\r\n  if (origin === undefined) origin = {x:0, y:0};\r\n  guard(origin, `origin`);\r\n  guard(pt, `pt`);\r\n  guardNumber(amountRadian, ``, `amountRadian`);\r\n  const p = Polar.fromCartesian(pt, origin);\r\n  const pp = Polar.rotate(p, amountRadian);\r\n  return Polar.toCartesian(pp, origin);\r\n};\r\n\r\n/**\r\n * Normalises a point by a given width and height\r\n * @param pt Point\r\n * @param width Width\r\n * @param height Height\r\n */\r\nexport function normalise(pt:Point, width:number, height:number):Point;\r\n\r\n/**\r\n * Normalises x,y by width and height so it is on a 0..1 scale\r\n * @param x \r\n * @param y \r\n * @param width \r\n * @param height \r\n */\r\nexport function normalise(x:number, y:number, width:number, height:number):Point;\r\n\r\n/**\r\n * Normalises a point so it is on a 0..1 scale\r\n * @param a Point, or x\r\n * @param b y coord or width\r\n * @param c height or width\r\n * @param d height\r\n * @returns Point\r\n */\r\nexport function normalise(a:Point|number, b:number, c:number, d?:number):Point {\r\n  // ✔️ Unit tested\r\n  if (isPoint(a)) {\r\n    guardNumber(b, `positive`, `width`);\r\n    guardNumber(c, `positive`, `height`);\r\n    return {\r\n      x: a.x / b,\r\n      y: a.y / c\r\n    };\r\n  } else {\r\n    guardNumber(a, `positive`, `x`);\r\n    guardNumber(b, `positive`, `y`);\r\n    guardNumber(c, `positive`, `width`);\r\n    if (d === undefined) throw new Error(`Expected height parameter`);\r\n    guardNumber(d, `positive`, `height`);\r\n    return {\r\n      x: a / c,\r\n      y: b / d\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Wraps a point to be within `ptMin` and `ptMax`.\r\n * Note that max values are _exclusive_, meaning the return value will always be one less.\r\n * \r\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\r\n * \r\n * ```js\r\n * // Wraps 150,100 to on 0,0 -100,100 range\r\n * wrap({x:150,y:100}, {x:100,y:100});\r\n * ```\r\n * \r\n * If `ptMin` is not specified, {x:0,y:0} is used.\r\n * @param pt Point to wrap\r\n * @param ptMax Maximum value\r\n * @param ptMin Minimum value, or {x:0, y:0} by default\r\n * @returns Wrapped point\r\n */\r\nexport const wrap = (pt:Point, ptMax:Point, ptMin:Point = {x:0, y:0}):Point => {\r\n  // ✔️ Unit tested\r\n  guard(pt, `pt`);\r\n  guard(ptMax, `ptMax`);\r\n  guard(ptMin, `ptMin`);\r\n  \r\n  return {\r\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\r\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y)\r\n  };\r\n};\r\n\r\n/**\r\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\r\n * @param pt Point\r\n * @param min Minimum value (0 by default)\r\n * @param max Maximum value (1 by default)\r\n */\r\nexport function clamp(pt:Point, min?:number, max?:number):Point;\r\n\r\n/**\r\n * Clamps an x,y pair to be between `min` and `max` (0 & 1 by default)\r\n * @param x X coordinate\r\n * @param y Y coordinate\r\n * @param min Minimum value (0 by default)\r\n * @param max Maximum value (1 by default)\r\n */\r\nexport function clamp(x:number, y:number, min?:number, max?:number):Point;\r\nexport function clamp(a:Point|number, b?:number, c?:number, d?:number):Point {\r\n  // ✔️ Unit tested\r\n\r\n  if (isPoint(a)) {\r\n    if (b === undefined) b = 0;\r\n    if (c === undefined) c = 1;\r\n    guardNumber(b, ``, `min`);\r\n    guardNumber(c, ``, `max`);\r\n    return {\r\n      x: clampNumber(a.x, b, c),\r\n      y: clampNumber(a.y, b, c)\r\n    };\r\n  } else {\r\n    if (b === undefined) throw new Error(`Expected y coordinate`);\r\n    if (c === undefined) c = 0;\r\n    if (d === undefined) d = 1;\r\n    guardNumber(a, ``, `x`);\r\n    guardNumber(b, ``, `y`);\r\n    guardNumber(c, ``, `min`);\r\n    guardNumber(d, ``, `max`);\r\n\r\n    return {\r\n      x: clampNumber(a, c, d),\r\n      y: clampNumber(b, c, d)\r\n    };\r\n  }\r\n}\r\n","import {guard as guardPoint} from './Point.js';\r\nimport {percent as guardPercent} from '../Guards.js';\r\nimport {Path} from './Path.js';\r\nimport { Rects, Points} from './index.js';\r\n\r\nexport type Line = {\r\n  readonly a: Points.Point\r\n  readonly b: Points.Point\r\n}\r\n\r\nexport const isLine = (p: Path | Line | Points.Point): p is Line => {\r\n  if (p === undefined) return false;\r\n  return (p as Line).a !== undefined && (p as Line).b !== undefined;\r\n};\r\n\r\n/**\r\n * Returns true if the lines have the same value\r\n *\r\n * @param {Line} a\r\n * @param {Line} b\r\n * @returns {boolean}\r\n */\r\nexport const equals = (a:Line, b:Line):boolean =>  a.a === b.a && a.b === b.b;\r\n\r\n/**\r\n * Applies `fn` to both start and end points.\r\n * \r\n * ```js\r\n * // Line 10,10 -> 20,20\r\n * const line = Lines.fromNumbers(10,10, 20,20);\r\n * \r\n * // Applies randomisation to x&y\r\n * const rand = (p) => ({\r\n *  x: p.x * Math.random(),\r\n *  y: p.y * Math.random()\r\n * });\r\n * \r\n * // Applies our randomisation function\r\n * const line2 = apply(line, rand);\r\n * ```\r\n * @param line Line\r\n * @param fn Function that takes a point and returns a point\r\n * @returns \r\n */\r\nexport const apply = (line:Line, fn:(p:Points.Point) => Points.Point) => (\r\n  {\r\n    ...line,\r\n    a: fn(line.a),\r\n    b: fn(line.b)\r\n  }\r\n);\r\n\r\n/**\r\n * Throws an exception if:\r\n * * line is undefined\r\n * * a or b parameters are missing\r\n * \r\n * Does not validate points\r\n * @param line \r\n * @param paramName \r\n */\r\nexport const guard = (line:Line, paramName:string = `line`) => {\r\n  if (line === undefined) throw new Error(`${paramName} undefined`);\r\n  if (line.a === undefined) throw new Error(`${paramName}.a undefined. Expected {a:Point, b:Point}`);\r\n  if (line.b === undefined) throw new Error(`${paramName}.b undefined. Expected {a:Point, b:Point}`);\r\n};\r\n\r\n/**\r\n * Returns the angle in radians of a line, or two points\r\n * ```js\r\n * angleRadian(line);\r\n * angleRadian(ptA, ptB);\r\n * ```\r\n * @param lineOrPoint \r\n * @param b \r\n * @returns \r\n */\r\nexport const angleRadian = (lineOrPoint:Line|Points.Point, b?:Points.Point):number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let a:Points.Point;\r\n  if (isLine(lineOrPoint)) {\r\n    a = lineOrPoint.a;\r\n    b = lineOrPoint.b;\r\n  } else {\r\n    a = lineOrPoint;\r\n    if (b === undefined) throw new Error(`b point must be provided`);\r\n  }\r\n  return Math.atan2(b.y - a.y, b.x - a.x);\r\n};\r\n\r\n/**\r\n * Multiplies start and end of line by x,y given in `p`.\r\n * ```js\r\n * // Line 1,1 -> 10,10\r\n * const l = fromNumbers(1,1,10,10);\r\n * const ll = multiply(l, {x:2, y:3});\r\n * // Yields: 2,20 -> 3,30\r\n * ```\r\n * @param line \r\n * @param point \r\n * @returns \r\n */\r\nexport const multiply = (line:Line, point:Points.Point):Line => ({ \r\n  a: Points.multiply(line.a, point),\r\n  b: Points.multiply(line.b, point)\r\n});\r\n\r\n/**\r\n * Returns true if `point` is within `maxRange` of `line`.\r\n * ```js\r\n * const line = Lines.fromNumbers(0,20,20,20);\r\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\r\n * ```\r\n * @param line\r\n * @param point\r\n * @param maxRange \r\n * @returns True if point is within range\r\n */\r\nexport const withinRange = (line:Line, point:Points.Point, maxRange:number):boolean =>  {\r\n  const dist = distance(line, point);\r\n  return dist <= maxRange;\r\n};\r\n\r\n/**\r\n * Returns the length of a line or length between two points\r\n * ```js\r\n * length(line);\r\n * length(ptA, ptB);\r\n * ```\r\n * @param aOrLine Line or first point\r\n * @param b Second point\r\n * @returns \r\n */\r\nexport const length = (aOrLine: Points.Point|Line, b?: Points.Point): number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let a;\r\n  if (isLine(aOrLine)) {\r\n    b = aOrLine.b;\r\n    a = aOrLine.a;\r\n  } else {\r\n    a = aOrLine;\r\n    if (b === undefined) throw new Error(`Requires both a and b parameters`);\r\n  }\r\n  guardPoint(a, `a`);\r\n  guardPoint(a, `b`);\r\n\r\n  const x = b.x - a.x;\r\n  const y = b.y - a.y;\r\n  if (a.z !== undefined && b.z !== undefined) {\r\n    const z = b.z - a.z;\r\n    return Math.hypot(x, y, z);\r\n  } else {\r\n    return Math.hypot(x, y);\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the nearest point on `line` closest to `point`.\r\n * ```js\r\n * nearest(line, {x:10,y:10});\r\n * ```\r\n * @param line\r\n * @param point\r\n * @returns Point {x,y}\r\n */\r\nexport const nearest = (line:Line, point:Points.Point): Points.Point => {\r\n  const {a, b} = line;\r\n  const atob = { x: b.x - a.x, y: b.y - a.y };\r\n  const atop = { x: point.x - a.x, y: point.y - a.y };\r\n  const len = atob.x * atob.x + atob.y * atob.y;\r\n  //eslint-disable-next-line functional/no-let\r\n  let dot = atop.x * atob.x + atop.y * atob.y;\r\n  const t = Math.min(1, Math.max(0, dot / len));\r\n  dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\r\n  return {x: a.x + atob.x * t, y: a.y + atob.y * t};\r\n};\r\n\r\n/**\r\n * Calculates slope of line\r\n * @example\r\n * ```js\r\n * slope(line);\r\n * slope(ptA, ptB)\r\n * ```\r\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\r\n * @param b Second point if needed\r\n * @returns \r\n */\r\nexport const slope = (lineOrPoint:Line|Points.Point, b?:Points.Point):number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let a:Points.Point;\r\n  if (isLine(lineOrPoint)) {\r\n    //eslint-disable-next-line functional/no-let\r\n    a = lineOrPoint.a;\r\n    b = lineOrPoint.b;\r\n  } else {\r\n    a = lineOrPoint;\r\n    if (b === undefined) throw new Error(`b parameter required`);\r\n  }\r\n  if (b !== undefined) {\r\n    return (b.y - a.y) / (b.x - a.x);\r\n  } else throw Error(`Second point missing`);\r\n};\r\n\r\n/**\r\n * Extends a line to intersection the x-axis at a specified location\r\n * @param line Line to extend\r\n * @param xIntersection Intersection of x-axis.\r\n */\r\nexport const extendX = (line:Line, xIntersection:number):Points.Point => {\r\n  const y = line.a.y + (xIntersection - line.a.x) * slope(line);\r\n  return {x: xIntersection, y};\r\n};\r\n\r\n/**\r\n * Returns a line extended from it's start (`a`) by a specified distance\r\n *\r\n * ```js\r\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\r\n * const extended = extendFromStart(line, 2);\r\n * ```\r\n * @param ine\r\n * @param distance\r\n * @return Newly extended line\r\n */\r\nexport const extendFromStart = (line:Line, distance:number):Line => {\r\n  const len = length(line);\r\n  return Object.freeze({\r\n    a: line.a,\r\n    b: Object.freeze({\r\n      x: line.b.x + (line.b.x - line.a.x) / len * distance,\r\n      y: line.b.y + (line.b.y - line.a.y) / len * distance,\r\n    })\r\n  })\r\n  ;\r\n};\r\n\r\n/**\r\n * Returns the distance of `point` to the \r\n * nearest point on `line`.\r\n * \r\n * ```js\r\n * distance(line, {x:10,y:10});\r\n * ```\r\n * @param line\r\n * @param point\r\n * @returns \r\n */\r\nexport const distance = (line:Line, point:Points.Point):number => {\r\n  guard(line, `line`);\r\n  guardPoint(point, `point`);\r\n\r\n  const lineLength = length(line);\r\n  if (lineLength === 0) {\r\n    // Line is really a point\r\n    return length(line.a, point);\r\n  }\r\n\r\n  const near = nearest(line, point);\r\n  return length(near, point);\r\n};\r\n\r\n/**\r\n * Calculates a point in-between `a` and `b`.\r\n * \r\n * ```js\r\n * // Get {x,y} at 50% along line\r\n * interpolate(0.5, line);\r\n * \r\n * // Get {x,y} at 80% between point A and B\r\n * interpolate(0.8, ptA, ptB);\r\n * ```\r\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\r\n * @param a Start\r\n * @param b End\r\n * @returns Point between a and b\r\n */\r\nexport  function interpolate(amount: number, a: Points.Point, b: Points.Point): Points.Point;\r\nexport  function interpolate(amount: number, line:Line): Points.Point;\r\n\r\n//eslint-disable-next-line func-style\r\nexport function interpolate(amount:number, a:Points.Point|Line, b?:Points.Point): Points.Point {\r\n  guardPercent(amount, `amount`);\r\n  if (isLine(a)) {\r\n    b = a.b;\r\n    a = a.a;\r\n  }\r\n\r\n  if (!Points.isPoint(a)) throw new Error(`Expected point`);\r\n  if (!Points.isPoint(b)) throw new Error(`Expected point`);\r\n\r\n  guardPoint(a, `a`);\r\n  guardPoint(b, `b`);\r\n\r\n  const d = length(a, b);\r\n  const d2 = d * (1 - amount);\r\n\r\n  const x = b.x - (d2 * (b.x - a.x) / d);\r\n  const y = b.y - (d2 * (b.y - a.y) / d);\r\n  return {x: x, y: y};\r\n}\r\n\r\n/**\r\n * Returns a string representation of line, or two points\r\n * @param a \r\n * @param b \r\n * @returns \r\n */\r\nexport function toString (a: Points.Point, b: Points.Point): string;\r\n\r\nexport function toString(line:Line):string;\r\n\r\n//eslint-disable-next-line func-style\r\nexport function toString(a:Points.Point|Line, b?:Points.Point):string {\r\n  if (isLine(a)) {\r\n    guard(a, `a`);\r\n    b = a.b;\r\n    a = a.a;\r\n  } else if (b === undefined) throw new Error(`Expect second point if first is a point`);\r\n  return Points.toString(a) + `-` + Points.toString(b);\r\n}\r\n\r\n/**\r\n * Returns a line from a basis of coordinates\r\n * ```js\r\n * // Line from 0,1 -> 10,15\r\n * fromNumbers(0,1,10,15);\r\n * ```\r\n * @param x1 \r\n * @param y1 \r\n * @param x2 \r\n * @param y2 \r\n * @returns \r\n */\r\nexport const fromNumbers = (x1: number, y1: number, x2: number, y2: number): Line => {\r\n  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);\r\n  if (Number.isNaN(x2)) throw new Error(`x2 is NaN`);\r\n  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);\r\n  if (Number.isNaN(y2)) throw new Error(`y2 is NaN`);\r\n\r\n  const a = {x: x1, y: y1};\r\n  const b = {x: x2, y: y2};\r\n  return fromPoints(a, b);\r\n};\r\n\r\n/**\r\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\r\n *\r\n * @export\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {number[]}\r\n */\r\nexport const toFlatArray = (a: Points.Point, b: Points.Point): readonly number[] =>  [a.x, a.y, b.x, b.y];\r\n\r\nexport const toSvgString = (a: Points.Point, b: Points.Point): readonly string[] => [`M${a.x} ${a.y} L ${b.x} ${b.y}`];\r\n\r\n/**\r\n * Returns a line from four numbers [x1,y1,x2,y2]\r\n * @param arr Array in the form [x1,y1,x2,y2]\r\n * @returns Line\r\n */\r\nexport const fromArray = (arr: readonly number[]): Line => {\r\n  if (!Array.isArray(arr)) throw new Error(`arr parameter is not an array`);\r\n  if (arr.length !== 4) throw new Error(`array is expected to have length four`);\r\n  return fromNumbers(arr[0], arr[1], arr[2], arr[3]);\r\n};\r\n\r\n/**\r\n * Returns a line from two points\r\n * ```js\r\n * // Line from 0,1 to 10,15\r\n * fromPoints({x:0,y:1}, {x:10,y:15});\r\n * ```\r\n * @param a Start point\r\n * @param b End point\r\n * @returns \r\n */\r\nexport const fromPoints = (a: Points.Point, b: Points.Point): Line => {\r\n  guardPoint(a, `a`);\r\n  guardPoint(b, `b`);\r\n  a = Object.freeze(a);\r\n  b = Object.freeze(b);\r\n  return Object.freeze({\r\n    a: a,\r\n    b: b\r\n  });\r\n};\r\n\r\n/**\r\n * Returns an array of lines that connects provided points.\r\n * \r\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c\r\n * @param points \r\n * @returns \r\n */\r\nexport const joinPointsToLines = (...points:readonly Points.Point[]): readonly Line[] => {\r\n  const lines = [];\r\n  //eslint-disable-next-line functional/no-let\r\n  let start = points[0];\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i=1;i<points.length;i++) {\r\n    //eslint-disable-next-line functional/immutable-data\r\n    lines.push(fromPoints(start, points[i]));\r\n    start = points[i];\r\n  }\r\n  return lines;\r\n};\r\n\r\n\r\nexport const fromPointsToPath = (a:Points.Point, b:Points.Point): LinePath => toPath(fromPoints(a, b));\r\n\r\nexport type LinePath = Line & Path & {\r\n  toFlatArray():readonly number[]\r\n}\r\n\r\n/**\r\n * Returns a rectangle that encompasses dimension of line\r\n */\r\nexport const bbox = (line:Line):Rects.RectPositioned =>  Points.bbox(line.a, line.b);\r\n\r\nexport const toPath = (line:Line): LinePath => {\r\n  const {a, b} = line;\r\n  return Object.freeze({\r\n    ...line,\r\n    length: () => length(a, b),\r\n    interpolate: (amount: number) => interpolate(amount, a, b),\r\n    bbox: () => bbox(line),\r\n    toString: () => toString(a, b),\r\n    toFlatArray: () => toFlatArray(a, b),\r\n    toSvgString: () => toSvgString(a, b),\r\n    toPoints: () => [a, b],\r\n    rotate: () => (amountRadian:number, origin:Points.Point) => rotate(line, amountRadian, origin),\r\n    kind: `line`\r\n  });\r\n};\r\n\r\n/**\r\n * Returns a line that is rotated by `angleRad`. By default it rotates\r\n * around its center, but an arbitrary `origin` point can be provided.\r\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\r\n * \r\n * ```js\r\n * // Rotates line by 0.1 radians around point 10,10\r\n * rotate(line, 0.1, {x:10,y:10});\r\n * \r\n * // Rotate line by 5 degrees around its center\r\n * rotate(line, degreeToRadian(5));\r\n * \r\n * // Rotate line by 5 degres around its end point\r\n * rotate(line, degreeToRadian(5), line.b);\r\n * ```\r\n * @param line Line to rotate\r\n * @param amountRadian Angle in radians to rotate by\r\n * @param origin Point to rotate around. If undefined, middle of line will be used\r\n * @returns \r\n */\r\nexport const rotate = (line:Line, amountRadian?:number, origin?:Points.Point|number):Line => {\r\n  if (amountRadian === undefined || amountRadian === 0) return line;\r\n  if (origin === undefined) origin = 0.5;\r\n  if (typeof origin === `number`) {\r\n    guardPercent(origin, `origin`);\r\n    origin = interpolate(origin, line.a, line.b);\r\n  }\r\n  return {\r\n    a: Points.rotate(line.a, amountRadian, origin),\r\n    b: Points.rotate(line.b, amountRadian, origin)\r\n  };\r\n};","import {Bezier as BezierLib} from 'bezier-js';\r\nimport {Paths, Points, Rects, Lines} from './index.js';\r\n\r\nexport type QuadraticBezier = {\r\n  readonly a: Points.Point,\r\n  readonly b: Points.Point,\r\n  readonly quadratic: Points.Point\r\n}\r\n\r\nexport type QuadraticBezierPath = Paths.Path & QuadraticBezier;\r\nexport type CubicBezier = {\r\n  readonly a: Points.Point,\r\n  readonly b: Points.Point,\r\n  readonly cubic1: Points.Point,\r\n  readonly cubic2: Points.Point,\r\n}\r\n\r\nexport type CubicBezierPath = Paths.Path & CubicBezier;\r\n\r\nexport const isQuadraticBezier = (path: Paths.Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\r\nexport const isCubicBezier = (path: Paths.Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\r\n\r\n/**\r\n * Returns a new quadratic bezier with specified bend amount\r\n *\r\n * @param {QuadraticBezier} b Curve\r\n * @param {number} [bend=0] Bend amount, from -1 to 1\r\n * @returns {QuadraticBezier}\r\n */\r\nexport const quadraticBend = (a:Points.Point, b: Points.Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\r\n\r\n/**\r\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\r\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve\r\n * @param {Points.Point} start Start of curve\r\n * @param {Points.Point} end End of curve\r\n * @param {number} [bend=0] Bend amount, -1 to 1\r\n * @returns {QuadraticBezier}\r\n */\r\nexport const quadraticSimple = (start: Points.Point, end: Points.Point, bend = 0): QuadraticBezier => {\r\n  if (isNaN(bend)) throw Error(`bend is NaN`);\r\n  if (bend < -1 || bend > 1) throw Error(`Expects bend range of -1 to 1`);\r\n\r\n  const middle = Lines.interpolate(0.5, start, end);\r\n  // eslint-disable-next-line functional/no-let\r\n  let target = middle;\r\n  if (end.y < start.y) {\r\n    // Upward slope\r\n    target = bend > 0 ? {x: Math.min(start.x, end.x), y: Math.min(start.y, end.y)} :\r\n      {x: Math.max(start.x, end.x), y: Math.max(start.y, end.y)};\r\n  } else {\r\n    // Downward slope\r\n    target = bend > 0 ? {x: Math.max(start.x, end.x), y: Math.min(start.y, end.y)} :\r\n      {x: Math.min(start.x, end.x), y: Math.max(start.y, end.y)};\r\n  }\r\n\r\n  const handle = Lines.interpolate(Math.abs(bend), middle, target,);\r\n  return quadratic(start, end, handle);\r\n};\r\n\r\n/**\r\n * Returns a relative point on a simple quadratic \r\n * @param start Start\r\n * @param end  End\r\n * @param bend Bend (-1 to 1)\r\n * @param amt Amount\r\n * @returns Point\r\n */\r\nexport const computeQuadraticSimple = (start: Points.Point, end: Points.Point, bend: number, amt:number):Points.Point => {\r\n  const q = quadraticSimple(start, end, bend);\r\n  const bzr = new BezierLib(q.a, q.quadratic, q.b);\r\n  return bzr.compute(amt);\r\n};\r\n\r\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\r\nexport const quadraticToSvgString = (start: Points.Point, end: Points.Point, handle: Points.Point): readonly string[] => [`M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`];\r\n\r\nexport const toPath = (cubicOrQuadratic:CubicBezier|QuadraticBezier): CubicBezierPath|QuadraticBezierPath => {\r\n  if (isCubicBezier(cubicOrQuadratic)) {\r\n    return cubicToPath(cubicOrQuadratic);\r\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\r\n    return quadratictoPath(cubicOrQuadratic);\r\n  } else {\r\n    throw new Error(`Unknown bezier type`);\r\n  }\r\n};\r\n\r\nexport const cubic = (start:Points.Point, end:Points.Point, cubic1:Points.Point, cubic2:Points.Point): CubicBezier => (\r\n  {\r\n    a: Object.freeze(start),\r\n    b: Object.freeze(end),\r\n    cubic1: Object.freeze(cubic1),\r\n    cubic2: Object.freeze(cubic2) \r\n  });\r\n\r\nconst cubicToPath = (cubic:CubicBezier): CubicBezierPath => {\r\n  const {a, cubic1, cubic2, b} = cubic;\r\n\r\n  const bzr = new BezierLib(a, cubic1, cubic2, b);\r\n  return Object.freeze({\r\n    ...cubic,\r\n    length: () => bzr.length(),\r\n    interpolate: (t: number) => bzr.compute(t),\r\n    bbox: () => {\r\n      const {x, y} = bzr.bbox();\r\n      const xSize = x.size;\r\n      const ySize = y.size;\r\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n\r\n      return Rects.fromTopLeft({x: x.min, y: y.min}, xSize, ySize);\r\n    },\r\n    toString: () => bzr.toString(),\r\n    toSvgString: () => [`brrup`],\r\n    kind: `bezier/cubic`\r\n  });\r\n};\r\n\r\nexport const quadratic = (start: Points.Point, end: Points.Point, handle: Points.Point): QuadraticBezier => ({\r\n  a: Object.freeze(start),\r\n  b: Object.freeze(end),\r\n  quadratic: Object.freeze(handle)\r\n});\r\n\r\n\r\nconst quadratictoPath = (quadraticBezier:QuadraticBezier): QuadraticBezierPath => {\r\n  const {a, b, quadratic} = quadraticBezier;\r\n  const bzr = new BezierLib(a, quadratic, b);\r\n  return Object.freeze({\r\n    ...quadraticBezier,\r\n    length: () => bzr.length(),\r\n    interpolate: (t: number) => bzr.compute(t),\r\n    bbox: () => {\r\n      const {x, y} = bzr.bbox();\r\n      const xSize = x.size;\r\n      const ySize = y.size;\r\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      return Rects.fromTopLeft({x: x.min, y: y.min}, xSize, ySize);\r\n    },\r\n    toString: () => bzr.toString(),\r\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\r\n    kind: `bezier/quadratic`\r\n  });\r\n};\r\n\r\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import {guard as guardPoint} from './Point.js';\r\nimport {Path} from './Path.js';\r\nimport {Line} from './Line.js';\r\nimport {Points, Rects} from  './index.js';\r\n\r\nconst piPi = Math.PI *2;\r\n\r\n/**\r\n * A circle\r\n */\r\nexport type Circle = {\r\n  readonly radius: number\r\n}\r\n\r\n/**\r\n * A {@link Circle} with position\r\n */\r\nexport type CirclePositioned = Points.Point & Circle;\r\n\r\n\r\nexport type CircularPath = Circle & Path & {\r\n  readonly kind: `circular`\r\n};\r\n\r\n/**\r\n * Returns true if parameter has x,y\r\n * @param p Circle or point\r\n * @returns \r\n */\r\nexport const isPositioned = (p: Circle | Points.Point): p is Points.Point => (p as Points.Point).x !== undefined && (p as Points.Point).y !== undefined;\r\n\r\nexport const isCircle = (p: Circle|CirclePositioned|number): p is Circle => (p as Circle).radius !== undefined;\r\n\r\n\r\n/**\r\n * Returns a point on a circle at a specified angle in radians\r\n * @param circle\r\n * @param angleRadian Angle in radians\r\n * @param Origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\r\n * @returns Point oo circle\r\n */\r\nexport const point = (circle:Circle|CirclePositioned, angleRadian:number, origin?:Points.Point): Points.Point => {\r\n  if (origin === undefined) {\r\n    if (isPositioned(circle)) {\r\n      origin = circle;\r\n    } else {\r\n      origin = {x:0, y:0};\r\n    }\r\n  }\r\n  return {\r\n    x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\r\n    y: (Math.sin(-angleRadian) * circle.radius) + origin.y\r\n  };\r\n};\r\n\r\nconst guard = (circle:CirclePositioned|Circle) => {\r\n  if (isPositioned(circle)) {\r\n    guardPoint(circle, `circle`);\r\n  }\r\n\r\n  if (Number.isNaN(circle.radius)) throw new Error(`Radius is NaN`);\r\n  if (circle.radius <= 0) throw new Error(`Radius must be greater than zero`);\r\n};\r\n\r\n\r\n/**\r\n * Computes relative position along circle\r\n * @param circle \r\n * @param t Position, 0-1\r\n * @returns \r\n */\r\nexport const interpolate = (circle:CirclePositioned, t:number):Points.Point => point(circle, t*piPi);\r\n\r\n/**\r\n * Returns circumference of circle\r\n * @param circle \r\n * @returns \r\n */\r\nexport const length = (circle:Circle):number => piPi*circle.radius;\r\n\r\n/**\r\n * Computes a bounding box that encloses circle\r\n * @param circle\r\n * @returns \r\n */\r\nexport const bbox = (circle:CirclePositioned|Circle):Rects.RectPositioned|Rects.Rect => {\r\n  if (isPositioned(circle)) {\r\n    return Rects.fromCenter(circle, circle.radius*2, circle.radius*2);\r\n  } else {\r\n    return {width: circle.radius*2, height: circle.radius*2};\r\n  }\r\n};\r\n\r\n/**\r\n * Returns true if `b` is completely contained by `a`\r\n *\r\n * @param a\r\n * @param b\r\n * @returns\r\n */\r\nexport const isContainedBy = (a:CirclePositioned, b:CirclePositioned):boolean => {\r\n  const d = distanceCenter(a, b);\r\n  return (d < Math.abs(a.radius - b.radius));\r\n};\r\n\r\n/**\r\n * Returns true if a or b overlap or are equal\r\n * \r\n * Use `intersections` to find the points of intersection\r\n *\r\n * @param a\r\n * @param b\r\n * @returns True if circle overlap\r\n */\r\nexport const isIntersecting = (a:CirclePositioned, b:CirclePositioned):boolean => {\r\n  if (isEquals(a, b)) return true;\r\n  if (isContainedBy(a, b)) return true;\r\n  return intersections(a, b).length === 2;\r\n};\r\n\r\n/**\r\n * Returns the points of intersection betweeen `a` and `b`.\r\n * \r\n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\r\n *\r\n * @param a Circle\r\n * @param b Circle\r\n * @returns Points of intersection, or an empty list if there are none\r\n */\r\nexport const intersections = (a:CirclePositioned, b:CirclePositioned):readonly Points.Point[] => {\r\n  const vector = Points.subtract(b, a);\r\n  const centerD = Math.sqrt((vector.y*vector.y) + (vector.x*vector.x));\r\n\r\n  // Do not intersect\r\n  if (centerD > a.radius + b.radius) return [];\r\n\r\n  // Circle contains another\r\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\r\n\r\n  // Circles are the same\r\n  if (isEquals(a, b)) return [];\r\n\r\n  const centroidD = ((a.radius*a.radius) - (b.radius*b.radius) + (centerD*centerD)) / (2.0 * centerD);\r\n  const centroid = {\r\n    x: a.x + (vector.x * centroidD / centerD),\r\n    y: a.y + (vector.y * centroidD / centerD)\r\n  };\r\n\r\n  const centroidIntersectionD = Math.sqrt((a.radius*a.radius) - (centroidD*centroidD));\r\n\r\n  const intersection =  {\r\n    x: -vector.y * (centroidIntersectionD/centerD),\r\n    y: vector.x * (centroidIntersectionD/centerD)\r\n  };\r\n  return [\r\n    Points.sum(centroid, intersection),\r\n    Points.subtract(centroid, intersection)\r\n  ];\r\n};\r\n\r\n/**\r\n * Returns true if the two objects have the same values\r\n *\r\n * @param a\r\n * @param b\r\n * @returns\r\n */\r\nexport const isEquals = (a:CirclePositioned|Circle, b:CirclePositioned|Circle):boolean => {\r\n  if (a.radius !== b.radius) return false;\r\n\r\n  if (isPositioned(a) && isPositioned(b)) {\r\n    if (a.x !== b.x) return false;\r\n    if (a.y !== b.y) return false;\r\n    if (a.z !== b.z) return false;\r\n    return true;\r\n  } else if (!isPositioned(a) && !isPositioned(b)) {\r\n    // no-op\r\n  } else return false; // one is positioned one not\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns the distance between two circle centers\r\n * @param a \r\n * @param b \r\n * @returns \r\n */\r\nexport const distanceCenter = (a:CirclePositioned, b:CirclePositioned):number => Points.distance(a, b);\r\n\r\ntype ToSvg = {\r\n  (radius:number, sweep:boolean, origin:Points.Point): readonly string[];\r\n  (circle:Circle, sweep:boolean, origin:Points.Point): readonly string[];\r\n  (circle:CirclePositioned, sweep:boolean): readonly string[];\r\n};\r\n\r\n\r\n/**\r\n * Creates a SVG path segment.\r\n * @param a Circle or radius\r\n * @param sweep If true, path is 'outward'\r\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\r\n * @returns \r\n */\r\nexport const toSvg:ToSvg = (a:CirclePositioned|number|Circle, sweep:boolean, origin?:Points.Point):readonly string[] => {\r\n  if (isCircle(a)) {\r\n    if (origin !== undefined) {\r\n      return toSvgFull(a.radius, origin, sweep);\r\n    }\r\n    if (isPositioned(a)) {\r\n      return toSvgFull(a.radius, a, sweep);\r\n    } else throw new Error(`origin parameter needed for non-positioned circle`);\r\n  } else {\r\n    if (origin !== undefined) {\r\n      return toSvgFull(a, origin, sweep);\r\n    } else throw new Error(`origin parameter needed`);\r\n  }  \r\n};\r\n\r\nconst toSvgFull = (radius:number, origin:Points.Point, sweep:boolean):readonly string[] => {\r\n  // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\r\n  const {x, y} = origin;\r\n  const s = sweep ? `1` :`0`;\r\n  return `\r\n    M ${x}, ${y}\r\n    m -${radius}, 0\r\n    a ${radius},${radius} 0 1,${s} ${radius*2},0\r\n    a ${radius},${radius} 0 1,${s} -${radius*2},0\r\n  `.split(`\\n`);\r\n};\r\n\r\n/**\r\n * Returns a `CircularPath` representation of a circle\r\n *\r\n * @param {CirclePositioned} circle\r\n * @returns {CircularPath}\r\n */\r\nexport const toPath = (circle:CirclePositioned): CircularPath => {\r\n  guard(circle);\r\n\r\n  return Object.freeze({\r\n    ...circle,\r\n    /**\r\n     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\r\n     * @param {t} Relative (0.0-1.0) point\r\n     * @returns {Point} X,y\r\n     */\r\n    interpolate: (t:number) => interpolate(circle, t),\r\n    bbox:() => bbox(circle) as Rects.RectPositioned,\r\n    length: () => length(circle),\r\n    toSvgString: (sweep = true) => toSvg(circle, sweep),\r\n    kind: `circular`\r\n  });\r\n};\r\n\r\n/**\r\n * Returns the point(s) of intersection between a circle and line.\r\n * @param circle \r\n * @param line \r\n * @returns Point(s) of intersection, or empty array\r\n */\r\nexport const intersectionLine = (circle:CirclePositioned, line:Line): readonly Points.Point[] => {\r\n  const v1 = {\r\n    x: line.b.x - line.a.x,\r\n    y: line.b.y - line.a.y\r\n  };\r\n  const v2 = {\r\n    x: line.a.x - circle.x,\r\n    y: line.a.y - circle.y\r\n  };\r\n\r\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\r\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\r\n  \r\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\r\n  if(isNaN(d)) return []; // no intercept\r\n\r\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\r\n  const u2 = (b + d) / c;    \r\n\r\n  const ret = [];\r\n  if(u1 <= 1 && u1 >= 0) {  // add point if on the line segment\r\n    //eslint-disable-next-line functional/immutable-data\r\n    ret.push({ \r\n      x: line.a.x + v1.x * u1,\r\n      y: line.a.y + v1.y * u1\r\n    });\r\n  }\r\n  if(u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\r\n    //eslint-disable-next-line functional/immutable-data\r\n    ret.push({\r\n      x: line.a.x + v1.x * u2,\r\n      y: line.a.y + v1.y * u2\r\n    });\r\n  }       \r\n  return ret;\r\n};","import {Points, Paths, Rects} from './index.js';\r\n\r\nexport type CompoundPath = Paths.Path & {\r\n  readonly segments: readonly Paths.Path[]\r\n  readonly kind: `compound`\r\n};\r\n\r\n/**\r\n * Returns a new compoundpath, replacing a path at a given index\r\n *\r\n * @param {CompoundPath} compoundPath Existing compoundpath\r\n * @param {number} index Index to replace at\r\n * @param {Paths.Path} path Path to substitute in\r\n * @returns {CompoundPath} New compoundpath\r\n */\r\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Paths.Path): CompoundPath => {\r\n  const existing = [...compoundPath.segments];\r\n  //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\r\n  existing[index] = path;\r\n  return fromPaths(...existing);\r\n};\r\n\r\n/**\r\n * Computes x,y point at a relative position along compoundpath\r\n *\r\n * @param {Paths.Path[]} paths Combined paths (assumes contiguous)\r\n * @param {number} t Position (given as a percentage from 0 to 1)\r\n * @param {boolean} [useWidth] If true, widths are used for calulcating. If false, lengths are used\r\n * @param {Dimensions} [dimensions] Precalculated dimensions of paths, will be computed if omitted\r\n * @returns\r\n */\r\nexport const interpolate = (paths: readonly Paths.Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => {\r\n  if (dimensions === undefined) {\r\n    dimensions = computeDimensions(paths);\r\n  }\r\n\r\n  // Expected value to land on\r\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\r\n  //eslint-disable-next-line functional/no-let\r\n  let soFar = 0;\r\n\r\n  // Use widths or lengths?\r\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 0; i < l.length; i++) {\r\n    if (soFar + l[i] >= expected) {\r\n      const relative = expected - soFar;\r\n      //eslint-disable-next-line functional/no-let\r\n      let amt = relative / l[i];\r\n      //eslint-disable-next-line functional/no-let\r\n      if (amt > 1) amt = 1;\r\n      return paths[i].interpolate(amt);\r\n    } else soFar += l[i];\r\n  }\r\n  return {x: 0, y: 0};\r\n};\r\n\r\ntype Dimensions = {\r\n  /**\r\n   * Width of each path (based on bounding box)\r\n   *\r\n   * @type {number[]}\r\n   */\r\n  readonly widths: readonly number[],\r\n  /**\r\n   * Length of each path\r\n   *\r\n   * @type {number[]}\r\n   */\r\n   readonly lengths: readonly number[],\r\n\r\n  /**\r\n   * Total length of all paths\r\n   *\r\n   * @type {number}\r\n   */\r\n   readonly totalLength: number,\r\n  /**\r\n   * Total width of all paths\r\n   *\r\n   * @type {number}\r\n   */\r\n   readonly totalWidth: number\r\n}\r\n/**\r\n * Computes the widths and lengths of all paths, adding them up as well\r\n *\r\n * @param {Paths.Path[]} paths\r\n * @returns {Dimensions}\r\n */\r\nexport const computeDimensions = (paths: readonly Paths.Path[]): Dimensions => {\r\n  const widths = paths.map(l => l.bbox().width);\r\n  const lengths = paths.map(l => l.length());\r\n  //eslint-disable-next-line functional/no-let\r\n  let totalLength = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let totalWidth = 0;\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 0; i < lengths.length; i++) totalLength += lengths[i];\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 0; i < widths.length; i++) totalWidth += widths[i];\r\n\r\n  return {totalLength, totalWidth, widths, lengths};\r\n};\r\n\r\n/**\r\n * Computes the bounding box that encloses entire compoundpath\r\n *\r\n * @param {Paths.Path[]} paths\r\n * \r\n * @returns {Rects.Rect}\r\n */\r\nexport const bbox = (paths: readonly Paths.Path[]): Rects.RectPositioned => {\r\n  const boxes = paths.map(p => p.bbox());\r\n  const corners = boxes.map(b => Rects.getCorners(b)).flat();\r\n  \r\n  return Points.bbox(...corners);\r\n};\r\n\r\n/**\r\n * Produce a human-friendly representation of paths\r\n *\r\n * @param {Paths.Path[]} paths\r\n * @returns {string}\r\n */\r\nexport const toString = (paths: readonly Paths.Path[]): string => paths.map(p => p.toString()).join(`, `);\r\n\r\n/**\r\n * Throws an error if paths are not connected together, in order\r\n *\r\n * @param {Paths.Path[]} paths\r\n */\r\nexport const guardContinuous = (paths: readonly Paths.Path[]) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let lastPos = Paths.getEnd(paths[0]);\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 1; i < paths.length; i++) {\r\n    const start = Paths.getStart(paths[i]);\r\n    if (!Points.equals(start, lastPos)) throw new Error(`Path index ` + i + ` does not start at prior path end. Start: ` + start.x + `,` + start.y + ` expected: ` + lastPos.x + `,` + lastPos.y + ``);\r\n    lastPos = Paths.getEnd(paths[i]);\r\n  }\r\n};\r\n\r\nexport const toSvgString = (paths: readonly Paths.Path[]): readonly string[] => paths.flatMap(p => p.toSvgString());\r\n\r\n/**\r\n * Create a compoundpath from an array of paths.\r\n * All this does is verify they are connected, and precomputes dimensions\r\n *\r\n * @param {...Paths.Path[]} paths\r\n * @returns {CompoundPath}\r\n */\r\nexport const fromPaths = (...paths: readonly Paths.Path[]): CompoundPath => {\r\n  guardContinuous(paths); // Throws an error if paths are not connected\r\n  const dims = computeDimensions(paths);\r\n\r\n  return Object.freeze({\r\n    segments: paths,\r\n    length: () => dims.totalLength,\r\n    interpolate: (t: number, useWidth = false) => interpolate(paths, t, useWidth, dims),\r\n    bbox: () => bbox(paths),\r\n    toString: () => toString(paths),\r\n    toSvgString: () => toSvgString(paths),\r\n    kind: `compound`\r\n  });\r\n};\r\n","import {Rects, Points} from './index.js';\r\nimport {integer as guardInteger} from '../Guards.js';\r\nimport {clampIndex} from \"../Util.js\";\r\nimport {randomElement} from '../collections/Arrays.js';\r\nimport {SetMutable} from '../collections/Interfaces.js';\r\nimport {setMutable, } from \"../collections/Set.js\";\r\nimport {zipKeyValue} from \"../collections/Map.js\";\r\n\r\nexport type GridVisual = Readonly<{\r\n  readonly size: number,\r\n}>\r\n\r\nexport type Grid = Readonly<{\r\n  readonly rows: number\r\n  readonly cols: number\r\n}>;\r\n\r\nexport type Cell = Readonly<{\r\n  readonly x: number\r\n  readonly y: number\r\n}>;\r\n\r\nexport type Neighbours = Readonly<{\r\n  readonly n: Cell | undefined,\r\n  readonly e: Cell | undefined,\r\n  readonly s: Cell | undefined,\r\n  readonly w: Cell | undefined,\r\n  readonly ne: Cell | undefined,\r\n  readonly nw: Cell | undefined,\r\n  readonly se: Cell | undefined,\r\n  readonly sw: Cell | undefined\r\n}>\r\n\r\nexport type CardinalDirection = `` | `n` | `ne` | `e` | `se` | `s` | `sw` | `w` | `nw`;\r\n\r\nexport type BoundsLogic = `unbounded` | `undefined` | `stop` | `wrap`;\r\n\r\ntype VisitorLogic = {\r\n  readonly options?: IdentifyNeighbours;\r\n  readonly select: NeighbourSelector\r\n}\r\nexport type VisitGenerator = Generator<Readonly<Cell>, void, unknown>\r\nexport type VisitorOpts = {\r\n  readonly visited?: SetMutable<Cell>\r\n  readonly reversed?: boolean\r\n  readonly debug?: boolean\r\n}\r\nexport type Visitor = (grid: Grid, start: Cell, opts?: VisitorOpts) => VisitGenerator;\r\n\r\nexport type NeighbourMaybe = readonly [keyof Neighbours, Cell | undefined];\r\nexport type Neighbour = readonly [keyof Neighbours, Cell];\r\ntype NeighbourSelector = (neighbours: ReadonlyArray<Neighbour>) => Neighbour | undefined;\r\ntype IdentifyNeighbours = (grid: Grid, origin: Cell) => ReadonlyArray<Neighbour>;\r\n\r\n/**\r\n * Returns true if `cell` parameter is a cell with x,y fields.\r\n * Does not check validity of fields.\r\n *\r\n * @param cell\r\n * @return True if parameter is a cell\r\n */\r\nconst isCell = (cell: Cell | undefined): cell is Cell => {\r\n  if (cell === undefined) return false;\r\n  return (`x` in cell && `y` in cell);\r\n};\r\n\r\n/**\r\n * Returns true if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\r\n *\r\n * @param n\r\n * @return\r\n */\r\nconst isNeighbour = (n: Neighbour | NeighbourMaybe | undefined): n is Neighbour => {\r\n  if (n === undefined) return false;\r\n  if (n[1] === undefined) return false;\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns _true_ if grids `a` and `b` are equal in value\r\n *\r\n * @param a\r\n * @param b\r\n * @return\r\n */\r\nexport const isEqual = (a: Grid | GridVisual, b: Grid | GridVisual): boolean => {\r\n  if (`rows` in a && `cols` in a) {\r\n    if (`rows` in b && `cols` in b) {\r\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\r\n    } else return false;\r\n  }\r\n  if (`size` in a) {\r\n    if (`size` in b) {\r\n      if (a.size !== b.size) return false;\r\n    } else return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns a key string for a cell instance\r\n * A key string allows comparison of instances by value rather than reference\r\n * @param v\r\n * @returns\r\n */\r\nexport const cellKeyString = (v: Cell): string => `Cell{${v.x},${v.y}}`;\r\n\r\n/**\r\n * Returns true if two cells equal. Returns false if either cell (or both) are undefined\r\n *\r\n * @param a\r\n * @param b\r\n * @returns\r\n */\r\nexport const cellEquals = (a: Cell, b: Cell): boolean => {\r\n  if (b === undefined) return false;\r\n  if (a === undefined) return false;\r\n  return a.x === b.x && a.y === b.y;\r\n};\r\n\r\n/**\r\n * Throws an exception if any of the cell's parameters are invalid\r\n * @private\r\n * @param cell \r\n * @param paramName \r\n * @param grid \r\n */\r\nexport const guardCell = (cell: Cell, paramName: string = `Param`, grid?: Grid) => {\r\n  if (cell === undefined) throw new Error(paramName + ` is undefined. Expecting {x,y}`);\r\n  if (cell.x === undefined) throw new Error(paramName + `.x is undefined`);\r\n  if (cell.y === undefined) throw new Error(paramName + `.y is undefined`);\r\n  if (!Number.isInteger(cell.x)) throw new Error(paramName + `.x is non-integer`);\r\n  if (!Number.isInteger(cell.y)) throw new Error(paramName + `.y is non-integer`);\r\n  if (grid !== undefined) {\r\n    if (!inside(grid, cell)) throw new Error(`${paramName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid.cols}, ${grid.rows}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Throws an exception if any of the grid's parameters are invalid\r\n * @param grid\r\n * @param paramName \r\n */\r\nconst guardGrid = (grid: Grid, paramName: string = `Param`) => {\r\n  if (grid === undefined) throw new Error(`${paramName} is undefined. Expecting grid.`);\r\n  if (!(`rows` in grid)) throw new Error(`${paramName}.rows is undefined`);\r\n  if (!(`cols` in grid)) throw new Error(`${paramName}.cols is undefined`);\r\n\r\n  if (!Number.isInteger(grid.rows)) throw new Error(`${paramName}.rows is not an integer`);\r\n  if (!Number.isInteger(grid.cols)) throw new Error(`${paramName}.cols is not an integer`);\r\n};\r\n\r\n/**\r\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\r\n *\r\n * @param grid\r\n * @param cell\r\n * @return\r\n */\r\nexport const inside = (grid: Grid, cell: Cell): boolean => {\r\n  if (cell.x < 0 || cell.y < 0) return false;\r\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\r\n  return true;\r\n};\r\n/**\r\n * Returns a visual rectangle of the cell, positioned from the top-left corner\r\n *\r\n * @param cell\r\n * @param grid\r\n * @return\r\n */\r\nexport const rectangleForCell = (cell: Cell, grid: Grid & GridVisual): Rects.RectPositioned => {\r\n  guardCell(cell);\r\n  const size = grid.size;\r\n  const x = cell.x * size;\r\n  const y = cell.y * size;\r\n  const r = Rects.fromTopLeft({x: x, y: y}, size, size);\r\n  return r;\r\n};\r\n\r\n/**\r\n * Returns the cell at a specified visual coordinate\r\n *\r\n * @param position Position, eg in pixels\r\n * @param grid Grid\r\n * @return Cell at position or undefined if outside of the grid\r\n */\r\nexport const cellAtPoint = (position: Points.Point, grid: Grid & GridVisual): Cell | undefined => {\r\n  const size = grid.size;\r\n  if (position.x < 0 || position.y < 0) return;\r\n  const x = Math.floor(position.x / size);\r\n  const y = Math.floor(position.y / size);\r\n  if (x >= grid.cols) return;\r\n  if (y >= grid.rows) return;\r\n  return {x, y};\r\n};\r\n\r\n/**\r\n * Returns a list of all cardinal directions\r\n */\r\nexport const allDirections = Object.freeze([`n`, `ne`, `nw`, `e`, `s`, `se`, `sw`, `w`]) as ReadonlyArray<CardinalDirection>;\r\n\r\n/**\r\n * Returns a list of + shaped directions (ie. excluding diaganol)\r\n */\r\nexport const crossDirections = Object.freeze([`n`, `e`, `s`, `w`]) as ReadonlyArray<CardinalDirection>;\r\n\r\n/**\r\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to all.\r\n * \r\n * ```js\r\n * const n = neighbours = ({rows: 5, cols: 5}, {x:2, y:2} `wrap`);\r\n * {\r\n *  n: {x: 2, y: 1}\r\n *  s: {x: 2, y: 3}\r\n *  ....\r\n * }\r\n * ```\r\n * @returns Returns a map of cells, keyed by cardinal direction\r\n * @param grid Grid\r\n * @param cell Cell\r\n * @param bounds How to handle edges of grid\r\n * @param directions Directions to return\r\n */\r\nexport const neighbours = (grid: Grid, cell: Cell, bounds: BoundsLogic = `undefined`, directions?: ReadonlyArray<CardinalDirection>): Neighbours => {\r\n  const dirs = directions ?? allDirections;\r\n  const points = dirs.map(c => offset(grid, cell, getVectorFromCardinal(c), bounds));\r\n  return zipKeyValue<Cell>(dirs, points) as Neighbours;\r\n};\r\n\r\n/**\r\n * Returns the visual midpoint of a cell (eg pixel coordinate)\r\n *\r\n * @param cell\r\n * @param grid\r\n * @return \r\n */\r\nexport const cellMiddle = (cell: Cell, grid: Grid & GridVisual): Points.Point => {\r\n  guardCell(cell);\r\n\r\n  const size = grid.size;\r\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\r\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\r\n  return Object.freeze({x: x + size / 2, y: y + size / 2});\r\n};\r\n\r\n/**\r\n * Returns the cells on the line of start and end, inclusive\r\n *\r\n * ```js\r\n * // Get cells that connect 0,0 and 10,10\r\n * const cells = getLine({x:0,y:0}, {x:10,y:10});\r\n * ```\r\n * \r\n * This function does not handle wrapped coordinates.\r\n * @param start Starting cell\r\n * @param end End cell\r\n * @returns\r\n */\r\nexport const getLine = (start: Cell, end: Cell): ReadonlyArray<Cell> => {\r\n  // https://stackoverflow.com/a/4672319\r\n  guardCell(start);\r\n  guardCell(end);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let startX = start.x;\r\n  // eslint-disable-next-line functional/no-let\r\n  let startY = start.y;\r\n  const dx = Math.abs(end.x - startX);\r\n  const dy = Math.abs(end.y - startY);\r\n  const sx = (startX < end.x) ? 1 : -1;\r\n  const sy = (startY < end.y) ? 1 : -1;\r\n  // eslint-disable-next-line functional/no-let\r\n  let err = dx - dy;\r\n\r\n  const cells = [];\r\n  // eslint-disable-next-line functional/no-loop-statement,no-constant-condition\r\n  while (true) {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    cells.push(Object.freeze({x: startX, y: startY}));\r\n    if (startX === end.x && startY === end.y) break;\r\n    const e2 = 2 * err;\r\n    if (e2 > -dy) {\r\n      err -= dy;\r\n      startX += sx;\r\n    }\r\n    if (e2 < dx) {\r\n      err += dx;\r\n      startY += sy;\r\n    }\r\n  }\r\n  return cells;\r\n};\r\n\r\n/**\r\n * Returns cells that correspond to the cardinal directions at a specified distance\r\n *\r\n * @param grid Grid\r\n * @param steps Distance\r\n * @param start Start poiint\r\n * @param bound Logic for if bounds of grid are exceeded\r\n * @returns Cells corresponding to cardinals\r\n */\r\nexport const offsetCardinals = (grid: Grid, start: Cell, steps: number, bounds: BoundsLogic = `stop`): Neighbours => {\r\n  guardGrid(grid, `grid`);\r\n  guardCell(start, `start`);\r\n  guardInteger(steps, `aboveZero`, `steps`);\r\n\r\n  const directions = allDirections;\r\n  const vectors = directions.map(d => getVectorFromCardinal(d, steps));\r\n  const cells = directions.map((d, i) => offset(grid, start, vectors[i], bounds));\r\n\r\n  return zipKeyValue(directions, cells) as Neighbours;\r\n};\r\n\r\n/**\r\n * Returns an {x,y} signed vector corresponding to the provided cardinal direction.\r\n * ```js\r\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\r\n * ```\r\n * \r\n * Optional `multiplier` can be applied to vector\r\n * ```js\r\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\r\n * ```\r\n * \r\n * Blank direction returns {x: 0, y: 0}\r\n * @param cardinal Direction\r\n * @param multiplier Multipler\r\n * @returns Signed vector in the form of {x,y}\r\n */\r\nexport const getVectorFromCardinal = (cardinal: CardinalDirection, multiplier: number = 1): Cell => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let v;\r\n  switch (cardinal) {\r\n  case `n`:\r\n    v = {x: 0, y: -1 * multiplier};\r\n    break;\r\n  case `ne`:\r\n    v = {x: 1 * multiplier, y: -1 * multiplier};\r\n    break;\r\n  case `e`:\r\n    v = {x: 1 * multiplier, y: 0};\r\n    break;\r\n  case `se`:\r\n    v = {x: 1 * multiplier, y: 1 * multiplier};\r\n    break;\r\n  case `s`:\r\n    v = {x: 0, y: 1 * multiplier};\r\n    break;\r\n  case `sw`:\r\n    v = {x: -1 * multiplier, y: 1 * multiplier};\r\n    break;\r\n  case `w`:\r\n    v = {x: -1 * multiplier, y: 0};\r\n    break;\r\n  case `nw`:\r\n    v = {x: -1 * multiplier, y: -1 * multiplier};\r\n    break;\r\n  default:\r\n    v = {x: 0, y: 0};\r\n  }\r\n  return Object.freeze(v);\r\n};\r\n\r\n/**\r\n * Returns a list of cells from `start` to `end`.\r\n * \r\n * Throws an error if start and end are not on same row or column.\r\n *\r\n * @param start Start cell\r\n * @param end end clel\r\n * @param endInclusive\r\n * @return Array of cells\r\n */\r\nexport const simpleLine = function (start: Cell, end: Cell, endInclusive: boolean = false): ReadonlyArray<Cell> {\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  const cells: Cell[] = [];\r\n  if (start.x === end.x) {\r\n    // Vertical\r\n    const lastY = endInclusive ? end.y + 1 : end.y;\r\n    // eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let y = start.y; y < lastY; y++) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      cells.push({x: start.x, y: y});\r\n    }\r\n  } else if (start.y === end.y) {\r\n    // Horizontal\r\n    const lastX = endInclusive ? end.x + 1 : end.x;\r\n    // eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let x = start.x; x < lastX; x++) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      cells.push({x: x, y: start.y});\r\n    }\r\n  } else {\r\n    throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);\r\n  }\r\n  return cells;\r\n};\r\n\r\n/**\r\n *\r\n * Returns a coordinate offset from `start` by `vector` amount.\r\n * \r\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\r\n * \r\n * \r\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift down a line \r\n * @param grid Grid to traverse\r\n * @param vector Offset in x/y\r\n * @param start Start point\r\n * @param bounds\r\n * @returns Cell\r\n */\r\nexport const offset = function (grid: Grid, start: Cell, vector: Cell, bounds: BoundsLogic = `undefined`): Cell | undefined {\r\n  guardCell(start, `start`, grid);\r\n  guardCell(vector);\r\n  guardGrid(grid, `grid`);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let x = start.x;\r\n  // eslint-disable-next-line functional/no-let\r\n  let y = start.y;\r\n  switch (bounds) {\r\n  case `wrap`:\r\n    x += vector.x % grid.cols;\r\n    y += vector.y % grid.rows;\r\n    if (x < 0) x = grid.cols + x;\r\n    else if (x >= grid.cols) {\r\n      x -= grid.cols;\r\n    }\r\n    if (y < 0) y = grid.rows + y;\r\n    else if (y >= grid.rows) {\r\n      y -= grid.rows;\r\n    }\r\n    break;\r\n  case `stop`:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    x = clampIndex(x, grid.cols);\r\n    y = clampIndex(y, grid.rows);\r\n    break;\r\n  case `undefined`:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    if (x < 0 || y < 0) return;\r\n    if (x >= grid.cols || y >= grid.rows) return;\r\n    break;\r\n  case `unbounded`:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    break;\r\n  default:\r\n    throw new Error(`Unknown BoundsLogic case ${bounds}`);\r\n  }\r\n  return Object.freeze({x, y});\r\n};\r\n\r\nconst neighbourList = (grid: Grid, cell: Cell, directions: ReadonlyArray<CardinalDirection>, bounds: BoundsLogic): ReadonlyArray<Neighbour> => {\r\n  // Get neighbours for cell\r\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\r\n\r\n  // Filter out undefined cells\r\n  const entries = Object.entries(cellNeighbours);\r\n  return (entries as Array<NeighbourMaybe>).filter(isNeighbour);\r\n};\r\n\r\n/**\r\n * Visits every cell in grid using supplied selection function\r\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\r\n * visitorColumn, visitorRow.\r\n * \r\n * Usage example:\r\n * ```js\r\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\r\n *  for (let cell of visitor) {\r\n *   // do something with cell\r\n *  }\r\n * ```\r\n *\r\n * If you want to keep tabs on the visitor, pass in a MutableValueSet. This is\r\n * updated with visited cells (and is used internally anyway)\r\n * ```js\r\n *  let visited = new mutableValueSet<Grids.Cell>(c => Grids.cellKeyString(c));\r\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\r\n * ```\r\n * \r\n * To visit with some delay, try this pattern\r\n * ```js\r\n *  const delayMs = 100;\r\n *  const run = () => {\r\n *   let cell = visitor.next().value;\r\n *   if (cell === undefined) return;\r\n *   // Do something with cell\r\n *   setTimeout(run, delayMs);\r\n *  }\r\n *  setTimeout(run, delayMs);\r\n * ```\r\n * @param {(neighbourSelect: NeighbourSelector} neighbourSelect Select neighbour to visit\r\n * @param {Grid} grid Grid to visit\r\n * @param {Cell} start Starting cell\r\n * @param {MutableStringSet<Cell>} [visited] Optional tracker of visited cells\r\n * @returns {Iterable<Cell>}\r\n */\r\n// eslint-disable-next-line functional/prefer-readonly-type\r\nexport const visitor = function* (\r\n  logic: VisitorLogic,\r\n  grid: Grid,\r\n  start: Cell,\r\n  opts: VisitorOpts = {}\r\n): VisitGenerator {\r\n\r\n  guardGrid(grid, `grid`);\r\n  guardCell(start, `start`, grid);\r\n\r\n\r\n  const v = opts.visited ?? setMutable<Cell>(c => cellKeyString(c));\r\n  const possibleNeighbours = logic.options ? logic.options : (g: Grid, c: Cell) => neighbourList(g, c, crossDirections, `undefined`);\r\n\r\n  if (!isCell(start)) throw new Error(`'start' parameter is undefined or not a cell`);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let cellQueue: Cell[] = [start];\r\n  // eslint-disable-next-line functional/no-let\r\n  let moveQueue: Neighbour[] = [];\r\n  // eslint-disable-next-line functional/no-let\r\n  let current: Cell | null = null;\r\n\r\n  // eslint-disable-next-line functional/no-loop-statement\r\n  while (cellQueue.length > 0) {\r\n    // console.log(`cell queue: ${cellQueue.length} move queue: ${moveQueue.length} current: ${JSON.stringify(current)}` );\r\n    if (current === null) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      const nv = cellQueue.pop();\r\n      if (nv === undefined) {\r\n        // console.log(`cellQueue drained`);\r\n        break;\r\n      }\r\n      current = nv;\r\n    }\r\n\r\n    if (!v.has(current)) {\r\n      v.add(current);\r\n      yield (current);\r\n\r\n      const nextSteps = possibleNeighbours(grid, current)\r\n        .filter(step => !v.has(step[1]));\r\n\r\n      if (nextSteps.length === 0) {\r\n        // No more moves for this cell\r\n        if (current !== null) {\r\n          cellQueue = cellQueue.filter(cq => cellEquals(cq, current as Cell));\r\n        }\r\n      } else {\r\n        // eslint-disable-next-line functional/immutable-data\r\n        moveQueue.push(...nextSteps);\r\n      }\r\n    }\r\n\r\n    // Remove steps already made\r\n    moveQueue = moveQueue.filter(step => !v.has(step[1]));\r\n\r\n    if (moveQueue.length === 0) {\r\n      // console.log(`moveQueue empty`);\r\n      current = null;\r\n    } else {\r\n      // Pick move\r\n      const potential = logic.select(moveQueue);\r\n      if (potential !== undefined) {\r\n        // eslint-disable-next-line functional/immutable-data\r\n        cellQueue.push(potential[1]);\r\n        current = potential[1];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) => visitor({\r\n  select: (nbos) => nbos[nbos.length - 1]\r\n},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nexport const visitorBreadth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) => visitor({\r\n  select: (nbos) => nbos[0]\r\n},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nconst randomNeighbour = (nbos: readonly Neighbour[]) => randomElement(nbos); // .filter(isNeighbour));\r\n\r\nexport const visitorRandomContiguous = (grid: Grid, start: Cell, opts: VisitorOpts = {}) => visitor({\r\n  select: randomNeighbour\r\n},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nexport const visitorRandom = (grid: Grid, start: Cell, opts: VisitorOpts = {}) => visitor({\r\n  options: (grid, cell) => {\r\n    const t: Neighbour[] = [];\r\n    // eslint-disable-next-line functional/no-loop-statement\r\n    for (const c of cells(grid, cell)) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      t.push([`n`, c]);\r\n    }\r\n    return t;\r\n  },\r\n  select: randomNeighbour\r\n},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nexport const visitorRow = (grid: Grid, start: Cell, opts: VisitorOpts = {}) => {\r\n  const {reversed = false} = opts;\r\n\r\n  const neighbourSelect = (nbos: readonly Neighbour[]) => nbos.find(n => n[0] === (reversed ? `w` : `e`));\r\n\r\n  const possibleNeighbours = (grid: Grid, cell: Cell): ReadonlyArray<Neighbour> => {\r\n    if (reversed) {\r\n      // WALKING BACKWARD ALONG RONG\r\n      if (cell.x > 0) {\r\n        // All fine, step to the left\r\n        cell = {x: cell.x - 1, y: cell.y};\r\n      } else {\r\n        // At the beginning of a row\r\n        if (cell.y > 0) {\r\n          // Wrap to next row up\r\n          cell = {x: grid.cols - 1, y: cell.y - 1};\r\n        } else {\r\n          // Wrap to end of grid\r\n          cell = {x: grid.cols - 1, y: grid.rows - 1};\r\n        }\r\n      }\r\n    } else {\r\n      /*\r\n       * WALKING FORWARD ALONG ROWS\r\n       * console.log(`${cell.x}, ${cell.y}`);\r\n       */\r\n      if (cell.x < grid.rows - 1) {\r\n        // All fine, step to the right\r\n        cell = {x: cell.x + 1, y: cell.y};\r\n      } else {\r\n        // At the end of a row\r\n        if (cell.y < grid.rows - 1) {\r\n          // More rows available, wrap to next row down\r\n          cell = {x: 0, y: cell.y + 1};\r\n        } else {\r\n          // No more rows available, wrap to start of the grid\r\n          cell = {x: 0, y: 0};\r\n        }\r\n      }\r\n    }\r\n    return [[(reversed ? `w` : `e`), cell]];\r\n  };\r\n\r\n  const logic: VisitorLogic = {\r\n    select: neighbourSelect,\r\n    options: possibleNeighbours\r\n  };\r\n\r\n  return visitor(logic, grid, start, opts);\r\n};\r\n\r\n/**\r\n * Runs the provided `visitor` for `steps`, returning the cell we end at\r\n * \r\n * ```js\r\n * // Get a cell 10 steps away (row-wise) from start\r\n * const cell = visitFor(grid, start, 10, visitorRow);\r\n * ```\r\n * @param grid Grid to traverse\r\n * @param start Start point\r\n * @param steps Number of steps\r\n * @param visitor Visitor function\r\n * @returns \r\n */\r\nexport const visitFor = (grid: Grid, start: Cell, steps: number, visitor: Visitor): Cell => {\r\n  guardInteger(steps, ``, `steps`);\r\n\r\n  const opts: VisitorOpts = {\r\n    reversed: steps < 0\r\n  };\r\n  steps = Math.abs(steps);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let c = start;\r\n  // eslint-disable-next-line functional/no-let\r\n  let v = visitor(grid, start, opts);\r\n  v.next(); // Burn up starting cell\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let stepsMade = 0;\r\n\r\n  // eslint-disable-next-line functional/no-loop-statement\r\n  while (stepsMade < steps) {\r\n    stepsMade++;\r\n    const {value} = v.next();\r\n    if (value) {\r\n      c = value;\r\n      if (opts.debug) console.log(`stepsMade: ${stepsMade} cell: ${c.x}, ${c.y} reverse: ${opts.reversed}`);\r\n    } else {\r\n      if (steps >= grid.cols * grid.rows) {\r\n        steps -= grid.cols * grid.rows;\r\n        stepsMade = 0;\r\n        v = visitor(grid, start, opts);\r\n        v.next();\r\n        c = start;\r\n        if (opts.debug) console.log(`resetting visitor to ${steps}`);\r\n      } else throw new Error(`Value not received by visitor`);\r\n    }\r\n  }\r\n  return c;\r\n};\r\n\r\n/**\r\n * Visits cells running down columns, left-to-right.\r\n * @param grid Grid to traverse\r\n * @param start Start cell\r\n * @param opts Options\r\n * @returns Visitor generator\r\n */\r\nexport const visitorColumn = (grid: Grid, start: Cell, opts: VisitorOpts = {}):VisitGenerator => {\r\n  const {reversed = false} = opts;\r\n  const logic: VisitorLogic = {\r\n    select: (nbos) => nbos.find(n => n[0] === (reversed ? `n` : `s`)),\r\n    options: (grid, cell): ReadonlyArray<Neighbour> => {\r\n      if (reversed) {\r\n        // WALK UP COLUMN, RIGHT-TO-LEFT\r\n        if (cell.y > 0) {\r\n          // Easy case\r\n          cell = {x: cell.x, y: cell.y - 1};\r\n        } else {\r\n          // Top of column\r\n          if (cell.x === 0) {\r\n            // Top-left corner, need to wrap\r\n            cell = {x: grid.cols - 1, y: grid.rows - 1};\r\n          } else {\r\n            cell = {x: cell.x - 1, y: grid.rows - 1};\r\n          }\r\n        }\r\n      } else {\r\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\r\n        if (cell.y < grid.rows - 1) {\r\n          // Easy case, move down by one\r\n          cell = {x: cell.x, y: cell.y + 1};\r\n        } else {\r\n          // End of column\r\n          if (cell.x < grid.cols - 1) {\r\n            // Move to next column and start at top\r\n            cell = {x: cell.x + 1, y: 0};\r\n          } else {\r\n            // Move to start of grid\r\n            cell = {x: 0, y: 0};\r\n          }\r\n        }\r\n      }\r\n      return [[reversed ? `n` : `s`, cell]];\r\n    }\r\n  };\r\n  return visitor(logic, grid, start, opts);\r\n};\r\n\r\n/**\r\n * Enumerate rows of grid, returning all the cells in the row\r\n * ```js\r\n * for (const row of Grid.rows(shape)) {\r\n *  // row is an array of Cells.\r\n * }\r\n * ```\r\n * @param grid \r\n * @param start \r\n */\r\nexport const rows = function* (grid: Grid, start: Cell = {x: 0, y: 0}) {\r\n  //eslint-disable-next-line functional/no-let\r\n  let row = start.y;\r\n  //eslint-disable-next-line functional/no-let\r\n  let rowCells: Cell[] = [];\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const c of cells(grid, start)) {\r\n    if (c.y !== row) {\r\n      yield rowCells;\r\n      rowCells = [c];\r\n      row = c.y;\r\n    } else {\r\n      //eslint-disable-next-line functional/immutable-data\r\n      rowCells.push(c);\r\n    }\r\n  }\r\n  if (rowCells.length > 0) yield rowCells;\r\n};\r\n\r\n/**\r\n * Enumerate all cells in an efficient manner. Runs left-to-right, top-to-bottom.\r\n * If end of grid is reached, iterator will wrap to ensure all are visited.\r\n *\r\n * @param {Grid} grid\r\n * @param {Cell} [start={x:0, y:0}]\r\n */\r\nexport const cells = function* (grid: Grid, start: Cell = {x: 0, y: 0}) {\r\n  guardGrid(grid, `grid`);\r\n  guardCell(start, `start`, grid);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let {x, y} = start;\r\n  // eslint-disable-next-line functional/no-let\r\n  let canMove = true;\r\n  // eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    yield {x, y};\r\n    x++;\r\n    if (x === grid.cols) {\r\n      y++;\r\n      x = 0;\r\n    }\r\n    if (y === grid.rows) {\r\n      y = 0;\r\n      x = 0;\r\n    }\r\n    if (x === start.x && y === start.y) canMove = false; // Complete\r\n  } while (canMove);\r\n};","import {Lines, Beziers, Rects, Points} from './index.js';\r\n\r\n//eslint-disable-next-line  functional/no-mixed-type\r\nexport type Path = {\r\n  length(): number\r\n  /**\r\n   * Returns a point at a relative (0.0-1.0) position along the path\r\n   *\r\n   * @param {number} t Relative position (0.0-1.0)\r\n   * @returns {Point} Point\r\n   */\r\n  interpolate(t: number): Points.Point\r\n  bbox(): Rects.RectPositioned\r\n  toString(): string\r\n  toSvgString(): readonly string[]\r\n  readonly kind: `compound` | `elliptical` | `circular` | `arc` | `bezier/cubic` | `bezier/quadratic` | `line`\r\n}\r\n/**\r\n * Return the start point of a path\r\n *\r\n * @param {Path} path\r\n * @return {*}  {Point}\r\n */\r\nexport const getStart = function (path: Path): Points.Point {\r\n  if (Beziers.isQuadraticBezier(path)) return path.a;\r\n  else if (Lines.isLine(path)) return path.a;\r\n  else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n};\r\n\r\n/**\r\n * Return the end point of a path\r\n *\r\n * @param {Path} path\r\n * @return {*}  {Point}\r\n */\r\nexport const getEnd = function (path: Path): Points.Point {\r\n  if (Beziers.isQuadraticBezier(path)) return path.b;\r\n  else if (Lines.isLine(path)) return path.b;\r\n  else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n};\r\n\r\nexport type WithBeziers = {\r\n  //eslint-disable-next-line  functional/no-method-signature\r\n  getBeziers(): readonly Path[]\r\n};","import {Points, Lines} from './index.js';\r\n\r\nexport type Rect = {\r\n  readonly width: number,\r\n  readonly height: number,\r\n}\r\nexport type RectPositioned = Points.Point & Rect;\r\n\r\nexport const fromElement = (el:HTMLElement): Rect => ({width: el.clientWidth, height: el.clientHeight});\r\n\r\nexport const isEqual = (a:Rect, b:Rect):boolean => a.width === b.width && a.height === b.height;\r\n\r\nexport const fromCenter = (origin: Points.Point, width: number, height: number): RectPositioned => {\r\n  Points.guard(origin, `origin`);\r\n\r\n  guardDim(width, `width`);\r\n  guardDim(height, `height`);\r\n\r\n  const halfW = width / 2;\r\n  const halfH = height / 2;\r\n  return {x: origin.x - halfW, y: origin.y - halfH, width: width, height: height};\r\n  // let pts = [];\r\n  // pts.push({x: origin.x - halfW, y: origin.y - halfH});\r\n  // pts.push({x: origin.x + halfW, y: origin.y - halfH});\r\n  // pts.push({x: origin.x + halfW, y: origin.y + halfH});\r\n  // pts.push({x: origin.x - halfW, y: origin.y + halfH});\r\n  //return rectFromPoints(...pts);\r\n};\r\n\r\n/**\r\n * Returns a rectangle based on provided four corners.\r\n * \r\n * To create a rectangle that contains an arbitary set of points, use {@links Points.bbox}.\r\n * \r\n * Does some sanity checking such as:\r\n *  - x will be smallest of topLeft/bottomLeft\r\n *  - y will be smallest of topRight/topLeft\r\n *  - width will be largest between top/bottom left and right\r\n *  - height will be largest between left and right top/bottom\r\n */\r\nexport const maxFromCorners = (topLeft:Points.Point, topRight:Points.Point, bottomRight:Points.Point, bottomLeft: Points.Point):RectPositioned => {\r\n  if (topLeft.y > bottomRight.y) throw new Error(`topLeft.y greater than bottomRight.y`);\r\n  if (topLeft.y > bottomLeft.y) throw new Error(`topLeft.y greater than bottomLeft.y`);\r\n\r\n  const w1  = topRight.x - topLeft.x;\r\n  const w2 = bottomRight.x - bottomLeft.x;\r\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\r\n  const h2 = Math.abs(bottomRight.y - topRight.y);\r\n  return {\r\n    x: Math.min(topLeft.x, bottomLeft.x),\r\n    y: Math.min(topRight.y, topLeft.y),\r\n    width: Math.max(w1, w2),\r\n    height: Math.max(h1, h2) \r\n  };\r\n};\r\n\r\nconst guardDim = (d: number, name: string = `Dimension`) => {\r\n  if (d === undefined) throw Error(`${name} is undefined`);\r\n  if (isNaN(d)) throw Error(`${name} is NaN`);\r\n  if (d < 0) throw Error(`${name} cannot be negative`);\r\n};\r\n\r\nexport const guard = (rect: Rect, name: string = `rect`) => {\r\n  if (rect === undefined) throw Error(`{$name} undefined`);\r\n  guardDim(rect.width, name + `.width`);\r\n  guardDim(rect.height, name + `.height`);\r\n};\r\n\r\nexport const fromTopLeft = (origin: Points.Point, width: number, height: number): RectPositioned => {\r\n  guardDim(width, `width`);\r\n  guardDim(height, `height`);\r\n  Points.guard(origin, `origin`);\r\n\r\n  return {x: origin.x, y: origin.y, width: width, height: height};\r\n  // let pts = [origin];\r\n  // pts.push({x: origin.x + width, y: origin.y});\r\n  // pts.push({x: origin.x + width, y: origin.y + height});\r\n  // pts.push({x: origin.x, y: origin.y + height});\r\n  // return rectFromPoints(...pts);\r\n};\r\n\r\nexport const getCorners = (rect: RectPositioned|Rect, origin?:Points.Point): readonly Points.Point[] => {\r\n  guard(rect);\r\n  if (origin === undefined && Points.isPoint(rect)) origin = rect;\r\n  else if (origin === undefined) throw new Error(`Unpositioned rect needs origin param`);\r\n\r\n  return [\r\n    {x: origin.x, y: origin.y},\r\n    {x: origin.x + rect.width, y: origin.y},\r\n    {x: origin.x + rect.width, y: origin.y + rect.height},\r\n    {x: origin.x, y: origin.y + rect.height}\r\n  ];\r\n};\r\n\r\nexport const getCenter = (rect: RectPositioned|Rect, origin?:Points.Point): Points.Point => {\r\n  guard(rect);\r\n  if (origin === undefined && Points.isPoint(rect)) origin = rect;\r\n  else if (origin === undefined) throw new Error(`Unpositioned rect needs origin param`);\r\n\r\n  return {\r\n    x: origin.x + rect.width / 2,\r\n    y: origin.y + rect.height / 2\r\n  };\r\n};\r\n\r\n/**\r\n * Returns four lines based on each corner.\r\n * Lines are given in order: top, right, bottom, left\r\n *\r\n * @param {(RectPositioned|Rect)} rect\r\n * @param {Points.Point} [origin]\r\n * @returns {Lines.Line[]}\r\n */\r\nexport const getLines = (rect: RectPositioned|Rect, origin?:Points.Point): readonly Lines.Line[] => Lines.joinPointsToLines(...getCorners(rect, origin));\r\n","import {Path} from './Path.js';\r\nimport {degreeToRadian, Points} from './index.js';\r\n\r\n/**\r\n * An ellipse\r\n */\r\nexport type Ellipse = {\r\n  readonly radiusX: number\r\n  readonly radiusY: number\r\n  /**\r\n   * Rotation, in radians\r\n   */\r\n  readonly rotation?:number\r\n  readonly startAngle?:number\r\n  readonly endAngle?:number\r\n}\r\n\r\n/**\r\n * A {@link Ellipse} with position\r\n */\r\nexport type EllipsePositioned = Points.Point & Ellipse\r\n\r\n\r\nexport const fromDegrees = (radiusX:number, radiusY:number, rotationDeg:number = 0, startAngleDeg:number = 0, endAngleDeg:number = 360):Ellipse => ({\r\n  radiusX, radiusY,\r\n  rotation: degreeToRadian(rotationDeg),\r\n  startAngle: degreeToRadian(startAngleDeg),\r\n  endAngle: degreeToRadian(endAngleDeg)\r\n});\r\n\r\nexport type EllipticalPath = Ellipse & Path & {\r\n  readonly kind: `elliptical`\r\n};","import {degreeToRadian} from \"./index.js\";\r\nimport * as Points from \"./Point.js\";\r\n\r\nexport type Coord = {\r\n  readonly distance: number,\r\n  readonly angleRadian: number\r\n}\r\n\r\ntype ToCartesian = {\r\n  (point:Coord, origin?:Points.Point) :Points.Point\r\n  (distance:number, angleRadians:number, origin?:Points.Point) :Points.Point\r\n}\r\n\r\nexport const isCoord = (p: number|unknown): p is Coord => {\r\n  if ((p as Coord).distance === undefined) return false;\r\n  if ((p as Coord).angleRadian === undefined) return false;\r\n  return true;\r\n};\r\n\r\nexport const fromCartesian = (point: Points.Point, origin: Points.Point): Coord => {\r\n  point = Points.subtract(point, origin);\r\n  //eslint-disable-next-line functional/no-let\r\n  //let a =  Math.atan2(point.y, point.x);\r\n  //if (a < 0) a = Math.abs(a);\r\n  //else a = Math.PI + (Math.PI - a);\r\n\r\n  return {\r\n    angleRadian: Math.atan2(point.y, point.x),\r\n    distance: Math.sqrt(point.x * point.x + point.y * point.y)\r\n  };\r\n};\r\n\r\nexport const toCartesian:ToCartesian = (a:Coord|number, b?:Points.Point|number, c?:Points.Point): Points.Point => {\r\n  if (isCoord(a)) {\r\n    if (b === undefined) b = Points.Empty;\r\n    if (!Points.isPoint(b)) throw new Error(`Expecting (Coord, Point). Point param wrong type.`);\r\n    return polarToCartesian(a.distance, a.angleRadian, b);\r\n  } else {\r\n    if (typeof a === `number` && typeof b === `number`) {\r\n      if (c === undefined) c = Points.Empty;\r\n      if (!Points.isPoint(c)) throw new Error(`Expecting (number, number, Point). Point param wrong type`);\r\n      return polarToCartesian(a, b, c);\r\n    } else {\r\n      throw new Error(`Expecting (number, number)`);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Produces an Archimedean spiral\r\n * \r\n * \r\n * This is a generator:\r\n * ```\r\n * const s = spiral(0.1, 1);\r\n * for (const coord of s) {\r\n *  // Use Polar coord...\r\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\r\n * }\r\n * ```\r\n * \r\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\r\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\r\n */\r\n//eslint-disable-next-line func-style\r\nexport function* spiral(smoothness:number, zoom:number): IterableIterator<Coord & {readonly step:number}> {\r\n  //eslint-disable-next-line functional/no-let\r\n  let step = 0;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (true) {\r\n    //eslint-disable-next-line functional/no-let\r\n    const a = smoothness * step++;\r\n    yield {\r\n      distance: zoom * a,\r\n      angleRadian: a,\r\n      step: step\r\n    };\r\n  }\r\n}\r\n\r\nexport const rotate = (c:Coord, amountRadian:number): Coord => ({\r\n  ...c,\r\n  angleRadian: c.angleRadian + amountRadian\r\n});\r\n\r\nexport const rotateDegrees = (c:Coord, amountDeg:number):Coord => ({\r\n  ...c,\r\n  angleRadian: c.angleRadian + degreeToRadian(amountDeg)\r\n});\r\n\r\n/**\r\n * Produces an Archimedian spiral with manual stepping.\r\n * @param step Step number. Typically 0, 1, 2 ...\r\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\r\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\r\n * @returns \r\n */\r\nexport const spiralRaw = (step:number, smoothness:number, zoom:number):Coord => {\r\n  const a = smoothness * step;\r\n  return {\r\n    distance: zoom * a,\r\n    angleRadian: a\r\n  };\r\n};\r\n\r\nconst polarToCartesian = (distance:number, angleRadians:number, origin:Points.Point):Points.Point => {\r\n  Points.guard(origin);\r\n  return {\r\n    x: origin.x + (distance * Math.cos(angleRadians)),\r\n    y: origin.y + (distance * Math.sin(angleRadians)),\r\n  };\r\n};\r\n\r\n\r\n"],"mappings":"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","names":[]}