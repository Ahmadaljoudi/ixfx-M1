{"version":3,"sources":["../src/collections/Arrays.ts","../src/util.ts","../src/collections/NumericArrays.ts"],"sourcesContent":["/**\r\n * Functions for working with primitive arrays, regardless of type\r\n * See Also: NumericArrays.ts\r\n */\r\n\r\nimport {IsEqual, isEqualDefault} from '../util.js';\r\n\r\nexport * from './NumericArrays.js';\r\n\r\n/**\r\n * Throws an error if `array` parameter is not a valid array\r\n * @private\r\n * @param array \r\n * @param paramName \r\n */\r\nexport const guardArray = <V>(array:ArrayLike<V>, paramName:string = `?`) => {\r\n  if (array === undefined) throw new Error(`Param '${paramName}' is undefined. Expected array.`);\r\n  if (array === null) throw new Error(`Param '${paramName}' is null. Expected array.`);\r\n  if (!Array.isArray(array)) throw new Error(`Param '${paramName}' not an array as expected`);\r\n};\r\n\r\n/**\r\n * Returns a random array index\r\n * @param array\r\n * @returns \r\n */\r\nexport const randomIndex = <V>(array: ArrayLike<V>): number => Math.floor(Math.random() * array.length);\r\n\r\n/**\r\n * Returns random element\r\n * @param array\r\n * @returns \r\n */\r\nexport const randomElement = <V>(array: ArrayLike<V>): V => {\r\n  guardArray(array, `array`);\r\n  return array[Math.floor(Math.random() * array.length)];\r\n};\r\n\r\n/**\r\n * Removes a random item from an array, returning both the item and the new array as a result.\r\n * Does not modify the original array unless `mutate` parameter is true.\r\n * \r\n * @example Without changing source\r\n * ```js\r\n * const data = [100, 20, 40];\r\n * const {value, array} = randomPluck(data);\r\n * // value: 20, array: [100, 40], data: [100, 20, 40];\r\n * ```\r\n *\r\n * @example Mutating source\r\n * ```js\r\n * const data = [100, 20, 40];\r\n * const {value} = randomPluck(data, true);\r\n * // value: 20, data: [100, 40];\r\n * ```\r\n * \r\n * @template V Type of array\r\n * @param array Array to pluck item from\r\n * @param mutate If _true_, changes input array. _False_ by default.\r\n * @return Returns an object `{value:V|undefined, array:V[]}`\r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const randomPluck = <V>(array:readonly V[], mutate = false):{readonly value:V|undefined, readonly array:Array<V> } => {\r\n  if (array === undefined) throw new Error(`array is undefined`);\r\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\r\n  if (array.length === 0) return {value: undefined, array: []};\r\n  const index = randomIndex(array);\r\n  if (mutate) {\r\n    return {\r\n      value: array[index],\r\n      //eslint-disable-next-line functional/immutable-data\r\n      array: array.splice(index, 1)\r\n    };\r\n  } else {\r\n    // Copy array, remove item from that\r\n    const t = [...array];\r\n    //eslint-disable-next-line functional/immutable-data\r\n    t.splice(index, 1);\r\n    return {\r\n      value: array[index],\r\n      array: t\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Returns a shuffled copy of the input array.\r\n * @example\r\n * ```js\r\n * const d = [1, 2, 3, 4];\r\n * const s = shuffle(d);\r\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\r\n * ```\r\n * @param dataToShuffle \r\n * @returns Copy with items moved around randomly\r\n * @template V Type of array items\r\n */\r\nexport const shuffle = <V>(dataToShuffle:ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const array = [...dataToShuffle];\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n};\r\n\r\n/**\r\n * Returns an array with a value omitted. If value is not found, result will be a copy of input.\r\n * Value checking is completed via the provided `comparer` function, or by default checking whether `a === b`.\r\n *\r\n * @example\r\n * ```js\r\n * const data = [100, 20, 40];\r\n * const filtered = without(data, 20); // [100, 40]\r\n * ```\r\n * @template V Type of array items\r\n * @param data Source array\r\n * @param value Value to remove\r\n * @param comparer Comparison function. If not provided {@link isEqualDefault} is used, which compares using `===`\r\n * @return Copy of array without value.\r\n */\r\nexport const without = <V>(data:ReadonlyArray<V>, value:V, comparer:IsEqual<V> = isEqualDefault):ReadonlyArray<V> => data.filter(v => !comparer(v, value));\r\n\r\n/**\r\n * Groups data by a grouper function, returning data as a map with string\r\n * keys and array values.\r\n * \r\n * @example\r\n * ```js\r\n * const data = [\r\n *  { age: 39, city: `London` }\r\n *  { age: 14, city: `Copenhagen` }\r\n *  { age: 23, city: `Stockholm` }\r\n *  { age: 56, city: `London` }\r\n * ];\r\n * const map = groupBy(data, item => data.city); \r\n * ```\r\n * \r\n * Returns a map: \r\n * \r\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\r\n * Stockhom: [{ age: 23, city: `Stockholm` }]\r\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\r\n * \r\n * @param array Array to group\r\n * @param grouper Function that returns a key for a given item\r\n * @template K Type of key to group by. Typically string.\r\n * @template V Type of values\r\n * @returns Map \r\n */\r\nexport const groupBy = <K, V>(array: ReadonlyArray<V>, grouper: (item: V) => K) => array.reduce((store, item) => {\r\n  const key = grouper(item);\r\n  const val = store.get(key);\r\n  if (val === undefined) {\r\n    store.set(key, [item]);\r\n  } else {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    val.push(item);\r\n  }\r\n  return store;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n}, new Map<K, V[]>());","\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * Usage:\r\n *  clamp(0.5);         // 0.5 - just fine, within default of 0 to 1\r\n *  clamp(1.5);         // 1 - above default max of 1\r\n *  clamp(-50, 0, 100); // 0 - below range\r\n *  clamp(50, 0, 50);   // 50 - within range\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * @param {number} v Value to clamp\r\n * @param {number} [min=0] Minimum value (inclusive)\r\n * @param {number} [max=1] Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n    /**\r\n * Returns a bezier interpolated value, using the given ranges\r\n * @param {number} value  Value to be interpolated\r\n * @param {number} s1 Source range start\r\n * @param {number} s2  Source range end\r\n * @param {number} t1  Target range start\r\n * @param {number} t2  Target range end\r\n * @param {number} [slope]  Weight of the curve (0.5 = linear, 0.1 = weighted near target start, 0.9 = weighted near target end)\r\n * @returns {number} Interpolated value\r\n */\r\n//      var interpolate = function (value, s1, s2, t1, t2, slope) {\r\n// //https://stackoverflow.com/questions/25752572/non-linear-interpolation-of-a-range-to-another-range\r\n\r\n//       //Default to linear interpolation\r\n//       slope = slope || 0.5;\r\n  \r\n//       //If the value is out of the source range, floor to min/max target values\r\n//       if(value < Math.min(s1, s2)) {\r\n//           return Math.min(s1, s2) === s1 ? t1 : t2;\r\n//       }\r\n  \r\n//       if(value > Math.max(s1, s2)) {\r\n//           return Math.max(s1, s2) === s1 ? t1 : t2;\r\n//       }\r\n  \r\n//       //Reverse the value, to make it correspond to the target range (this is a side-effect of the bezier calculation)\r\n//       value = s2-value;\r\n  \r\n//       var C1 = {x: s1, y:t1}; //Start of bezier curve\r\n//       var C3 = {x: s2, y:t2}; //End of bezier curve\r\n//       var C2 = {              //Control point\r\n//           x: C3.x,\r\n//           y: C1.y + Math.abs(slope) * (C3.y - C1.y)\r\n//       };\r\n  \r\n//       //Find out how far the value is on the curve\r\n//       var percent = value / (C3.x-C1.x);\r\n  \r\n//       return C1.y*b1(percent) + C2.y*b2(percent) + C3.y*b3(percent);\r\n  \r\n//       function b1(t) { return t*t }\r\n//       function b2(t) { return 2*t*(1 - t)  }\r\n//       function b3(t) { return (1 - t)*(1 - t) }\r\n//   };\r\n\r\nexport const map = (\r\n  v:number, \r\n  inMin:number, inMax:number, \r\n  outMin:number, outMax:number\r\n) => (v - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and length (exclusive)\r\n * This is useful for clamping an array range, because the largest allowed number will\r\n * be one less than length\r\n * \r\n * ```js\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampZeroBounds(0, myArray.length); // 0\r\n * clampZeroBounds(1.2, myArray.length); // 1\r\n * clampZeroBounds(4, myArray.length); // 4\r\n * clampZeroBounds(5, myArray.length); // 4\r\n * clampZeroBounds(-1, myArray.length); // 0 \r\n * ```\r\n * @param {number} v Integer value to clamp\r\n * @param {number} length Length of bounds\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\nexport const clampZeroBounds = (v: number, length: number) => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\nexport const lerp =(amt:number, a:number, b:number) => (1-amt) * a + amt * b;\r\n\r\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\r\nexport type IsEqual<V> = (a:V, b:V) => boolean;\r\n\r\n/**\r\n * Default comparer function is equiv to checking `a === b`\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqualDefault = <V>(a:V, b:V):boolean => a === b;\r\n\r\n/**\r\n * Comparer returns true if string representation of `a` and `b` are equal.\r\n * Uses `toStringDefault` to generate a string representation (`JSON.stringify`)\r\n *\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean} True if the contents of `a` and `b` are equal\r\n */\r\nexport const isEqualValueDefault = <V>(a:V, b:V):boolean => {\r\n  // ✔ UNIT TESTED\r\n  if (a === b) return true; // Object references are the same, or string values are the same\r\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\r\n};\r\n\r\n/**\r\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} itemToMakeStringFor\r\n * @returns {string}\r\n */\r\nexport const toStringDefault = <V>(itemToMakeStringFor:V):string => ((typeof itemToMakeStringFor === `string`) ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor));\r\n\r\n","/**\r\n * Calculates the average of all numbers in an array.\r\n * Array items which aren't a valid number are ignored and do not factor into averaging.\r\n *\r\n * Use {@link minMaxAvg} if you want min, max and total as well.\r\n * \r\n * @example\r\n * ```\r\n * // Average of a list\r\n * const avg = average(1, 1.4, 0.9, 0.1);\r\n * \r\n * // Average of a variable\r\n * let data = [100,200];\r\n * average(...data);\r\n * ```\r\n * @param data Data to average.\r\n * @returns Average of array\r\n */\r\nexport const average = (...data: readonly number[]): number => {\r\n  // ✔ UNIT TESTED\r\n  if (data === undefined) throw new Error(`data parameter is undefined`);\r\n\r\n  //const total = data.reduce((acc, v) => acc+v, 0);\r\n  const validNumbers = data.filter(d => typeof d === `number` && !Number.isNaN(d));\r\n  const total = validNumbers.reduce((acc, v) => acc + v, 0);\r\n  return total / validNumbers.length;\r\n};\r\n\r\n/**\r\n * Returns the min, max, avg and total of the array.\r\n * Any values that are invalid are silently skipped over.\r\n * \r\n * Use {@link average} if you only need average\r\n * \r\n * @param data \r\n * @returns `{min, max, avg, total}`\r\n */\r\nexport const minMaxAvg = (data: readonly number[]): {\r\n  /**\r\n   * Smallest value in array\r\n   */\r\n  readonly min: number; \r\n  /**\r\n   * Total of all items\r\n   */\r\n  readonly total: number; \r\n  /**\r\n   * Largest value in array\r\n   */\r\n  readonly max: number; \r\n  /**\r\n   * Average value in array\r\n   */\r\n  readonly avg: number;} => {\r\n  const validNumbers = data.filter(d => typeof d === `number` && !Number.isNaN(d));\r\n  const total = validNumbers.reduce((acc, v) => acc + v, 0);\r\n  return {\r\n    total: total,\r\n    max: Math.max(...validNumbers),\r\n    min: Math.min(...validNumbers),\r\n    avg: total / validNumbers.length\r\n  };\r\n};"],"mappings":"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","names":[]}