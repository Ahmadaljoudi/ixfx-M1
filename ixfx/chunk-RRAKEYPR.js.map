{"version":3,"sources":["../src/collections/Stack.ts","../src/collections/NumericArrays.ts","../src/collections/MutableCircularArray.ts","../src/collections/MutableMapMulti.ts"],"sourcesContent":["// ✔ Unit tested!\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\nexport type StackOpts = {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  readonly overflowPolicy?: OverflowPolicy\r\n}\r\n\r\nconst trimStack = <V>(opts: StackOpts, stack: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = stack.length + toAdd.length;\r\n  const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n\r\n  switch (policy) {\r\n  case OverflowPolicy.DiscardAdditions:\r\n    if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (stack.length === opts.capacity) {\r\n      return stack; // Completely full\r\n    } else {\r\n      // Only add some from the new array\r\n      return [...stack, ...toAdd.slice(0, toAdd.length-toRemove)];\r\n    }\r\n  case OverflowPolicy.DiscardNewer:\r\n    if (toRemove >= stack.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old (from 0)\r\n      if (opts.debug) console.log(` from orig: ${stack.slice(0, toRemove-1)}`);\r\n      return [...stack.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  case OverflowPolicy.DiscardOlder:\r\n    // Oldest item in stack is position 0\r\n    return [...stack, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n// Add to top (last index)\r\nconst push = <V>(opts: StackOpts, stack: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\r\n  //const mutated = [...stack, ...toAdd];\r\n  const potentialLength = stack.length + toAdd.length;\r\n\r\n  const overSize = (opts.capacity && potentialLength > opts.capacity);\r\n  const toReturn  = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];\r\n  return toReturn;\r\n};\r\n\r\n// Remove from top (last index)\r\nconst pop = <V>(opts: StackOpts, stack: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (stack.length === 0) throw new Error(`Stack is empty`);\r\n  return stack.slice(0, stack.length - 1);\r\n};\r\n\r\n/**\r\n * Peek at the top of the stack (end of array)\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {V[]} stack\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: StackOpts, stack: ReadonlyArray<V>): V | undefined => stack[stack.length - 1];\r\n\r\nconst isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => stack.length === 0;\r\n\r\nconst isFull = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return stack.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------\r\n// Immutable\r\n// -------------------------\r\n\r\n/**\r\n * Immutable stack\r\n * `Push` & `pop` both return a new instance, the original is never modified.\r\n * \r\n * Usage:\r\n * ```\r\n * push(item);  // Return a new stack with item(s) added\r\n * pop();       // Return a new stack with top-most item removed (ie. newest)\r\n * .peek;       // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length;     // How many items in stack\r\n * .data;       // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * let sanga = new Stack();\r\n * sanga = sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga = sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * const sangaAlt = sanga.push(`lettuce`, `cheese`); // sanga stays [`bread`, `tomato`], while sangaAlt is [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class Stack\r\n * @template V\r\n */\r\nexport class Stack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): Stack<V> {\r\n    return new Stack<V>(this.opts, push(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  pop(): Stack<V> {\r\n    return new Stack<V>(this.opts, pop(this.opts, this.data));\r\n  }\r\n\r\n  /**\r\n   * Enumerates stack from bottom-to-top\r\n   *\r\n   * @param {(v:V) => void} fn\r\n   * @memberof Stack\r\n   */\r\n  forEach(fn:(v:V) => void): void {\r\n    this.data.forEach(fn);\r\n  }\r\n\r\n  forEachFromTop(fn:(v:V) => void): void {\r\n    [...this.data].reverse().forEach(fn);\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n/**\r\n * Returns an immutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} [opts={}]\r\n * @param {...V[]} startingItems\r\n * @returns {Stack<V>}\r\n */\r\nexport const stack = <V>(opts: StackOpts = {}, ...startingItems: ReadonlyArray<V>): Stack<V> => new Stack({...opts}, [...startingItems]);\r\n\r\n\r\n// -------------------------\r\n// Mutable\r\n// -------------------------\r\n\r\n\r\n/**\r\n * Mutable stack\r\n * \r\n * Usage:\r\n * ```\r\n * push(item); // Add one or more items to the top of the stack\r\n * pop(); // Removes and retiurns the item at the top of the stack (ie the newest thing)\r\n * .peek; // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length; // How many items in stack\r\n * .data; // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const sanga = new MutableStack();\r\n * sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * sanga.push(`lettuce`, `cheese`); // Stack is now [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class MutableStack\r\n * @template V\r\n */\r\nclass MutableStack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = push(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  pop(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    pop(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a mutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {...V[]} startingItems\r\n * @returns\r\n */\r\nexport const stackMutable = <V>(opts: StackOpts, ...startingItems: ReadonlyArray<V>) =>  new MutableStack({...opts}, [...startingItems]);","/**\r\n * Calculates the average of all numbers in an array.\r\n * Array items which aren't a valid number are ignored and do not factor into averaging.\r\n *\r\n * Usage\r\n * ```\r\n * average(1, 1.4, 0.9, 0.1);\r\n * \r\n * let data = [100,200];\r\n * average(...data);\r\n * ```\r\n * @param {...number[]} data Data to average.\r\n * @returns {number}\r\n */\r\nexport const average = (...data: readonly number[]): number => {\r\n  // ✔ UNIT TESTED\r\n  if (data === undefined) throw new Error(`data parameter is undefined`);\r\n\r\n  //const total = data.reduce((acc, v) => acc+v, 0);\r\n  const validNumbers = data.filter(d => typeof d === `number` && !Number.isNaN(d));\r\n  const total = validNumbers.reduce((acc, v) => acc + v, 0);\r\n  return total / validNumbers.length;\r\n};\r\n\r\nexport const getMinMaxAvg = (data: readonly number[]): {readonly min: number; readonly total: number; readonly max: number; readonly avg: number;} => {\r\n  const validNumbers = data.filter(d => typeof d === `number` && !Number.isNaN(d));\r\n  const total = validNumbers.reduce((acc, v) => acc + v, 0);\r\n  return {\r\n    total: total,\r\n    max: Math.max(...validNumbers),\r\n    min: Math.min(...validNumbers),\r\n    avg: total / validNumbers.length\r\n  };\r\n};","/**\r\n * The circular array grows to a fixed size. Once full, new\r\n * items replace the oldest item in the array. Immutable.\r\n *\r\n * Usage:\r\n * ```\r\n * let a = new Circular(10);\r\n * let b = a.add(something);\r\n * ```\r\n * @class CircularArray\r\n * @extends {Array}\r\n * @template V\r\n */\r\nexport class MutableCircularArray<V> extends Array {\r\n  // ✔ Class is unit tested!\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  #capacity: number;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  #pointer: number;\r\n\r\n  constructor(capacity: number) {\r\n    super();\r\n    if (Number.isNaN(capacity)) throw Error(`capacity is NaN`);\r\n    // Can't throw because .filter won't use ctor proprly\r\n    //if (capacity <= 0) throw Error(`capacity must be greater than zero (${capacity})`);\r\n    this.#capacity = capacity;\r\n    this.#pointer = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a new Circular with item added\r\n   *\r\n   * @param {V} thing Thing to add\r\n   * @returns {Circular<V>} Circular with item added\r\n   * @memberof Circular\r\n   */\r\n  add(thing: V): MutableCircularArray<V> {\r\n    const ca = MutableCircularArray.from(this) as MutableCircularArray<V>;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca[this.#pointer] = thing;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca.#capacity = this.#capacity;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\r\n    return ca;\r\n  }\r\n\r\n  get pointer(): number {\r\n    return this.#pointer;\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    if (this.#capacity === 0) return false;\r\n    return this.length === this.#capacity;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Returns a new mutable circular array\r\n *\r\n * @template V\r\n * @param {number} capacity\r\n * @return {*}  {CircularArray<V>}\r\n */\r\nexport const mutableCircularArray = <V>(capacity:number): MutableCircularArray<V> => new MutableCircularArray<V>(capacity);\r\n","// ✔ UNIT TESTED\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\nimport { ToString, IsEqual, toStringDefault, isEqualDefault } from \"../util.js\";\r\nimport { addUniqueByHash } from \"./Set.js\";\r\nimport { hasAnyValue as mapHasAnyValue,  toArray as mapToArray, find as mapFind, filter as mapFilter} from './Map.js';\r\nimport {  without } from './Arrays.js';\r\nimport {MutableCircularArray, mutableCircularArray} from './MutableCircularArray.js';\r\n\r\nexport type MapMultiOpts<V> = {\r\n  /**\r\n   * Returns true if two values should be considered equal.\r\n   * \r\n   * @type {(IsEqual<V>|undefined)}\r\n   */\r\n // readonly valueComparer?: IsEqual<V>|undefined\r\n\r\n /**\r\n  * Returns a group for values added via `addValue`. Eg. maybe you want to \r\n  * group values in the shape `{name: 'Samantha' city: 'Copenhagen'}` by city:\r\n  * \r\n  * ```\r\n  * const opts = {\r\n  *  groupBy: (v) => v.city\r\n  * }\r\n  * ```\r\n  *\r\n  * @type {(ToString<V>|undefined)}\r\n  */\r\n readonly groupBy?: ToString<V>|undefined\r\n}\r\n\r\ntype MutableMapArrayEvents<V> = {\r\n  readonly addedValues: {readonly values: ReadonlyArray<V>}\r\n  readonly addedKey: {readonly key: string }\r\n  readonly clear: boolean\r\n  readonly deleteKey: {readonly key: string}\r\n}\r\n\r\nexport type MultiValue<V, M> = Readonly<{\r\n  has(source:M, value:V): boolean\r\n  add(destination:M|undefined, values:ReadonlyArray<V>):M\r\n  toArray(source:M): ReadonlyArray<V>|undefined\r\n  find(source:M, predicate:(v:V) => boolean): V|unknown\r\n  filter(source:M, predicate:(v:V) => boolean): ReadonlyArray<V>\r\n  without(source:M, value:V): ReadonlyArray<V>\r\n  count(source:M): number\r\n}>;\r\n\r\n/**\r\n * Like a `Map` but multiple values can be stored for each key. \r\n * Duplicate values can be added to the same or even a several keys.\r\n * \r\n * By default, equality is based on value rather than reference.\r\n *\r\n * @export\r\n * @class MutableMapMulti\r\n * @template V\r\n */\r\nexport class MutableMapOf<V, M>  extends SimpleEventEmitter<MutableMapArrayEvents<V>> {\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #map: Map<string, M> = new Map();\r\n  //readonly valueComparer: IsEqual<V>;\r\n  readonly groupBy: ToString<V>;\r\n  readonly type: MultiValue<V, M>;\r\n\r\n  /**\r\n   * Constructor.\r\n   * \r\n   * By default it will group by the string representation of values and use\r\n   * reference matching for values.\r\n   * @param {MapMultiOpts<V>} [opts={}]\r\n   * @memberof MutableMapMulti\r\n   */\r\n  constructor(type:MultiValue<V, M>, opts:MapMultiOpts<V> = {}) {\r\n    super();\r\n    this.type = type;\r\n    this.groupBy = opts.groupBy ?? toStringDefault;\r\n    // this.valueComparer = opts.valueComparer ?? isEqualDefault;\r\n  }\r\n\r\n  debugString(): string {\r\n    const keys = Array.from(this.#map.keys());\r\n    // eslint-disable-next-line functional/no-let\r\n    let r = `Keys: ${keys.join(`, `)}\\r\\n`;\r\n    keys.forEach(k => {\r\n      const v = this.#map.get(k);\r\n      if (v !== undefined) {\r\n        const asArray = this.type.toArray(v);\r\n        if (asArray !== undefined) {\r\n          r += ` - ${k} (${this.type.count(v)}) = ${JSON.stringify(asArray)}\\r\\n`;\r\n        }\r\n      } else r += ` - ${k} (undefined)\\r\\n`;\r\n    });\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the map is empty\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   * @memberof MutableMapMulti\r\n   */\r\n  get isEmpty():boolean {\r\n    return (this.#map.size === 0);\r\n  }\r\n\r\n  /**\r\n   * Clears the map\r\n   *\r\n   * @memberof MutableMapMulti\r\n   */\r\n  clear() {\r\n    this.#map.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  /**\r\n   * Adds several values under the same key. Duplicate values are permitted.\r\n   *\r\n   * @param {string} key Key for values\r\n   * @param {...V[]} value Values\r\n   * @memberof MapMulti\r\n   */\r\n  addKeyedValues(key: string, ...values: ReadonlyArray<V>) {\r\n    const set = this.#map.get(key);\r\n    //console.log(`addKeyedValues: key: ${key} values: ${JSON.stringify(values)}`);\r\n    if (set === undefined) {\r\n      this.#map.set(key, this.type.add(undefined, values));\r\n      super.fireEvent(`addedKey`, {key:key});\r\n      super.fireEvent(`addedValues`, {values: values});\r\n    } else {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#map.set(key, this.type.add(set, values));\r\n      super.fireEvent(`addedValues`, {values: values});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a value, automatically extracting a key via the\r\n   * `groupBy` function assigned in the constructor options.\r\n   *\r\n   * @param {V} values\r\n   * @memberof MutableMapArray\r\n   */\r\n  addValue(...values:ReadonlyArray<V>) {\r\n    values.forEach(v => this.addKeyedValues(this.groupBy(v), v));\r\n  }\r\n\r\n  /**\r\n   * Returns true if `value` is stored under `key`.\r\n   *\r\n   * By default values are compared by value, not reference.\r\n   * \r\n   * @param {string} key\r\n   * @param {V} value\r\n   * @return {*}  {boolean}\r\n   * @memberof MutableMapArray\r\n   */\r\n  hasKeyValue(key:string, value:V):boolean {    \r\n    const m = this.#map.get(key);\r\n    if (m === undefined) return false;    \r\n    return this.type.has(m, value);\r\n  }\r\n\r\n  has(key:string):boolean {\r\n    return this.#map.has(key);\r\n  }\r\n\r\n  /**\r\n   * Deletes all values under the specified key that match the given value.\r\n   *\r\n   * @param {string} key\r\n   * @param {V} value\r\n   * @return {*} \r\n   * @memberof MutableMapArray\r\n   */\r\n  deleteKeyValue(key: string, value: V) {\r\n    const a = this.#map.get(key);\r\n    if (a === undefined) return;\r\n    const filtered = this.type.without(a, value);// this.type.filter(a, v => !this.valueComparer(v, value));\r\n    this.#map.set(key, this.type.add(undefined, filtered));\r\n  }\r\n\r\n  delete(key:string): boolean {\r\n    const a = this.#map.get(key);\r\n    if (a === undefined) return false;\r\n    this.#map.delete(key);\r\n    this.fireEvent(`deleteKey`, {key: key});\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Deletes all occurences of `value` regardless of key\r\n   *\r\n   * @param {V} value\r\n   * @memberof MapMulti\r\n   */\r\n  // deleteDeep(value: V) {\r\n  //   const keys = Array.from(this.#map.keys());\r\n\r\n  //   keys.forEach(k => {\r\n  //     const a = this.#map.get(k);\r\n  //     if (a === undefined) return;\r\n  //     const b = this.type.filter(a, v => !this.valueComparer(v, value));\r\n  //     this.#map.set(k, this.type.add(undefined, b));\r\n  //   });\r\n  // }\r\n\r\n  /**\r\n   * Finds the first key where value is stored. \r\n   * Note: value could be stored in multiple keys\r\n   *\r\n   * @param {V} value\r\n   * @returns {(string | undefined)}\r\n   * @memberof MapMulti\r\n   */\r\n  findKeyForValue(value: V): string | undefined {\r\n    const keys = Array.from(this.#map.keys());\r\n    const found = keys.find(key => {\r\n      const a = this.#map.get(key);\r\n      if (a === undefined) throw Error(`Bug: map could not be accessed`);\r\n      if (this.type.has(a, value)) return true;\r\n      return false;\r\n    });\r\n    return found;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of values stored under `key`, or 0 if key is not present.\r\n   *\r\n   * @param {string} key\r\n   * @return {*}  {number}\r\n   * @memberof MutableMapArray\r\n   */\r\n  count(key: string): number {\r\n    const e = this.#map.get(key);\r\n    if (e === undefined) return 0;\r\n    return this.type.count(e);\r\n  }\r\n\r\n  /**\r\n   * Returns the array of values stored under `key`\r\n   * or undefined if key does not exist\r\n   *\r\n   * @param {string} key\r\n   * @return {*}  {readonly}\r\n   * @memberof MutableMapArray\r\n   */\r\n  get(key: string): readonly V[] | undefined {\r\n    const m = this.#map.get(key);\r\n    if (m === undefined) return undefined;\r\n    return this.type.toArray(m);\r\n  }\r\n\r\n  getSource(key:string): M|undefined {\r\n    return this.#map.get(key);\r\n  }\r\n\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  keys(): string[] {\r\n    return Array.from(this.#map.keys());\r\n  }\r\n\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  keysAndCounts(): Array<[string, number]> {\r\n    const keys = this.keys();\r\n    /* eslint-disable-next-line functional/prefer-readonly-type */\r\n    const r = keys.map(k => [k, this.count(k)]) as Array<[string, number]>;\r\n    return r;\r\n  }\r\n\r\n  merge(other: MutableMapOf<V, M>) {\r\n    const keys = other.keys();\r\n    keys.forEach(key => {\r\n      const data = other.get(key);\r\n      if (data !== undefined) this.addKeyedValues(key, ...data);\r\n    });\r\n  }\r\n}\r\n\r\nexport type MapArrayOpts<V> = MapMultiOpts<V> & {\r\n  readonly comparer?:IsEqual<V>\r\n  readonly toString?:ToString<V>\r\n}\r\n\r\n// ✔ UNIT TESTED\r\nexport const mutableMapArray = <V>(opts:MapArrayOpts<V> = {}) => {\r\n  const comparer = opts.comparer === undefined ?\r\n    opts.toString === undefined ? (a:V, b:V) => opts.toString(a) === opts.toString(b) :\r\n      isEqualDefault\r\n    : opts.comparer;\r\n    \r\n  const t:MultiValue<V, ReadonlyArray<V>> = {\r\n    add:(dest, values) => {\r\n      if (dest === undefined) return [...values];\r\n      return [...dest, ...values];\r\n    },\r\n    count: (source) => source.length,\r\n    find: (source, predicate) => source.find(predicate),\r\n    filter: (source, predicate) => source.filter(predicate),\r\n    toArray: (source) => source,\r\n    has: (source, value) => source.find(v => comparer(v, value)) !== undefined,\r\n    without: (source, value) => source.filter(v => !comparer(v, value))\r\n  };\r\n  const m = new MutableMapOf<V, ReadonlyArray<V>>(t, opts);\r\n  return m;\r\n};\r\n\r\nexport type MapSetOpts<V> = MapMultiOpts<V> & {\r\n  readonly hash:ToString<V>\r\n};\r\n\r\nexport const mutableMapSet = <V>(opts?:MapSetOpts<V>) => {\r\n  const hash = opts?.hash ?? toStringDefault;\r\n  const comparer = (a:V, b:V) => hash(a) === hash(b);\r\n\r\n  const t:MultiValue<V, ReadonlyMap<string, V>> = {\r\n    add:(dest, values) => addUniqueByHash(dest, hash, ...values),\r\n    count: (source) => source.size,\r\n    find: (source, predicate) => mapFind(source, predicate),\r\n    filter: (source, predicate) => mapFilter(source, predicate),\r\n    toArray: (source) => mapToArray(source),\r\n    has: (source, value) => mapHasAnyValue(source, value, comparer),\r\n    without: (source, value) => without(mapToArray(source), value, comparer)\r\n  };\r\n  const m = new MutableMapOf<V, ReadonlyMap<string, V>>(t, opts);\r\n  return m;\r\n};\r\n\r\nexport type MapCircularOpts<V> = MapMultiOpts<V> & {\r\n  readonly capacity:number\r\n}\r\nexport const mutableMapCircular = <V>(opts:MapCircularOpts<V>) => {\r\n  const comparer = isEqualDefault;\r\n\r\n  const t:MultiValue<V, MutableCircularArray<V>> = {\r\n    add:(dest, values) => {\r\n      if (dest === undefined) dest = mutableCircularArray<V>(opts.capacity);\r\n      values.forEach(v => dest = dest?.add(v));\r\n      return dest;\r\n    },\r\n    count: (source) => source.length,\r\n    find: (source, predicate) => source.find(predicate),\r\n    filter: (source, predicate) => source.filter(predicate),\r\n    toArray: (source) => source,\r\n    has: (source, value) => source.find(v => comparer(v, value)) !== undefined,\r\n    without: (source, value) => source.filter(v => !comparer(v, value))\r\n  };\r\n  return new MutableMapOf<V, MutableCircularArray<V>>(t, opts);\r\n};"],"mappings":"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","names":[]}