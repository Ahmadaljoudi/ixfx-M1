{"version":3,"sources":["../src/flow/index.ts"],"sourcesContent":["import { number as guardNumber} from \"../Guards.js\";\r\nimport {sleep} from \"./Timer.js\";\r\n\r\nexport * as StateMachine from './StateMachine.js';\r\nexport * from './Timer.js';\r\n\r\n/**\r\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\r\n * If `fn` returns _false_, iterator cancels. \r\n * \r\n * @example\r\n * ```js\r\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\r\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\r\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\r\n * ```\r\n * \r\n * Use {@link forEachAsync} if you want to use an async `iterator` and async `fn`.\r\n * @param iterator Iterable or array\r\n * @param fn Function to call for each item. If function returns false, iteration cancels\r\n */\r\nexport const forEach = <V>(iterator:IterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>boolean|void) => {\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const x of iterator) {\r\n    const r = fn(x);\r\n    if (typeof r === `boolean` && !r) break;\r\n  }\r\n};\r\n\r\n/**\r\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\r\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\r\n * \r\n * Use {@link forEach} for a synchronous version.\r\n * \r\n * ```\r\n * // Prints items from array every second\r\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\r\n * ```\r\n * \r\n * @example Retry `doSomething` up to five times, with 5 seconds between each attempt\r\n * ```\r\n * await forEachAsync(count(5), i=> {\r\n *  try {\r\n *    await doSomething();\r\n *    return false; // Succeeded, exit early\r\n *  } catch (ex) {\r\n *    console.log(ex);\r\n *    return true; // Keep trying\r\n *  }\r\n * }, 5000);\r\n * ```\r\n * @param iterator \r\n * @param fn \r\n */\r\nexport const forEachAsync = async function <V> (iterator:AsyncIterableIterator<V>|ReadonlyArray<V>, fn:(v?:V)=>Promise<boolean>|Promise<void>, intervalMs?:number) {\r\n  if (Array.isArray(iterator)) {\r\n    // Handle array\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const x of iterator) {\r\n      const r = await fn(x);\r\n      if (intervalMs) await sleep(intervalMs);\r\n      if (typeof r === `boolean` && !r) break;\r\n    }\r\n  } else {\r\n    // Handle an async iterator\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for await (const x of iterator) {\r\n      const r = await fn(x);\r\n      if (intervalMs) await sleep(intervalMs);\r\n      if (typeof r === `boolean` && !r) break;\r\n    }\r\n  }\r\n};\r\n\r\nexport type RepeatPredicate = (repeats:number, valuesProduced:number)=>boolean;\r\n/**\r\n * Runs `fn` a certain number of times, accumulating result into an array.\r\n * If `fn` returns undefined, the result is ignored.\r\n * \r\n * ```js\r\n * // Results will be an array with five random numbers\r\n * const results = repeat(5, () => Math.random());\r\n * ```\r\n * \r\n * Repeats can be specified as an integer (eg. 5 for five repeats), or a function\r\n * that gives _false_ when repeating should stop.\r\n * \r\n * ```js\r\n * // Keep running `fn` until we've accumulated 10 values\r\n * // Useful if `fn` sometimes returns _undefined_\r\n * const results = repeat((repeats, valuesProduced) => valuesProduced < 10, fn);\r\n * ```\r\n * \r\n * If you don't need to accumulate return values, consider {@link Generators.count} with {@link Generators.forEach}.\r\n * \r\n * @param countOrPredicate Number of repeats or function returning false when to stop \r\n * @param fn Function to run, must return a value to accumulate into array or _undefined_\r\n * @returns Array of accumulated results\r\n */\r\nexport const repeat = <V>(countOrPredicate:number|RepeatPredicate, fn:()=>V|undefined):readonly V[] => {\r\n  // Unit tested: expected return array length\r\n  //eslint-disable-next-line functional/no-let\r\n  let repeats, valuesProduced;\r\n  repeats = valuesProduced = 0;\r\n  const ret = [];\r\n\r\n  if (typeof countOrPredicate === `number`) {\r\n    guardNumber(countOrPredicate, `positive`, `countOrPredicate`);\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (countOrPredicate-- > 0) {\r\n      repeats++;\r\n      const v = fn();\r\n      if (v === undefined) continue;\r\n      //eslint-disable-next-line functional/immutable-data\r\n      ret.push(v);\r\n      valuesProduced++;\r\n    }\r\n  } else {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    while (countOrPredicate(repeats, valuesProduced)) {\r\n      repeats++;\r\n      const v = fn();\r\n      if (v === undefined) continue;\r\n      //eslint-disable-next-line functional/immutable-data\r\n      ret.push(v);\r\n      valuesProduced++;\r\n    }\r\n  }\r\n  return ret;\r\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBO,IAAM,UAAU,CAAI,UAA+C,OAA4B;AAEpG,aAAW,KAAK,UAAU;AACxB,UAAM,IAAI,GAAG,CAAC;AACd,QAAI,OAAO,MAAM,aAAa,CAAC;AAAG;AAAA,EACpC;AACF;AA4BO,IAAM,eAAe,eAAoB,UAAoD,IAA2C,YAAoB;AACjK,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAG3B,eAAW,KAAK,UAAU;AACxB,YAAM,IAAI,MAAM,GAAG,CAAC;AACpB,UAAI;AAAY,cAAM,MAAM,UAAU;AACtC,UAAI,OAAO,MAAM,aAAa,CAAC;AAAG;AAAA,IACpC;AAAA,EACF,OAAO;AAGL,qBAAiB,KAAK,UAAU;AAC9B,YAAM,IAAI,MAAM,GAAG,CAAC;AACpB,UAAI;AAAY,cAAM,MAAM,UAAU;AACtC,UAAI,OAAO,MAAM,aAAa,CAAC;AAAG;AAAA,IACpC;AAAA,EACF;AACF;AA2BO,IAAM,SAAS,CAAI,kBAAyC,OAAoC;AAGrG,MAAI,SAAS;AACb,YAAU,iBAAiB;AAC3B,QAAM,MAAM,CAAC;AAEb,MAAI,OAAO,qBAAqB,UAAU;AACxC,WAAY,kBAAkB,YAAY,kBAAkB;AAE5D,WAAO,qBAAqB,GAAG;AAC7B;AACA,YAAM,IAAI,GAAG;AACb,UAAI,MAAM;AAAW;AAErB,UAAI,KAAK,CAAC;AACV;AAAA,IACF;AAAA,EACF,OAAO;AAEL,WAAO,iBAAiB,SAAS,cAAc,GAAG;AAChD;AACA,YAAM,IAAI,GAAG;AACb,UAAI,MAAM;AAAW;AAErB,UAAI,KAAK,CAAC;AACV;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;","names":[]}