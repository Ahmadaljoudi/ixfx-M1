{"version":3,"sources":["../src/Generators.ts"],"sourcesContent":["import {sleep} from \"./Timer.js\";\r\n\r\n/**\r\n * Generates values from `produce` with `intervalMs` time delay\r\n * \r\n * @example Produce a random number every 500ms:\r\n * ```\r\n * const randomGenerator = atInterval(() => Math.random(), 1000);\r\n * for await (const r of randomGenerator) {\r\n *  // Random value every 1 second\r\n * }\r\n * ```\r\n *\r\n * @template V\r\n * @param intervalMs Interval between execution\r\n * @param produce Function to call\r\n * @template V Data type\r\n * @returns\r\n */\r\n export const interval = async function*<V>(produce: () => Promise<V>, intervalMs: number) {\r\n  let cancelled = false;\r\n  try {\r\n    while (!cancelled) {\r\n      await sleep(intervalMs);\r\n      if (cancelled) return;\r\n      yield await produce();\r\n    }\r\n  } finally {\r\n    cancelled = true;\r\n  }\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, starting from `start` and coutnting by `interval`.\r\n * If `end` is provided, generator stops when reached.\r\n * \r\n * Unlike numericRange, numbers might contain rounding errors\r\n * \r\n * ```js\r\n * for (const c of numericRangeRaw(10, 100)) {\r\n *  // 100, 110, 120 ...\r\n * }\r\n * ```\r\n * @param interval Interval between numbers\r\n * @param start Start\r\n * @param end End (if undefined, range never ends)\r\n */\r\nexport const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  let v = start;\r\n  do {\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n *\r\n * @example For-loop\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * \r\n * @example If you want more control over when/where incrementing happens...\r\n * ```js\r\n * let percent = numericRange(0.1, 0, 1);\r\n * \r\n * let percentResult = percent.next().value;\r\n * ```\r\n * \r\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\r\n * number.\r\n * \r\n * @param interval Interval between numbers\r\n * @param start Start\r\n * @param end End (if undefined, range never ends)\r\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  if (interval <= 0) throw Error(`Interval is expected to be above zero`);\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  do {\r\n    let v = start * rounding;\r\n    while (v <= end) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Continually loops back and forth between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * @example Usage\r\n * ```js\r\n * for (let v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * @example Alternative:\r\n * ```js\r\n * let pp = percentPingPong(0.1, 0.5); // Setup generator one time\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to 0 and 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * @param {number} interval Amount to increment by. Defaults to 10%\r\n * @param {number} offset Starting point. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param {number} rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, offset?: number, rounding: number = 1000) {\r\n  if (offset === undefined && interval > 0) offset = 0;\r\n  else if (offset === undefined && interval < 0) offset = 1;\r\n  else offset = offset as number;\r\n  if (offset > 1 || offset < 0) throw new Error(`offset must be between 0 and 1`);\r\n  return pingPong(interval, 0, 1, offset, rounding);\r\n};\r\n\r\n/**\r\n * Ping-pongs continually between `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * In a loop:\r\n * ```\r\n * for (const c of pingPong(10, 0, 100)) {\r\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\r\n * }\r\n * ```\r\n * \r\n * Manual:\r\n * ```\r\n * const pp = pingPong(10, 0, 100);\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * @param interval Amount to increment by. Use negative numbers to start counting down\r\n * @param lower Lower bound (inclusive)\r\n * @param upper Upper bound (inclusive, must be greater than start)\r\n * @param offset Starting point within bounds (defaults to `lower`)\r\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, offset?: number, rounding: number = 1) {\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(offset)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (offset === undefined) offset = lower;\r\n  else offset = Math.floor(offset * rounding);\r\n  if (offset > upper || offset < lower) throw new Error(`Offset must be within lower and upper`);\r\n\r\n  let v = offset;\r\n  yield v / rounding;\r\n  let firstLoop = true;\r\n  while (true) {\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n"],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBQ,IAAM,WAAW,iBAAmB,SAA2B,YAAoB;AACzF,MAAI,YAAY;AAChB,MAAI;AACF,WAAO,CAAC,WAAW;AACjB,YAAM,MAAM;AACZ,UAAI;AAAW;AACf,YAAM,MAAM;AAAA;AAAA,YAEd;AACA,gBAAY;AAAA;AAAA;AAmBT,IAAM,kBAAkB,WAAW,WAAkB,QAAgB,GAAG,KAAc,YAAqB,OAAO;AACvH,MAAI,aAAY;AAAG,UAAM,IAAI,MAAM;AACnC,MAAI,QAAQ;AAAW,UAAM,OAAO;AACpC,MAAI,IAAI;AACR,KAAG;AACD,WAAO,IAAI,KAAK;AACd,YAAM;AACN,WAAK;AAAA;AAAA,WAEA;AAAA;AA6BJ,IAAM,eAAe,WAAW,WAAkB,QAAgB,GAAG,KAAc,YAAqB,OAAO,UAAmB;AACvI,MAAI,aAAY;AAAG,UAAM,MAAM;AAC/B,aAAW,YAAY;AACvB,MAAI,QAAQ;AAAW,UAAM,OAAO;AAAA;AAC/B,WAAO;AACZ,cAAW,YAAW;AAEtB,KAAG;AACD,QAAI,IAAI,QAAQ;AAChB,WAAO,KAAK,KAAK;AACf,YAAM,IAAI;AACV,WAAK;AAAA;AAAA,WAEA;AAAA;AA0BJ,IAAM,kBAAkB,SAAU,YAAmB,KAAK,QAAiB,WAAmB,KAAM;AACzG,MAAI,WAAW,UAAa,YAAW;AAAG,aAAS;AAAA,WAC1C,WAAW,UAAa,YAAW;AAAG,aAAS;AAAA;AACnD,aAAS;AACd,MAAI,SAAS,KAAK,SAAS;AAAG,UAAM,IAAI,MAAM;AAC9C,SAAO,SAAS,WAAU,GAAG,GAAG,QAAQ;AAAA;AAwBnC,IAAM,WAAW,WAAW,WAAkB,OAAe,OAAe,QAAiB,WAAmB,GAAG;AACxH,MAAI,OAAO,MAAM;AAAW,UAAM,IAAI,MAAM;AAC5C,MAAI,OAAO,MAAM;AAAQ,UAAM,IAAI,MAAM;AACzC,MAAI,OAAO,MAAM;AAAQ,UAAM,IAAI,MAAM;AACzC,MAAI,OAAO,MAAM;AAAS,UAAM,IAAI,MAAM;AAE1C,MAAI,SAAS;AAAO,UAAM,IAAI,MAAM;AACpC,MAAI,cAAa;AAAG,UAAM,IAAI,MAAM;AACpC,QAAM,WAAW,QAAQ;AACzB,MAAI,KAAK,IAAI,cAAa;AAAU,UAAM,IAAI,MAAM,+BAA+B,gBAAgB;AAEnG,MAAI,eAAe,YAAW;AAG9B,UAAQ,KAAK,MAAM,QAAQ;AAC3B,UAAQ,KAAK,MAAM,QAAQ;AAC3B,cAAW,KAAK,MAAM,KAAK,IAAI,YAAW;AAE1C,MAAI,WAAW;AAAW,aAAS;AAAA;AAC9B,aAAS,KAAK,MAAM,SAAS;AAClC,MAAI,SAAS,SAAS,SAAS;AAAO,UAAM,IAAI,MAAM;AAEtD,MAAI,IAAI;AACR,QAAM,IAAI;AACV,MAAI,YAAY;AAChB,SAAO,MAAM;AACX,QAAI,IAAK,gBAAe,YAAW,CAAC;AACpC,QAAI,gBAAgB,KAAK,OAAO;AAC9B,qBAAe;AACf,UAAI;AACJ,UAAI,MAAM,SAAS,WAAW;AAE5B,YAAI;AAAO,uBAAe;AAAA;AAAA,eAEnB,CAAC,gBAAgB,KAAK,OAAO;AACtC,qBAAe;AACf,UAAI;AACJ,UAAI,MAAM,SAAS,WAAW;AAE5B,YAAI;AAAO,uBAAe;AAAA;AAAA;AAG9B,UAAM,IAAI;AACV,gBAAY;AAAA;AAAA;","names":[]}