{"version":3,"sources":["../src/util.ts","../src/collections/Arrays.ts","../src/collections/Set.ts","../src/collections/Map.ts"],"sourcesContent":["\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * Usage:\r\n *  clamp(0.5);         // 0.5 - just fine, within default of 0 to 1\r\n *  clamp(1.5);         // 1 - above default max of 1\r\n *  clamp(-50, 0, 100); // 0 - below range\r\n *  clamp(50, 0, 50);   // 50 - within range\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * @param {number} v Value to clamp\r\n * @param {number} [min=0] Minimum value (inclusive)\r\n * @param {number} [max=1] Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and length (exclusive)\r\n * This is useful for clamping an array range, because the largest allowed number will\r\n * be one less than length\r\n * \r\n * ```js\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampZeroBounds(0, myArray.length); // 0\r\n * clampZeroBounds(1.2, myArray.length); // 1\r\n * clampZeroBounds(4, myArray.length); // 4\r\n * clampZeroBounds(5, myArray.length); // 4\r\n * clampZeroBounds(-1, myArray.length); // 0 \r\n * ```\r\n * @param {number} v Integer value to clamp\r\n * @param {number} length Length of bounds\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\nexport const clampZeroBounds = (v: number, length: number) => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\nexport const lerp =(amt:number, a:number, b:number) => (1-amt) * a + amt * b;\r\n\r\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\r\nexport type IsEqual<V> = (a:V, b:V) => boolean;\r\n\r\n/**\r\n * Default comparer function is equiv to checking `a === b`\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqualDefault = <V>(a:V, b:V):boolean => a === b;\r\n\r\n/**\r\n * Comparer returns true if string representation of `a` and `b` are equal.\r\n * Uses `toStringDefault` to generate a string representation (`JSON.stringify`)\r\n *\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean} True if the contents of `a` and `b` are equal\r\n */\r\nexport const isEqualValueDefault = <V>(a:V, b:V):boolean => {\r\n  // ✔ UNIT TESTED\r\n  if (a === b) return true; // Object references are the same, or string values are the same\r\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\r\n};\r\n\r\n/**\r\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} itemToMakeStringFor\r\n * @returns {string}\r\n */\r\nexport const toStringDefault = <V>(itemToMakeStringFor:V):string => ((typeof itemToMakeStringFor === `string`) ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor));\r\n\r\n","/**\r\n * Functions for working with primitive arrays, regardless of type\r\n * See Also: NumericArrays.ts\r\n */\r\n\r\nimport {IsEqual, isEqualDefault} from '../util.js';\r\n\r\nexport const guardArray = <V>(array:ArrayLike<V>, paramName:string = `?`) => {\r\n  if (array === undefined) throw new Error(`Param '${paramName}' is undefined. Expected array.`);\r\n  if (array === null) throw new Error(`Param '${paramName}' is null. Expected array.`);\r\n  if (!Array.isArray(array)) throw new Error(`Param '${paramName}' not an array as expected`);\r\n};\r\n\r\nexport const randomIndex = <V>(array: ArrayLike<V>): number => Math.floor(Math.random() * array.length);\r\n\r\nexport const randomElement = <V>(array: ArrayLike<V>): V => {\r\n  guardArray(array, `array`);\r\n  return array[Math.floor(Math.random() * array.length)];\r\n};\r\n\r\n/**\r\n * Removes a random item from an array, returning both the item and the new array as a result.\r\n * Does not modify the original array unless `mutate` parameter is true\r\n *\r\n * @template V\r\n * @param {readonly} array Array to pluck item from\r\n * @param {*} V \r\n * @param {*} []\r\n * @return {*}  {({readonly value:V|undefined, readonly array:ReadonlyArray<V> })}\r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const randomPluck = <V>(array:readonly V[], mutate = false):{readonly value:V|undefined, readonly array:Array<V> } => {\r\n  if (array === undefined) throw new Error(`array is undefined`);\r\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\r\n  if (array.length === 0) return {value: undefined, array: []};\r\n  const index = randomIndex(array);\r\n  if (mutate) {\r\n    return {\r\n      value: array[index],\r\n      //eslint-disable-next-line functional/immutable-data\r\n      array: array.splice(index, 1)\r\n    };\r\n  } else {\r\n    // Copy array, remove item from that\r\n    const t = [...array];\r\n    //eslint-disable-next-line functional/immutable-data\r\n    t.splice(index, 1);\r\n    return {\r\n      value: array[index],\r\n      array: t\r\n    };\r\n  }\r\n};\r\n\r\nexport const shuffle = (dataToShuffle:ReadonlyArray<unknown>): ReadonlyArray<unknown> => {\r\n  const array = [...dataToShuffle];\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n};\r\n\r\n/**\r\n * Returns an array with a value omitted.\r\n * Value checking is completed via the provided `comparer` function, or by default checking whether `a === b`.\r\n *\r\n * @template V\r\n * @param {ReadonlyArray<V>} data\r\n * @param {V} value\r\n * @param {IsEqual<V>} [comparer=isEqualDefault]\r\n * @return {*}  {ReadonlyArray<V>}\r\n */\r\nexport const without = <V>(data:ReadonlyArray<V>, value:V, comparer:IsEqual<V> = isEqualDefault):ReadonlyArray<V> => data.filter(v => !comparer(v, value));\r\n\r\n/**\r\n * Groups data by a grouper function, returning data as a map with string\r\n * keys and array values.\r\n * \r\n * @example\r\n * ```js\r\n * const data = [\r\n *  { age: 39, city: `London` }\r\n *  { age: 14, city: `Copenhagen` }\r\n *  { age: 23, city: `Stockholm` }\r\n *  { age: 56, city: `London` }\r\n * ];\r\n * const map = groupBy(data, item => data.city); \r\n * ```\r\n * \r\n * Returns a map:\r\n * ```js\r\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\r\n * Stockhom: [{ age: 23, city: `Stockholm` }]\r\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\r\n * ```\r\n * @param array Data to group\r\n * @param grouper Function that returns a key for a given item\r\n * @returns Map \r\n */\r\n export const groupBy = <K, V>(array: ReadonlyArray<V>, grouper: (item: V) => K) => array.reduce((store, item) => {\r\n  const key = grouper(item);\r\n  const val = store.get(key);\r\n  if (val === undefined) {\r\n    store.set(key, [item]);\r\n  } else {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    val.push(item);\r\n  }\r\n  return store;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n}, new Map<K, V[]>());","// ✔ UNIT TESTED\r\n\r\nimport { ToString } from \"../util.js\";\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\n\r\ntype MutableValueSetEventMap<V> = {\r\n  readonly add: {readonly value: V, readonly updated: boolean}\r\n  readonly clear: boolean\r\n  readonly delete: V\r\n}\r\n\r\nexport const addUniqueByHash = <V>(set:ReadonlyMap<string, V>|undefined, hashFunc: ToString<V>, ...values:readonly V[]) => {\r\n  const s = set === undefined ? new Map() : new Map(set);\r\n  values.forEach(v => {\r\n    const vStr = hashFunc(v);\r\n    if (s.has(vStr)) return;\r\n    s.set(vStr, v);\r\n  });\r\n  return s;\r\n};\r\n\r\nexport const mutableStringSet = <V>(keyString: ToString<V> | undefined = undefined) => new MutableStringSetImpl(keyString);\r\n\r\nexport type MutableStringSet<V> = {\r\n  readonly add: (item:V) => void\r\n  readonly has: (item:V) => boolean\r\n}\r\n\r\n/**\r\n * A mutable set that stores unique items by their value, rather\r\n * than object reference.\r\n * \r\n * By default the JSON.stringify() representation is used to compare\r\n * objects. Alternatively, pass a function into the constructor\r\n *\r\n * It also fires `add`, `clear` and `delete` events.\r\n * \r\n * Usage\r\n * ```\r\n * .add(item);    // Add one or more items. Items with same key are overriden.\r\n * .has(item);    // Returns true if item *value* is present\r\n * .clear();      // Remove everything\r\n * .delete(item); // Delete item by value\r\n * .toArray();    // Returns values as an array\r\n * .values();     // Returns an iterator over values\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const people = [\r\n *  {name: `Barry`, city: `London`}\r\n *  {name: `Sally`, city: `Bristol`}\r\n * ];\r\n * const set = mutableValueSet(person => {\r\n *  // Key person objects by name and city (assi)\r\n *  return `${person.name}-${person.city}`\r\n * });\r\n * set.add(...people);\r\n * \r\n * set.has({name:`Barry`, city:`Manchester`})); // False, key is different (Barry-Manchester)\r\n * set.has({name:`Barry`, city:`London`}));     // True, we have Barry-London as a key\r\n * set.has(people[1]);   // True, key of object is found (Sally-Bristol)\r\n * \r\n * set.addEventListener(`add`, newItem => {\r\n *  console.log(`New item added: ${newItem}`);\r\n * });\r\n * ```\r\n * \r\n * @export\r\n * @class MutableValueSet\r\n * @template V\r\n */\r\nclass MutableStringSetImpl<V> extends SimpleEventEmitter<MutableValueSetEventMap<V>> {\r\n  // ✔ UNIT TESTED\r\n  /* eslint-disable functional/prefer-readonly-type */\r\n  store = new Map<string, V>();\r\n  keyString: ToString<V>;\r\n\r\n  constructor(keyString: ToString<V> | undefined = undefined) {\r\n    super();\r\n    \r\n    if (keyString === undefined) {\r\n      keyString = (a) => {\r\n        if (typeof a === `string`) { \r\n          return a;\r\n        } else { \r\n          return JSON.stringify(a);\r\n        }\r\n      };\r\n    }\r\n    this.keyString = keyString;\r\n  }\r\n\r\n  add(...v: ReadonlyArray<V>) {\r\n    v.forEach(i => {\r\n      const isUpdated = this.has(i);\r\n      this.store.set(this.keyString(i), i);\r\n      super.fireEvent(`add`, { value: i, updated: isUpdated});\r\n    });\r\n  }\r\n\r\n  values() {\r\n    return this.store.values();\r\n  }\r\n\r\n  clear() {\r\n    this.store.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  delete(v: V): boolean {\r\n    const isDeleted = this.store.delete(this.keyString(v));\r\n    if (isDeleted) super.fireEvent(`delete`, v);\r\n    return isDeleted;\r\n  }\r\n\r\n  has(v: V): boolean {\r\n    return this.store.has(this.keyString(v));\r\n  }\r\n\r\n  toArray(): V[] {\r\n    return Array.from(this.store.values());\r\n  }\r\n}","import {IsEqual} from \"~/util.js\";\r\nimport {ArrayKeys, EitherKey, ObjKeys, ImmutableMap, MutableMap } from \"./Interfaces\";\r\n\r\n// ✔ UNIT TESTED!\r\n\r\n\r\n/**\r\n * Returns true if map contains key\r\n * \r\n * @example\r\n * ```js\r\n * if (has(map, `London`)) ...\r\n * ```\r\n * @param map Map to search\r\n * @param key Key to find\r\n * @returns True if map contains key\r\n */\r\nexport const has = <K, V>(map:ReadonlyMap<K, V>, key:K):boolean => map.has(key);\r\n\r\n/**\r\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\r\n * what key value might be under.\r\n * \r\n * Having a comparer function is useful to check by value rather than object reference.\r\n * \r\n * @example Find key value based on string equality\r\n * ```js\r\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\r\n * ```\r\n * @param map Map to search\r\n * @param key Key to search\r\n * @param value Value to search\r\n * @param comparer Function to determine match\r\n * @returns True if key is found\r\n */\r\nexport const hasKeyValue = <K, V>(map:ReadonlyMap<K, V>, key:K, value:V, comparer:IsEqual<V>):boolean => {\r\n  if (!map.has(key)) return false;\r\n  const values = Array.from(map.values());\r\n  return values.some(v => comparer(v, value));\r\n};\r\n\r\n/**\r\n * Returns true if _any_ key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\r\n * if you only want to find a value under a certain key.\r\n * \r\n * Having a comparer function is useful to check by value rather than object reference.\r\n * @example Finds value `samantha`, using string equality to match\r\n * ```js\r\n * hasAnyValue(map, `samantha`, (a, b) => a === b);\r\n * ```\r\n * @param map Map to search\r\n * @param value Value to find\r\n * @param comparer Function that determines matching\r\n * @returns True if value is found\r\n */\r\nexport const hasAnyValue = <K, V>(map:ReadonlyMap<K, V>, value:V, comparer:IsEqual<V>):boolean => {\r\n  const entries = Array.from(map.entries());\r\n  return entries.some(kv => comparer(kv[1], value));\r\n};\r\n\r\n/**\r\n * Returns items where `predicate` returns true.\r\n * \r\n * If you just want the first match, use `find`\r\n * \r\n * @example All people over thirty\r\n * ```js\r\n * const overThirty = filter(people, person => person.age > 30);\r\n * ```\r\n * @param map Map\r\n * @param predicate Filtering predicate \r\n * @returns Values that match predicate\r\n */\r\nexport const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\r\n\r\n/**\r\n * Copies data to an array\r\n * @param map \r\n * @returns \r\n */\r\nexport const toArray = <V>(map:ReadonlyMap<string, V>):ReadonlyArray<V> => Array.from(map.values());\r\n\r\n/**\r\n * Returns the first found item that matches `predicate` or undefined.\r\n * \r\n * If you want all matches, use `filter`.\r\n * \r\n * @example First person over thirty\r\n * ```js\r\n * const overThirty = find(people, person => person.age > 30);\r\n * ```\r\n * @param map \r\n * @param predicate \r\n * @returns Found item or undefined\r\n */\r\nexport const find = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):V|undefined =>  Array.from(map.values()).find(vv => predicate(vv));\r\n\r\n/**\r\n * Adds an array o [k,v] to the map, returning a new instance\r\n * @param map Initial data\r\n * @param data Data to add\r\n * @returns New map with data added\r\n */\r\nconst addArray = <K, V>(map: ReadonlyMap<K, V>, data:ArrayKeys<K, V>): ReadonlyMap<K, V> => {\r\n  const x = new Map<K, V>(map.entries());\r\n  data.forEach(d => {\r\n    if (d[0] === undefined) throw new Error(`key cannot be undefined`);\r\n    if (d[1] === undefined) throw new Error(`value cannot be undefined`);\r\n    x.set(d[0], d[1]);\r\n  });\r\n  return x;\r\n};\r\n\r\n/**\r\n * Adds objects to the map, returning a new instance\r\n * @param map Initial data\r\n * @param data Data to add\r\n * @returns A new map with data added\r\n */\r\nconst addObjects = <K, V>(map: ReadonlyMap<K, V>, data:ObjKeys<K, V>): ReadonlyMap<K, V> => {\r\n  const x = new Map<K, V>(map.entries());\r\n  data.forEach(d => {\r\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\r\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\r\n\r\n    x.set(d.key, d.value);\r\n  });\r\n  return x;\r\n};\r\n\r\n/**\r\n * Sets data in a copy of the initial map\r\n * @param map Initial map\r\n * @param key Key\r\n * @param value Value to  set\r\n * @returns New map with data set\r\n */\r\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key:K, value:V) => {\r\n  const x = new Map<K, V>(map.entries());\r\n  x.set(key, value);\r\n  return x;\r\n};\r\n\r\n/**\r\n * Adds data to a map, returning the new map.\r\n * \r\n * Can add items in the form of [key,value] or {key, value}.\r\n * @example These all produce the same result\r\n * ```js\r\n * map.set(`hello`, `samantha`);\r\n * map.add([`hello`, `samantha`]);\r\n * map.add({key: `hello`, value: `samantha`})\r\n * ```\r\n * @param map Initial data\r\n * @param data One or more data to add in the form of [key,value] or {key, value} \r\n * @returns New map with data added\r\n */\r\nexport const add = <K, V>(map: ReadonlyMap<K, V>, ...data:EitherKey<K, V>): ReadonlyMap<K, V> => {\r\n  if (map === undefined) throw new Error(`map parameter is undefined`);\r\n  if (data === undefined) throw new Error(`data parameter is undefined`);\r\n  if (data.length === 0) return map;\r\n\r\n  const firstRecord = data[0];\r\n  const isObj = typeof (firstRecord as {readonly key:K, readonly value:V}).key !== `undefined` && typeof (firstRecord as {readonly key:K, readonly value:V}).value !== `undefined`;  //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\r\n  return isObj ? addObjects(map, data as ObjKeys<K, V>) : addArray(map, data as ArrayKeys<K, V>);\r\n};\r\n\r\n/**\r\n * Delete a key from the map, returning a new map\r\n * @param map Initial data\r\n * @param key \r\n * @returns New map with data deleted\r\n */\r\nexport const del = <K, V>(map: ReadonlyMap<K, V>, key: K): ReadonlyMap<K, V> => {\r\n  const x = new Map<K, V>(map.entries());\r\n  x.delete(key);\r\n  return x;\r\n};\r\n\r\n/**\r\n * Returns an {@link ImmutableMap}.\r\n * Use {@link mutableMap} as an alternatve.\r\n * \r\n * @param dataOrMap Optional initial data in the form of an array of {key:value} or [key,value]\r\n * @returns {@link ImmutableMap}\r\n */\r\nexport const map = <K, V>(dataOrMap?: ReadonlyMap<K, V>|EitherKey<K, V>):ImmutableMap<K, V> => {\r\n  if (dataOrMap === undefined) return map([]);\r\n  if (Array.isArray(dataOrMap)) return map(add(new Map(), ...dataOrMap));\r\n  const data = dataOrMap as ReadonlyMap<K, V>;\r\n  return {\r\n    add: (...itemsToAdd:EitherKey<K, V>) => {\r\n      const s = add(data, ...itemsToAdd);\r\n      return map(s);\r\n    },\r\n    get: (key:K) => data.get(key),\r\n    delete: (key:K) => map(del(data, key)),\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    clear: () => map(),\r\n    has: (key:K) => data.has(key),\r\n    entries: () => data.entries(),\r\n    isEmpty: () => data.size === 0\r\n  };\r\n};\r\n\r\n// export const without = <V>(map:ReadonlyMap<string, V>, value:V): ReadonlyMap<string,V> => {\r\n//   source.toArray().filter(v => hash(v) !== hash(value))\r\n// }\r\n\r\n/**\r\n * Returns a {@link MutableMap} (which just wraps the in-built Map)\r\n * Use {@link map} for the immutable alternative.\r\n * \r\n * @param data Optional initial data in the form of an array of {key:value} or [key,value]\r\n * @returns {@link MutableMap}\r\n */\r\nexport const mutableMap = <K, V>(...data:EitherKey<K, V>): MutableMap<K, V> => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let m = add(new Map<K, V>(), ...data);\r\n  return {\r\n    add: (...data:EitherKey<K, V>) => {\r\n      m = add(m, ...data);\r\n    },\r\n    delete: (key:K) => {\r\n      m = del(m, key);\r\n    },\r\n    clear: () => {\r\n      m = add(new Map<K, V>());\r\n    },\r\n    set: (key:K, value:V):void => {\r\n      m = set(m, key, value);\r\n    },\r\n    get: (key:K):V|undefined => m.get(key),\r\n    entries: () => m.entries(),\r\n    isEmpty: () => m.size === 0,\r\n    has: (key:K) => has(m, key)\r\n  };\r\n};\r\n\r\n//#region Functions by Kees C. Bakker\r\n// Functions by Kees C. Bakker\r\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\r\n\r\n/**\r\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>\r\n * \r\n * @example\r\n * ```js\r\n * // Convert a map of string->string to string->number\r\n * transformMap<string, string, number>(mapOfStrings, (value, key) => parseInt(value));\r\n * ```\r\n * @param source \r\n * @param transformer \r\n * @returns \r\n */\r\nexport const transformMap = <K, V, R>(\r\n  source: ReadonlyMap<K, V>,\r\n  transformer: (value: V, key: K) => R\r\n) => new Map(\r\n    Array.from(source, v => [v[0], transformer(v[1], v[0])])\r\n  );\r\n\r\n/**\r\n * Zips together an array of keys and values into an object. Requires that \r\n * `keys` and `values` are the same length.\r\n * \r\n * @example\r\n * ```js\r\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\r\n * Yields: { a: 0, b: 1, c: 2}\r\n *```\r\n  * @template V\r\n  * @param keys\r\n  * @param values\r\n  * @return \r\n  */\r\nexport const zipKeyValue = <V>(keys:ReadonlyArray<string>, values:ArrayLike<V|undefined>) => {\r\n  if (keys.length !== values.length) throw new Error(`Keys and values arrays should be same length`);\r\n  return Object.fromEntries(keys.map((k, i) => [k, values[i]]));\r\n};\r\n\r\n/**\r\n * Converts a `Map` to a plain object, useful for serializing to JSON\r\n * \r\n * @example\r\n * ```js\r\n * const str = JSON.stringify(mapToObj(map));\r\n * ```\r\n * @param m \r\n * @returns \r\n */\r\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\r\nexport const mapToObj = <T>(m: ReadonlyMap<string, T>): { readonly [key: string]: T} => Array.from(m).reduce((obj: any, [key, value]) => {\r\n  /* eslint-disable-next-line functional/immutable-data */\r\n  obj[key] = value;\r\n  return obj;\r\n}, {});\r\n\r\n/**\r\n * Converts Map<K,V> to Array<R> with a provided `transformer`\r\n * \r\n * @example Get a list of ages from a map of Person objects\r\n * ```js\r\n * let person = { age: 29, name: `John`};\r\n * map.add(person.name, person);\r\n * const ages = mapToArray<string, People, number>(map, (key, person) => person.age);\r\n * // [29, ...]\r\n * ```\r\n * @param m \r\n * @param transformer \r\n * @returns \r\n */\r\nexport const mapToArray = <K, V, R>(\r\n  m: ReadonlyMap<K, V>,\r\n  transformer: (key: K, item: V) => R\r\n):readonly R[] => Array.from(m.entries()).map(x => transformer(x[0], x[1]));\r\n// End Functions by Kees C. Bakker\r\n//#endregion\r\n"],"mappings":"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","names":[]}