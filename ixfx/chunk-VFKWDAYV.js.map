{"version":3,"sources":["../src/collections/queue/index.ts","../src/collections/queue/QueueFns.ts","../src/collections/queue/Queue.ts","../src/collections/queue/QueueMutable.ts"],"sourcesContent":["export type QueueDiscardPolicy = `older` | `newer` | `additions`;\n\n/**\n * Queue options.\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = queue({capacity: 5, discardPolicy: `newer`});\n * ```\n */\nexport type QueueOpts = {\n  /**\n   * @private\n   */\n  readonly debug?: boolean;\n  /**\n   * Capcity limit\n   */\n  readonly capacity?: number;\n  /**\n   * Default is `additions`, meaning new items are discarded.\n   *\n   * `older`: Removes items front of the queue (ie older items are discarded)\n   *\n   * `newer`: Remove from rear of queue to make space for new items (ie newer items are discarded)\n   *\n   * `additions`: Only adds new items that there are room for (ie. brand new items are discarded)\n   *\n   */\n  readonly discardPolicy?: QueueDiscardPolicy;\n};\n\nexport { type IQueueMutable } from './IQueueMutable.js';\nexport { type IQueue } from './IQueue.js';\nexport { queue } from './Queue.js';\nexport { queueMutable } from './QueueMutable.js';\n","import type { QueueOpts } from './index.js';\n\nexport const debug = (opts: QueueOpts, msg: string): void => {\n  /* eslint-disable-next-line functional/no-expression-statements */\n  opts.debug ? console.log(`queue:${msg}`) : null;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  debug(\n    opts,\n    `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`\n  );\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`:\n      debug(\n        opts,\n        `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n          potentialLength - capacity\n        } toAddLen: ${toAdd.length}`\n      );\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [...queue, ...toAdd.slice(0, toRemove - 1)];\n      }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`:\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n      } else {\n        // Keep some of the old\n        const toAddFinal = toAdd.slice(\n          0,\n          Math.min(toAdd.length, capacity - toRemove + 1)\n        );\n        const toKeep = queue.slice(0, queue.length - toRemove);\n        debug(\n          opts,\n          `trimQueue: toRemove: ${toRemove} keeping: ${JSON.stringify(\n            toKeep\n          )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n            toAddFinal\n          )}`\n        );\n        const t = [...toKeep, ...toAddFinal];\n        debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`:\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [...queue, ...toAdd].slice(toRemove);\n    default:\n      throw new Error(`Unknown overflow policy ${policy}`);\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [...queue, ...toAdd];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${\n        toReturn.length\n      } capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${\n        toReturn.length\n      } expected: ${potentialLength} opts: ${JSON.stringify(opts)}`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[0];\n\nexport const isEmpty = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import type { IQueue } from './IQueue.js';\nimport { peek, isFull, isEmpty, enqueue, dequeue } from './QueueFns.js';\nimport { type QueueOpts } from './index.js';\n\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImpl<V> implements IQueue<V> {\n  readonly opts: QueueOpts;\n  readonly data: ReadonlyArray<V>;\n\n  /**\n   * Creates an instance of Queue.\n   * @param {QueueOpts} opts Options foor queue\n   * @param {V[]} data Initial data. Index 0 is front of queue\n   * @memberof Queue\n   */\n  constructor(opts: QueueOpts, data: ReadonlyArray<V>) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n    this.opts = opts;\n    this.data = data;\n  }\n\n  forEach(fn: (v: V) => void) {\n    //eslint-disable-next-line functional/no-let\n    for (let i = this.data.length - 1; i >= 0; i--) {\n      fn(this.data[i]);\n    }\n  }\n\n  forEachFromFront(fn: (v: V) => void) {\n    // From front of queue\n    this.data.forEach(fn); //(vv) => fn(vv));\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): QueueImpl<V> {\n    return new QueueImpl<V>(this.opts, enqueue(this.opts, this.data, ...toAdd));\n  }\n\n  dequeue(): QueueImpl<V> {\n    return new QueueImpl<V>(this.opts, dequeue(this.opts, this.data));\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * let q = queue();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = queue({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const queue = <V>(\n  opts: QueueOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueue<V> => {\n  opts = { ...opts }; // Make a copy of options\n  return new QueueImpl(opts, [...startingItems]); // Make a copy of array so it can't be modified\n};\n","import { type IQueueMutable } from './IQueueMutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './QueueFns.js';\nimport { type QueueOpts } from './index.js';\n\nexport class QueueMutableImpl<V> implements IQueueMutable<V> {\n  readonly opts: QueueOpts;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V>;\n\n  constructor(opts: QueueOpts, data: ReadonlyArray<V>) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.opts = opts;\n    this.data = data;\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): number {\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = enqueue(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.opts, this.data);\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.opts, this.data);\n    return v;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\n/**\n * Returns a mutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = queue();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = queue({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Items are added in array order. So first item will be at the front of the queue.\n */\nexport function queueMutable<V>(\n  opts: QueueOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueMutable<V> {\n  return new QueueMutableImpl({ ...opts }, [...startingItems]);\n}\n"],"mappings":"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","names":["queue"]}