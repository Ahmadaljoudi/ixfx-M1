{"version":3,"sources":["../src/Generators.ts"],"sourcesContent":["import {sleep} from \"./Timer.js\";\r\n\r\n// const sleep = async function*(timeoutMs:number) {\r\n//   yield new Promise((resolve, reject) => {\r\n//     setTimeout(() => resolve(undefined), timeoutMs);\r\n//   });\r\n// }\r\n\r\n/**\r\n * Returns a series that produces values according to a time interval\r\n * \r\n * Eg produce a random number every 500ms\r\n * ```\r\n * const randomGenerator = atInterval(() => Math.random(), 1000);\r\n * for await (const r of randomGenerator) {\r\n *  // use random value...\r\n * }\r\n * ```\r\n *\r\n * @template V\r\n * @param {number} intervalMs\r\n * @param {() => V} produce\r\n * @returns {Series<V>}\r\n */\r\n export const atInterval = async function*<V>(produce: () => Promise<V>, intervalMs: number) {\r\n  let cancelled = false;\r\n  try {\r\n    while (!cancelled) {\r\n      await sleep(intervalMs);\r\n      if (cancelled) return;\r\n      yield await produce();\r\n    }\r\n  } finally {\r\n    cancelled = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n * Unlike numericRange, numbers might contain rounding errors\r\n * @param {number} interval Interval between numbers\r\n * @param {number} [start=0] Start\r\n * @param {number} [end] End (if undefined, range never ends)\r\n */\r\n export const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  let v = start;\r\n  do {\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n *\r\n * For-loop example:\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * \r\n * If you want more control over when/where incrementing happens...\r\n * ````\r\n * let percent = numericRange(0.1, 0, 1);\r\n * let percentResult = percent.next();\r\n * while (!percentResult.done) {\r\n *  let v = percentResult.value;\r\n *  percentResult = percent.next();\r\n * }\r\n * ```\r\n * \r\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\r\n * number.\r\n * \r\n * @param {number} interval Interval between numbers\r\n * @param {number} [start=0] Start\r\n * @param {number} [end] End (if undefined, range never ends)\r\n * @param {number} [rounding] A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  if (interval <= 0) throw Error(`Interval is expected to be above zero`);\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  do {\r\n    let v = start * rounding;\r\n    while (v <= end) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Continually loops back and forth between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * Usage\r\n * ```\r\n * for (let v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * Alternative:\r\n * ```\r\n * let pp = percentPingPong(0.1, 0.5); // Setup generator one time\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to 0 and 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * @param {number} interval Amount to increment by. Defaults to 10%\r\n * @param {number} offset Starting point. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param {number} rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, offset?: number, rounding: number = 1000) {\r\n  if (offset === undefined && interval > 0) offset = 0;\r\n  else if (offset === undefined && interval < 0) offset = 1;\r\n  else offset = offset as number;\r\n  if (offset > 1 || offset < 0) throw new Error(`offset must be between 0 and 1`);\r\n  return pingPong(interval, 0, 1, offset, rounding);\r\n};\r\n\r\n\r\n/**\r\n * Ping-pongs continually between `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * @param {number} interval Amount to increment by. Use negative numbers to start counting down\r\n * @param {number} lower Lower bound (inclusive)\r\n * @param {number} upper Upper bound (inclusive, must be greater than start)\r\n * @param {number} offset Starting point within bounds (defaults to `lower`)\r\n * @param {number} [rounding=1] Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, offset?: number, rounding: number = 1) {\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(offset)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (offset === undefined) offset = lower;\r\n  else offset = Math.floor(offset * rounding);\r\n  if (offset > upper || offset < lower) throw new Error(`Offset must be within lower and upper`);\r\n\r\n  let v = offset;\r\n  yield v / rounding;\r\n  let firstLoop = true;\r\n  while (true) {\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n"],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBQ,IAAM,aAAa,iBAAmB,SAA2B,YAAoB;AAC3F,MAAI,YAAY;AAChB,MAAI;AACF,WAAO,CAAC,WAAW;AACjB,YAAM,MAAM;AACZ,UAAI;AAAW;AACf,YAAM,MAAM;AAAA;AAAA,YAEd;AACA,gBAAY;AAAA;AAAA;AAYR,IAAM,kBAAkB,WAAW,UAAkB,QAAgB,GAAG,KAAc,YAAqB,OAAO;AACxH,MAAI,YAAY;AAAG,UAAM,IAAI,MAAM;AACnC,MAAI,QAAQ;AAAW,UAAM,OAAO;AACpC,MAAI,IAAI;AACR,KAAG;AACD,WAAO,IAAI,KAAK;AACd,YAAM;AACN,WAAK;AAAA;AAAA,WAEA;AAAA;AAgCJ,IAAM,eAAe,WAAW,UAAkB,QAAgB,GAAG,KAAc,YAAqB,OAAO,UAAmB;AACvI,MAAI,YAAY;AAAG,UAAM,MAAM;AAC/B,aAAW,YAAY;AACvB,MAAI,QAAQ;AAAW,UAAM,OAAO;AAAA;AAC/B,WAAO;AACZ,aAAW,WAAW;AAEtB,KAAG;AACD,QAAI,IAAI,QAAQ;AAChB,WAAO,KAAK,KAAK;AACf,YAAM,IAAI;AACV,WAAK;AAAA;AAAA,WAEA;AAAA;AA0BJ,IAAM,kBAAkB,SAAU,WAAmB,KAAK,QAAiB,WAAmB,KAAM;AACzG,MAAI,WAAW,UAAa,WAAW;AAAG,aAAS;AAAA,WAC1C,WAAW,UAAa,WAAW;AAAG,aAAS;AAAA;AACnD,aAAS;AACd,MAAI,SAAS,KAAK,SAAS;AAAG,UAAM,IAAI,MAAM;AAC9C,SAAO,SAAS,UAAU,GAAG,GAAG,QAAQ;AAAA;AAanC,IAAM,WAAW,WAAW,UAAkB,OAAe,OAAe,QAAiB,WAAmB,GAAG;AACxH,MAAI,OAAO,MAAM;AAAW,UAAM,IAAI,MAAM;AAC5C,MAAI,OAAO,MAAM;AAAQ,UAAM,IAAI,MAAM;AACzC,MAAI,OAAO,MAAM;AAAQ,UAAM,IAAI,MAAM;AACzC,MAAI,OAAO,MAAM;AAAS,UAAM,IAAI,MAAM;AAE1C,MAAI,SAAS;AAAO,UAAM,IAAI,MAAM;AACpC,MAAI,aAAa;AAAG,UAAM,IAAI,MAAM;AACpC,QAAM,WAAW,QAAQ;AACzB,MAAI,KAAK,IAAI,aAAa;AAAU,UAAM,IAAI,MAAM,+BAA+B,gBAAgB;AAEnG,MAAI,eAAe,WAAW;AAG9B,UAAQ,KAAK,MAAM,QAAQ;AAC3B,UAAQ,KAAK,MAAM,QAAQ;AAC3B,aAAW,KAAK,MAAM,KAAK,IAAI,WAAW;AAE1C,MAAI,WAAW;AAAW,aAAS;AAAA;AAC9B,aAAS,KAAK,MAAM,SAAS;AAClC,MAAI,SAAS,SAAS,SAAS;AAAO,UAAM,IAAI,MAAM;AAEtD,MAAI,IAAI;AACR,QAAM,IAAI;AACV,MAAI,YAAY;AAChB,SAAO,MAAM;AACX,QAAI,IAAK,gBAAe,WAAW,CAAC;AACpC,QAAI,gBAAgB,KAAK,OAAO;AAC9B,qBAAe;AACf,UAAI;AACJ,UAAI,MAAM,SAAS,WAAW;AAE5B,YAAI;AAAO,uBAAe;AAAA;AAAA,eAEnB,CAAC,gBAAgB,KAAK,OAAO;AACtC,qBAAe;AACf,UAAI;AACJ,UAAI,MAAM,SAAS,WAAW;AAE5B,YAAI;AAAO,uBAAe;AAAA;AAAA;AAG9B,UAAM,IAAI;AACV,gBAAY;AAAA;AAAA;","names":[]}