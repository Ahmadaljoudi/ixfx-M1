{"version":3,"sources":["../src/Generators.ts","../src/modulation/PingPong.ts"],"sourcesContent":["import {number as guardNumber, integer as guardInteger} from \"./Guards.js\";\nexport {pingPong, pingPongPercent} from './modulation/PingPong.js';\nexport * as IterableAsync from './IterableAsync.js';\n\nexport {interval} from './flow/Interval.js';\nexport {delayLoop} from './flow/Delay.js';\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n * \n * Unlike {@link numericRange}, numbers might contain rounding errors\n * \n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let v = start;\n  //eslint-disable-next-line functional/no-loop-statement\n  do {\n    //eslint-disable-next-line functional/no-loop-statement\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n * \n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n * \n * let percentResult = percent.next().value;\n * ```\n * \n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n * \n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\n  guardNumber(interval,  `nonZero`);\n  \n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\n    if (!negativeInterval && start > end) throw new Error(`Interval of ${interval} will never go from ${start} to ${end}`);\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  //eslint-disable-next-line functional/no-loop-statement\n  do {\n    //eslint-disable-next-line functional/no-let\n    let v = start * rounding;\n    //eslint-disable-next-line functional/no-loop-statement\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n\n  } while (repeating);\n};\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n * \n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => console.log(`Hi`));\n * ```\n * \n * If you want to accumulate return values, consider using\n * {@link Flow.repeat}.\n * @param amount Number of integers to yield \n * @param offset Added to result\n */\nexport const count = function* (amount:number, offset:number = 0) {\n  // Unit tested.\n  guardInteger(amount, ``, `amount`);\n  guardInteger(offset, ``, `offset`);\n\n  if (amount === 0) return;\n  \n  //eslint-disable-next-line functional/no-let\n  let i = 0;\n  //eslint-disable-next-line functional/no-loop-statement\n  do {\n    if (amount < 0) yield -i + offset;\n    else yield i + offset;\n  } while (i++ < Math.abs(amount) - 1);\n};\n\n/**\n * Returns a number range between 0.0-1.0. \n * \n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n * \n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n * \n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns \n */\nexport const numericPercent = function (interval:number = 0.01, repeating:boolean = false, start:number = 0, end = 1) {\n  guardNumber(interval, `percentage`, `interval`);\n  guardNumber(start, `percentage`, `start`);\n  guardNumber(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};","import {number as guardNumber} from \"../Guards.js\";\n\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n * \n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n * \n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * \n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (interval: number = 0.1, lower?: number, upper?: number, start?: number, rounding: number = 1000) {\n  if (lower === undefined) lower = 0;\n  if (upper === undefined) upper = 1;\n  if (start === undefined) start = lower;\n  guardNumber(interval, `bipolar`, `interval`);\n  guardNumber(upper, `bipolar`, `end`);\n  guardNumber(start, `bipolar`, `offset`);\n  guardNumber(lower, `bipolar`, `start`);\n  return pingPong(interval, lower, upper, start, rounding);\n};\n\n/**\n * Ping-pongs continually back and forth `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n * \n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (interval: number, lower: number, upper: number, start?: number, rounding: number = 1) {\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\n  if (interval === undefined) throw new Error(`Parameter 'interval' is undefined`);\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\n\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\n\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\n  const distance = upper - lower;\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\n\n  //eslint-disable-next-line functional/no-let\n  let incrementing = interval > 0;\n\n  // Scale up values by rounding factor\n  upper = Math.floor(upper * rounding);\n  lower = Math.floor(lower * rounding);\n  interval = Math.floor(Math.abs(interval * rounding));\n\n  if (start === undefined) start = lower;\n  else start = Math.floor(start * rounding);\n  if (start > upper || start < lower) throw new Error(`Start (${start/rounding}) must be within lower (${lower/rounding}) and upper (${upper/rounding})`);\n\n  //eslint-disable-next-line functional/no-let\n  let v = start;\n  yield v / rounding;\n  //eslint-disable-next-line functional/no-let\n  let firstLoop = true;\n  //eslint-disable-next-line functional/no-loop-statement\n  while (true) {\n    v = v + (incrementing ? interval : -interval);\n    if (incrementing && v >= upper) {\n      incrementing = false;\n      v = upper;\n      if (v === upper && firstLoop) {\n        // Edge case where we start at upper bound and increment\n        v = lower; incrementing = true;\n      }\n    } else if (!incrementing && v <= lower) {\n      incrementing = true;\n      v = lower;\n      if (v === lower && firstLoop) {\n        // Edge case where we start at lower bound and decrement\n        v = upper; incrementing = false;\n      }\n    }\n    yield v / rounding;\n    firstLoop = false;\n  }\n};\n"],"mappings":"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","names":[]}