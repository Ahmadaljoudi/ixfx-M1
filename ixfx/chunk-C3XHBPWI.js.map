{"version":3,"sources":["../src/flow/StateMachine.ts","../src/Guards.ts"],"sourcesContent":["// ✔ UNIT TESTED\n\nimport { SimpleEventEmitter } from \"../Events.js\";\nimport { isStringArray } from \"../Guards.js\";\n\nexport interface Options {\n  readonly debug?:boolean\n}\n\nexport interface StateChangeEvent {\n  readonly newState:string,\n  readonly priorState:string\n}\n\nexport interface StopEvent {\n  readonly state:string;\n}\n\nexport type StateMachineEventMap = {\n  readonly change:StateChangeEvent\n  readonly stop:StopEvent\n};\n\nexport type StateEvent = (args:unknown, sender:StateMachine)=>void;\nexport type StateHandler = string | StateEvent | null;\n\nexport interface State {\n  readonly [event:string]:StateHandler;\n}\n\nexport interface MachineDescription {\n  readonly [key:string]:string | readonly string[] | null;\n}\n\nexport type DriverResult = {\n  readonly score?:number,\n  readonly state?:string,\n  readonly next?:boolean,\n  readonly reset?:boolean\n}\n\nexport type DriverExpression<V> = (args?:V)=>DriverResult|undefined;\n\nexport type DriverDescription<V> = {\n  readonly select?:`first`|`highest`|`lowest`,\n  readonly tryAll?:boolean\n  readonly expressions:DriverExpression<V> | readonly DriverExpression<V>[];\n}\nexport interface StateDriverDescription<V> {\n  readonly [key:string]:DriverDescription<V> | readonly DriverExpression<V>[] | DriverExpression<V>;\n}\n\n type DriverDescriptionNormalised<V> = {\n  readonly select:`first`|`highest`|`lowest`,\n  readonly tryAll:boolean,\n  readonly expressions:readonly DriverExpression<V>[];\n}\n\n interface StateDriverDescriptionNormalised<V> {\n  readonly [key:string]:DriverDescriptionNormalised<V>;\n}\n\nconst isDriverDescription = <V>(v:DriverDescription<V> | readonly DriverExpression<V>[] | DriverExpression<V>):v is DriverDescription<V> => {\n  if (Array.isArray(v)) return false;\n  const vv = v as DriverDescription<V>;\n  if (typeof vv.expressions !== `undefined`) return true;\n  return false;\n};\n\n/**\n * Returns a machine description based on a list of strings. The final string is the final\n * state.\n * \n * ```js\n * const states = [`one`, `two`, `three`];\n * const sm = StateMachine.create(states[0], descriptionFromList(states));\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const descriptionFromList = (...states:readonly string[]):MachineDescription => {\n  const t = {};\n  // eslint-disable-next-line functional/no-let\n  for (let i=0;i<states.length; i++) {\n    if (i === states.length - 1) {\n      /** @ts-ignore */\n      // eslint-disable-next-line functional/immutable-data \n      t[states[i]] = null;\n    } else {\n      /** @ts-ignore */\n      // eslint-disable-next-line functional/immutable-data\n      t[states[i]] = states[i+1];\n    }\n  }\n  return t;\n};\n\nconst bidirectionalDescriptionFromList = (...states:readonly string[]):MachineDescription => {\n  const t = {};\n  // eslint-disable-next-line functional/no-let\n  for (let i=0;i<states.length; i++) {\n    /** @ts-ignore */\n    // eslint-disable-next-line functional/immutable-data \n    t[states[i]] = [];\n  }\n\n  // eslint-disable-next-line functional/no-let\n  for (let i=0;i<states.length; i++) {\n    /** @ts-ignore */\n    const v = t[states[i]] as string[];\n    if (i === states.length - 1) {\n    // eslint-disable-next-line functional/immutable-data \n      if (states.length > 1) v.push(states[i-1]);\n      else {\n        /** @ts-ignore */\n        // eslint-disable-next-line functional/immutable-data \n        t[states[i]] = null;\n      }   \n    } else {\n      // eslint-disable-next-line functional/immutable-data \n      v.push(states[i+1]);\n      // eslint-disable-next-line functional/immutable-data \n      if (i > 0) v.push(states[i-1]);\n    }\n  }\n  return t;\n};\n\n/**\n * Returns a state machine based on a list of strings. The first string is used as the initial state,\n * the last string is considered the final. To just generate a description, use {@link descriptionFromList}.\n * \n * Changes are unidirectional, in array order. ie, for the list [`a`, `b`, `c`], the changes can be:\n * a -> b -> c -> null (final)\n * \n * Use {@link fromListBidirectional} to have bidirectional state changes.\n * \n * ```js\n * const states = [`one`, `two`, `three`];\n * const sm = StateMachine.fromList(states);\n * ```\n */\nexport const fromList = (...states:readonly string[]):StateMachine => new StateMachine(states[0], descriptionFromList(...states));\n\n/**\n * Returns a state machine based on a list of strings, where states can change forward and backwards.\n * ie, for the list [`a`, `b`, `c`], the changes can be:\n * a <-> b <-> c\n * \n * Use {@link fromList} for unidirectional state changes.\n * @param states \n * @returns \n */\nexport const fromListBidirectional = (...states:readonly string[]):StateMachine => new StateMachine(states[0], bidirectionalDescriptionFromList(...states));\n\n/**\n * Creates a new state machine\n * @param initial Initial state\n * @param m Machine description\n * @param opts Options\n * @returns State machine instance\n */\nexport const create = (initial:string, m:MachineDescription, opts:Options = { debug: false }):StateMachine =>  new StateMachine(initial, m, opts);\n\n/**\n * State machine\n *\n * Machine description is a simple object of possible state names to allowed state(s). Eg. the following\n * has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `Sleep` can only transition to the `wakeup`\n * state, while `wakeup` can transition to either `coffee` or `breakfast`. \n * \n * Use `null` to signify the final state. Multiple states can terminate the machine if desired.\n * ```\n * const description = { \n *  sleep: 'wakeup',\n *  wakeup: ['coffee', 'breakfast'],\n *  coffee: `bike`,\n *  breakfast: `bike`,\n *  bike: null\n * }\n * ```\n * Create the machine with the starting state (`sleep`)\n * ```\n * const machine = StateMachine.create(`sleep`, description);\n * ```\n * \n * Change the state by name:\n * ```\n * machine.state = `wakeup`\n * ```\n * \n * Or request an automatic transition (will use first state if there are several options)\n * ```\n * machine.next();\n * ```\n * \n * Check status\n * ```\n * if (machine.state === `coffee`) ...;\n * if (machine.isDone()) ...\n * ```\n * \n * Listen for state changes\n * ```\n * machine.addEventListener(`change`, (evt) => {\n *  const {priorState, newState} = evt;\n *  console.log(`State change from ${priorState} -> ${newState}`);\n * });\n * ```\n * @export\n * @class StateMachine\n * @extends {SimpleEventEmitter<StateMachineEventMap>}\n */\nexport class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #state:string;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #debug:boolean;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #m:MachineDescription;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #isDone:boolean;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #initial:string;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  #changedAt:number;\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param string initial Initial state\n   * @param MachineDescription m Machine description\n   * @param Options Options for machine (defaults to `{debug:false}`)\n   * @memberof StateMachine\n   */\n  constructor(initial:string, m:MachineDescription, opts:Options = { debug: false }) {\n    super();\n    const [isValid, errorMsg] = StateMachine.validate(initial, m);\n    if (!isValid) throw new Error(errorMsg);\n\n    this.#initial = initial;\n    this.#m = m;\n    this.#debug = opts.debug ?? false;\n    this.#state = initial;\n    this.#isDone = false;\n    this.#changedAt = 0;\n  }\n\n  get states():readonly string[] {\n    return Object.keys(this.#m);\n  }\n\n  static validate(initial:string, m:MachineDescription):readonly [boolean, string]  {\n    // Check that object is structured properly\n    const keys = Object.keys(m);\n    // eslint-disable-next-line functional/prefer-readonly-type\n    const finalStates:string[] = [];\n    const seenKeys = new Set();\n    const seenVals = new Set();\n\n    // eslint-disable-next-line functional/no-let\n    for (let i=0;i<keys.length;i++) {\n      const key = keys[i];\n      if (seenKeys.has(key)) return [false, `Key ${key} is already used`];\n      seenKeys.add(key);\n\n      if (typeof keys[i] !== `string`) return [false, `Key[${i}] is not a string`];\n      const val = m[key];\n      if (val === undefined) return [false, `Key ${key} value is undefined`];\n      if (typeof val === `string`) {\n        seenVals.add(val);\n        if (val === key) return [false, `Loop present for ${key}`];\n      } else if (Array.isArray(val)) {\n        if (!isStringArray(val)) return [false, `Key ${key} value is not an array of strings`];\n        val.forEach(v => seenVals.add(v));\n        if (val.find(v => v === key)) return [false, `Loop present for ${key}`];\n      } else if (val === null) {\n        // eslint-disable-next-line functional/immutable-data\n        finalStates.push(key);\n      } else {\n        return [false, `Key ${key} has a value that is neither null, string or array`];\n      }\n    }\n\n    // Check that all values have a top-level state\n    const seenValsArray = Array.from(seenVals);\n    const missing = seenValsArray.find(v => !seenKeys.has(v));\n    if (missing) return [false, `Potential state '${missing}' does not exist as a top-level state`];\n\n    // Check machine contains intial state\n    if (m[initial] === undefined) return [false, `Initial state ${initial} not present`];\n    return [true, ``];\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   * \n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   * @memberof StateMachine\n   */\n  next():string | null {\n    // Get possible transitions for current state\n    const r = this.#m[this.#state];\n    if (r === null) return null; // At the end\n\n    // If there are multiple options, use the first\n    if (Array.isArray(r)) {\n      // eslint-disable-next-line functional/immutable-data\n      if (typeof r[0] === `string`) this.state = r[0];\n      else throw new Error(`Error in machine description. Potential state array does not contain strings`);\n    } else if (typeof r === `string`) {\n      // eslint-disable-next-line functional/immutable-data\n      this.state = r; // Just one option\n    } else throw new Error(`Error in machine description. Potential state is neither array nor string`);\n    return this.state;\n  }\n\n  /**\n   * Returns true if state machine is in its final state\n   *\n   * @returns\n   * @memberof StateMachine\n   */\n  get isDone():boolean {\n    return this.#isDone;\n  }\n\n  /**\n   * Resets machine to initial state\n   *\n   * @memberof StateMachine\n   */\n  reset() {\n    // eslint-disable-next-line functional/immutable-data\n    this.#isDone = false;\n    // eslint-disable-next-line functional/immutable-data\n    this.#state = this.#initial;\n    this.#changedAt = Date.now();\n  }\n\n  /**\n   * Checks whether a state change is valid.\n   *\n   * @static\n   * @param priorState From state\n   * @param newState To state\n   * @param description Machine description\n   * @returns If valid: [true,''], if invalid: [false, 'Error msg here']\n   * @memberof StateMachine\n   */\n  static isValid(priorState:string, newState:string, description:MachineDescription):readonly [boolean, string] {\n    // Does state exist?\n    if (description[newState] === undefined) return [false, `Machine cannot change to non-existent state ${newState}`];\n\n    // Is transition allowed?\n    const rules = description[priorState];\n    if (Array.isArray(rules)) {\n      if (!rules.includes(newState)) return [false, `Machine cannot change '${priorState} -> ${newState}'. Allowed transitions: ${rules.join(`, `)}`];\n    } else {\n      if (newState !== rules && rules !== `*`) return [false, `Machine cannot '${priorState} -> ${newState}'. Allowed transition: ${rules}`];\n    }\n    return [true, `ok`];\n  }\n\n  isValid(newState:string):readonly [boolean, string] {\n    return StateMachine.isValid(this.state, newState, this.#m);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `StateMachine.isValid` to check validity without changing.\n   * \n   * If `newState` is the same as current state, the request is ignored silently.\n   *\n   * @memberof StateMachine\n   */\n  set state(newState:string) {\n    const priorState = this.#state;\n\n    if (newState === priorState) return;\n\n    const [isValid, errorMsg] = StateMachine.isValid(priorState, newState, this.#m);\n\n    if (!isValid) throw new Error(errorMsg);\n\n    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);\n\n    // eslint-disable-next-line functional/immutable-data\n    this.#state = newState;\n\n    const rules = this.#m[newState];\n    if (rules === null) {\n      // eslint-disable-next-line functional/immutable-data\n      this.#isDone = true;\n    }\n    this.#changedAt = Date.now();\n\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n      if (this.isDone) this.fireEvent(`stop`, { state: newState });\n    }, 1);\n  }\n\n  get state():string {\n    return this.#state;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt():number {\n    return this.#changedAt;\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed():number {\n    return Date.now() - this.#changedAt;\n  }\n}\n\nconst normaliseDriverDescription = <V>(d:DriverDescription<V>):DriverDescriptionNormalised<V> => {\n  const select = d.select ?? `first`;\n  const expressions = Array.isArray(d.expressions) ? d.expressions : [d.expressions];\n  const n:DriverDescriptionNormalised<V> = {\n    select,\n    expressions,\n    tryAll: d.tryAll ?? true\n  };\n  return n;\n};\n\nconst sortResults = (arr:readonly (DriverResult|undefined)[] = []):readonly DriverResult[] => {\n  // Remove undefined\n  const a = arr.filter(v => v !== undefined) as DriverResult[];\n  //eslint-disable-next-line functional/immutable-data\n  a.sort((a, b) => {\n    const aScore = a.score ?? 0;\n    const bScore = b.score ?? 0;\n    \n    if (aScore === bScore) return 0;\n    if (aScore > bScore) return -1;\n    return 1;\n  });\n  return a;\n};\n\n// const sortTest:readonly (DriverResult|undefined)[] = [\n//   { score: 0.4 },\n//   { score: 0 },\n//   undefined,\n//   { score: 1 },\n//   { score: 0.1 }\n// ];\n// console.log(sortResults(sortTest));\n\n/**\n * Drive a state machine. [Demo sketch](https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-regions)\n * \n * A description can be provided with functions to invoke for each named state. \n * The driver will invoke the function(s) corresponding to the current state of the machine.\n * \n * In the below example, it assumes a state machine with states 'init', 'one' and 'two'.\n *\n * ```js\n * StateMachine.drive(stateMachine, {\n *   init: () => {\n *     if (state.distances[0] > 0.1) return;\n *     return { state: `one` };\n *  },\n *   one: () => {\n *     if (state.distances[1] > 0.1) return;\n *     return { next: true };\n *   },\n *   two: () => {\n *     if (state.distances[2] > 0.1) return;\n *     return { reset: true };\n *   },\n *   __fallback:() => {\n *     // Handle case when the other handlers return undefined\n *   }\n * }\n * ```\n * \n * Three additional handlers can be defined: '__done', '__default'  and '__fallback'.\n * * '__done': used when there is no explicit handler for state and machine is done\n * * '__default': used if the state has no named handler\n * * '__fallback': used if there is no handler for state, or handler did not return a usable result.\n * \n * Each state can have a single function or array of functions to act as handlers.\n * The handler needs to return {@link DriverResult}. In the above example, you see\n * how to change to a named state (`{state: 'one'}`), how to trigger `sm.next()` and\n * how to reset the state machine.\n * \n * If the function cannot do anything, it can just return.\n * \n * Multiple functions can be provided to handle a particular state, eg:\n * ```js\n * StateMachine.drive(stateMachine, {\n *  init: [\n *    () => { ... },\n *    () => { ... }\n *  ]\n * })\n * ```\n * \n * When multiple functions are provided, by default the first that returns a result\n * and the result can be executed is used.\n * \n * It's also possible to use the highest or lowest scoring result. To do so, results\n * must have a `score` property, as shown below. Extra syntax also has to be provided\n * instead of a bare array of functions. This is how the logic for selecting results can be\n * set.\n * \n * ```js\n * StateMachine.drive(stateMachine, {\n *   init: {\n *    select: `highest`,\n *    expressions: [\n *     () => { \n *      // some logic...\n *      return { score: 0.1, state: `hello` }\n *     },\n *     () => { \n *      // some logic...\n *       return { score: 0.2, state: `goodbye` }\n *     }\n *    ]\n *   }\n * });\n * ```\n * \n * The score results likely should not be hardcoded as in the above example,\n * but rather based on some other dynamic values influencing what action to take.\n * \n * @param sm \n * @param driver \n * @returns \n */\nexport const drive = <V>(sm:StateMachine, driver:StateDriverDescription<V>) => {\n  const defaultSelect = `first`;\n  // Normalise driver first\n  const d:StateDriverDescriptionNormalised<V> = {};\n  for (const key of Object.keys(driver)) {\n    const branch = driver[key];\n    if (isDriverDescription(branch)) {\n      // @ts-ignore\n      //eslint-disable-next-line functional/immutable-data\n      d[key] = normaliseDriverDescription(branch);\n    } else if (Array.isArray(branch)) {\n      // @ts-ignore\n      //eslint-disable-next-line functional/immutable-data\n      d[key] = {\n        select: defaultSelect,\n        expressions: branch,\n        tryAll: true\n      };\n    } else {\n      // @ts-ignore\n      //eslint-disable-next-line functional/immutable-data\n      d[key] = {\n        select: defaultSelect,\n        tryAll: true,\n        expressions: [branch as DriverExpression<V>]\n      };\n    }\n  }\n\n  const drive = (r:DriverResult):boolean => {\n    try {\n      if (typeof r.next !== undefined && r.next) {\n        sm.next();\n      } else if (typeof r.state !== undefined) {\n        //eslint-disable-next-line functional/immutable-data, @typescript-eslint/no-non-null-assertion\n        sm.state = r.state!;\n      } else if (typeof r.reset !== undefined && r.reset) {\n        sm.reset();\n      } else {\n        throw new Error(`Result has neither 'reset', 'next' nor 'state' properties needed to drive state machine`);\n      }\n      return true;\n    } catch (ex) {\n      console.warn(ex);\n      return false;\n    }\n  };\n\n  const processResultSet = <V>(branch:DriverDescriptionNormalised<V>, resultSet:DriverResult[]) => {\n    for (const result of resultSet) {\n      if (drive(result)) return true;\n      if (!branch.tryAll) break;\n    }\n    return false;\n  };\n  \n  const processBranch = <V>(branch:DriverDescriptionNormalised<V>|null, args?:V) => {\n    if (!branch) return false;\n    //eslint-disable-next-line functional/no-let\n    let handled = false;\n\n    switch (branch.select) {\n    case `first`:\n      for (const expr of branch.expressions) {\n        const r = expr(args);\n        if (!r) continue;\n        if (drive(r)) {\n          handled = true;\n          break;\n        }\n      }\n      break;\n    case `highest`:\n      handled = processResultSet(branch, [...sortResults(branch.expressions.map(e => e(args)))]);\n      break;\n    case `lowest`:\n      handled = processResultSet(branch, [...sortResults(branch.expressions.map(e => e(args)))].reverse());\n      break;\n    default:\n      throw new Error(`Unknown select type: ${branch.select}. Expected first, highest or lowest`);\n    }\n    return handled;\n  };\n\n  const process = (args?:V) => {\n    //eslint-disable-next-line functional/no-let\n    let branch = d[sm.state];\n    if (!branch && sm.isDone) d[`__done`];\n    if (!branch) branch = d[`__default`];\n\n    //eslint-disable-next-line functional/no-let\n    let handled = processBranch(branch, args);\n    if (!handled) {\n      branch = d[`__fallback`];\n      handled = processBranch(branch, args);\n    }\n  };\n  return process;\n};","\nexport type NumberGuardRange = \n/**\n * No range checking\n */\n  `` | \n  /**\n   * Can be any number, except zero\n   */\n  `nonZero` | \n  `positive` | \n  `negative` | \n  /**\n   * Must be above zero\n   */\n  `aboveZero` | \n  `belowZero` | \n  `percentage` | \n  `bipolar`;\n\n/**\n * Throws an error if `t` is not a number or within specified range.\n * Use an empty string for no special range constraints.\n * Alternatives: {@link integer} for additional integer check, {@link percent} for percentage-range.\n * \n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param paramName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns \n */\nexport const number = (value?:number, range:NumberGuardRange = ``, paramName = `?`):boolean => {\n  if (typeof value === `undefined`) throw new Error(`Parameter ${paramName} is undefined`);\n  if (Number.isNaN(value)) throw new Error(`Parameter '${paramName}' is NaN`);\n  if (typeof value !== `number`) throw new Error(`Parameter '${paramName}' is not a number (${value})`);\n  switch (range) {\n  case `positive`:\n    if (value < 0) throw new Error(`Parameter '${paramName}' must be at least zero (${value})`);\n    break;\n  case `negative`:\n    if (value > 0) throw new Error(`Parameter '${paramName}' must be zero or lower (${value})`);\n    break;\n  case `aboveZero`:\n    if (value <= 0) throw new Error(`Parameter '${paramName}' must be above zero (${value})`);\n    break;\n  case `belowZero`:\n    if (value >= 0) throw new Error(`Parameter '${paramName}' must be below zero (${value})`);\n    break;\n  case `percentage`:\n    if (value > 1 || value < 0) throw new Error(`Parameter '${paramName}' must be in percentage range (0 to 1). (${value})`);\n    break;\n  case `nonZero`:\n    if (value === 0) throw new Error(`Parameter '${paramName}' must non-zero. (${value})`);\n    break;\n  case `bipolar`:\n    if (value > 1 || value < -1) throw new Error(`Parameter '${paramName}' must be in bipolar percentage range (-1 to 1). (${value})`);\n    break;\n  }\n  return true;\n};\n\n/**\n * Throws if `value` is _undefined_ or _null_.\n * @param value \n * @param paramName \n */\nexport const nullUndef = (value:any, paramName = '?') => {\n  if (typeof value === `undefined`) throw new Error(`${paramName} param is undefined`);\n  if (value === null) throw new Error(`${paramName} param is null`);\n\n}\n/**\n * Throws an error if `value` is not in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n * \n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param paramName Param name for customising exception message\n * @returns \n */\nexport const percent = (value:number, paramName = `?`) => number(value, `percentage`, paramName);\n\n/**\n * Throws an error if `value` is not an integer, or does not meet guard criteria.\n * See {@link number} for guard details, or use that if integer checking is not required.\n * \n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param paramName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integer = (value:number, range:NumberGuardRange = ``, paramName = `?`) => {\n  // ✔️ Unit tested\n  number(value, range, paramName);\n  if (!Number.isInteger(value)) throw new Error(`Parameter ${paramName} is not an integer`);\n};\n\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n * \n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n * \n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n * \n * @param value \n * @param range \n * @param defaultValue \n * @returns \n */\nexport const integerParse = (value:any, range:NumberGuardRange = ``, defaultValue:number = Number.NaN)  => {\n  // ✔️ Unit tested\n  if (value === undefined) return defaultValue;\n  if (value === null) return defaultValue;\n  try {\n    integer(Number.parseInt (value), range, 'parsed');\n  } catch (ex) {\n    return defaultValue;\n  }\n  return parseInt(value);\n}\n\n/**\n * Returns true if parameter is an array of strings\n * @param value \n * @returns \n */\nexport const isStringArray = (value:unknown):boolean => {\n  if (!Array.isArray(value)) return false;\n  return value.find(v => typeof v !== `string`) === undefined;\n};\n\n/**\n * Throws an error if parameter is not an array\n * @param value\n * @param paramName \n */\nexport const array = (value:unknown, paramName = `?`):void => {\n  if (!Array.isArray(value)) throw new Error(`Parameter '${paramName}' is expected to be an array'`);\n};\n\n/** Throws an error if parameter is not defined */\nexport const defined = <T>(argument:T | undefined):argument is T => argument !== undefined;\n"],"mappings":";;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACqCO,IAAM,SAAS,CAAC,OAAe,QAAyB,IAAI,YAAY,QAAgB;AAC7F,MAAI,OAAO,UAAU;AAAa,UAAM,IAAI,MAAM,aAAa,wBAAwB;AACvF,MAAI,OAAO,MAAM,KAAK;AAAG,UAAM,IAAI,MAAM,cAAc,mBAAmB;AAC1E,MAAI,OAAO,UAAU;AAAU,UAAM,IAAI,MAAM,cAAc,+BAA+B,QAAQ;AACpG,UAAQ,OAAO;AAAA,IACf,KAAK;AACH,UAAI,QAAQ;AAAG,cAAM,IAAI,MAAM,cAAc,qCAAqC,QAAQ;AAC1F;AAAA,IACF,KAAK;AACH,UAAI,QAAQ;AAAG,cAAM,IAAI,MAAM,cAAc,qCAAqC,QAAQ;AAC1F;AAAA,IACF,KAAK;AACH,UAAI,SAAS;AAAG,cAAM,IAAI,MAAM,cAAc,kCAAkC,QAAQ;AACxF;AAAA,IACF,KAAK;AACH,UAAI,SAAS;AAAG,cAAM,IAAI,MAAM,cAAc,kCAAkC,QAAQ;AACxF;AAAA,IACF,KAAK;AACH,UAAI,QAAQ,KAAK,QAAQ;AAAG,cAAM,IAAI,MAAM,cAAc,qDAAqD,QAAQ;AACvH;AAAA,IACF,KAAK;AACH,UAAI,UAAU;AAAG,cAAM,IAAI,MAAM,cAAc,8BAA8B,QAAQ;AACrF;AAAA,IACF,KAAK;AACH,UAAI,QAAQ,KAAK,QAAQ;AAAI,cAAM,IAAI,MAAM,cAAc,8DAA8D,QAAQ;AACjI;AAAA,EACF;AACA,SAAO;AACT;AAOO,IAAM,YAAY,CAAC,OAAW,YAAY,QAAQ;AACvD,MAAI,OAAO,UAAU;AAAa,UAAM,IAAI,MAAM,GAAG,8BAA8B;AACnF,MAAI,UAAU;AAAM,UAAM,IAAI,MAAM,GAAG,yBAAyB;AAElE;AAUO,IAAM,UAAU,CAAC,OAAc,YAAY,QAAQ,OAAO,OAAO,cAAc,SAAS;AAkBxF,IAAM,UAAU,CAAC,OAAc,QAAyB,IAAI,YAAY,QAAQ;AAErF,SAAO,OAAO,OAAO,SAAS;AAC9B,MAAI,CAAC,OAAO,UAAU,KAAK;AAAG,UAAM,IAAI,MAAM,aAAa,6BAA6B;AAC1F;AAsBO,IAAM,eAAe,CAAC,OAAW,QAAyB,IAAI,eAAsB,OAAO,QAAS;AAEzG,MAAI,UAAU;AAAW,WAAO;AAChC,MAAI,UAAU;AAAM,WAAO;AAC3B,MAAI;AACF,YAAQ,OAAO,SAAU,KAAK,GAAG,OAAO,QAAQ;AAAA,EAClD,SAAS,IAAP;AACA,WAAO;AAAA,EACT;AACA,SAAO,SAAS,KAAK;AACvB;AAOO,IAAM,gBAAgB,CAAC,UAA0B;AACtD,MAAI,CAAC,MAAM,QAAQ,KAAK;AAAG,WAAO;AAClC,SAAO,MAAM,KAAK,OAAK,OAAO,MAAM,QAAQ,MAAM;AACpD;AAOO,IAAM,QAAQ,CAAC,OAAe,YAAY,QAAa;AAC5D,MAAI,CAAC,MAAM,QAAQ,KAAK;AAAG,UAAM,IAAI,MAAM,cAAc,wCAAwC;AACnG;;;ADjGA,IAAM,sBAAsB,CAAI,MAA4G;AAC1I,MAAI,MAAM,QAAQ,CAAC;AAAG,WAAO;AAC7B,QAAM,KAAK;AACX,MAAI,OAAO,GAAG,gBAAgB;AAAa,WAAO;AAClD,SAAO;AACT;AAaO,IAAM,sBAAsB,IAAI,WAAgD;AACrF,QAAM,IAAI,CAAC;AAEX,WAAS,IAAE,GAAE,IAAE,OAAO,QAAQ,KAAK;AACjC,QAAI,MAAM,OAAO,SAAS,GAAG;AAG3B,QAAE,OAAO,CAAC,CAAC,IAAI;AAAA,IACjB,OAAO;AAGL,QAAE,OAAO,CAAC,CAAC,IAAI,OAAO,IAAE,CAAC;AAAA,IAC3B;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAM,mCAAmC,IAAI,WAAgD;AAC3F,QAAM,IAAI,CAAC;AAEX,WAAS,IAAE,GAAE,IAAE,OAAO,QAAQ,KAAK;AAGjC,MAAE,OAAO,CAAC,CAAC,IAAI,CAAC;AAAA,EAClB;AAGA,WAAS,IAAE,GAAE,IAAE,OAAO,QAAQ,KAAK;AAEjC,UAAM,IAAI,EAAE,OAAO,CAAC,CAAC;AACrB,QAAI,MAAM,OAAO,SAAS,GAAG;AAE3B,UAAI,OAAO,SAAS;AAAG,UAAE,KAAK,OAAO,IAAE,CAAC,CAAC;AAAA,WACpC;AAGH,UAAE,OAAO,CAAC,CAAC,IAAI;AAAA,MACjB;AAAA,IACF,OAAO;AAEL,QAAE,KAAK,OAAO,IAAE,CAAC,CAAC;AAElB,UAAI,IAAI;AAAG,UAAE,KAAK,OAAO,IAAE,CAAC,CAAC;AAAA,IAC/B;AAAA,EACF;AACA,SAAO;AACT;AAgBO,IAAM,WAAW,IAAI,WAA0C,IAAI,aAAa,OAAO,CAAC,GAAG,oBAAoB,GAAG,MAAM,CAAC;AAWzH,IAAM,wBAAwB,IAAI,WAA0C,IAAI,aAAa,OAAO,CAAC,GAAG,iCAAiC,GAAG,MAAM,CAAC;AASnJ,IAAM,SAAS,CAAC,SAAgB,GAAsB,OAAe,EAAE,OAAO,MAAM,MAAoB,IAAI,aAAa,SAAS,GAAG,IAAI;AAlKhJ;AAqNO,IAAM,gBAAN,cAA2B,mBAAyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBzE,YAAY,SAAgB,GAAsB,OAAe,EAAE,OAAO,MAAM,GAAG;AACjF,UAAM;AApBR;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAWE,UAAM,CAAC,SAAS,QAAQ,IAAI,cAAa,SAAS,SAAS,CAAC;AAC5D,QAAI,CAAC;AAAS,YAAM,IAAI,MAAM,QAAQ;AAEtC,uBAAK,UAAW;AAChB,uBAAK,IAAK;AACV,uBAAK,QAAS,KAAK,SAAS;AAC5B,uBAAK,QAAS;AACd,uBAAK,SAAU;AACf,uBAAK,YAAa;AAAA,EACpB;AAAA,EAEA,IAAI,SAA2B;AAC7B,WAAO,OAAO,KAAK,mBAAK,GAAE;AAAA,EAC5B;AAAA,EAEA,OAAO,SAAS,SAAgB,GAAkD;AAEhF,UAAM,OAAO,OAAO,KAAK,CAAC;AAE1B,UAAM,cAAuB,CAAC;AAC9B,UAAM,WAAW,oBAAI,IAAI;AACzB,UAAM,WAAW,oBAAI,IAAI;AAGzB,aAAS,IAAE,GAAE,IAAE,KAAK,QAAO,KAAK;AAC9B,YAAM,MAAM,KAAK,CAAC;AAClB,UAAI,SAAS,IAAI,GAAG;AAAG,eAAO,CAAC,OAAO,OAAO,qBAAqB;AAClE,eAAS,IAAI,GAAG;AAEhB,UAAI,OAAO,KAAK,CAAC,MAAM;AAAU,eAAO,CAAC,OAAO,OAAO,oBAAoB;AAC3E,YAAM,MAAM,EAAE,GAAG;AACjB,UAAI,QAAQ;AAAW,eAAO,CAAC,OAAO,OAAO,wBAAwB;AACrE,UAAI,OAAO,QAAQ,UAAU;AAC3B,iBAAS,IAAI,GAAG;AAChB,YAAI,QAAQ;AAAK,iBAAO,CAAC,OAAO,oBAAoB,KAAK;AAAA,MAC3D,WAAW,MAAM,QAAQ,GAAG,GAAG;AAC7B,YAAI,CAAC,cAAc,GAAG;AAAG,iBAAO,CAAC,OAAO,OAAO,sCAAsC;AACrF,YAAI,QAAQ,OAAK,SAAS,IAAI,CAAC,CAAC;AAChC,YAAI,IAAI,KAAK,OAAK,MAAM,GAAG;AAAG,iBAAO,CAAC,OAAO,oBAAoB,KAAK;AAAA,MACxE,WAAW,QAAQ,MAAM;AAEvB,oBAAY,KAAK,GAAG;AAAA,MACtB,OAAO;AACL,eAAO,CAAC,OAAO,OAAO,uDAAuD;AAAA,MAC/E;AAAA,IACF;AAGA,UAAM,gBAAgB,MAAM,KAAK,QAAQ;AACzC,UAAM,UAAU,cAAc,KAAK,OAAK,CAAC,SAAS,IAAI,CAAC,CAAC;AACxD,QAAI;AAAS,aAAO,CAAC,OAAO,oBAAoB,8CAA8C;AAG9F,QAAI,EAAE,OAAO,MAAM;AAAW,aAAO,CAAC,OAAO,iBAAiB,qBAAqB;AACnF,WAAO,CAAC,MAAM,EAAE;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAqB;AAEnB,UAAM,IAAI,mBAAK,IAAG,mBAAK,OAAM;AAC7B,QAAI,MAAM;AAAM,aAAO;AAGvB,QAAI,MAAM,QAAQ,CAAC,GAAG;AAEpB,UAAI,OAAO,EAAE,CAAC,MAAM;AAAU,aAAK,QAAQ,EAAE,CAAC;AAAA;AACzC,cAAM,IAAI,MAAM,8EAA8E;AAAA,IACrG,WAAW,OAAO,MAAM,UAAU;AAEhC,WAAK,QAAQ;AAAA,IACf;AAAO,YAAM,IAAI,MAAM,2EAA2E;AAClG,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,SAAiB;AACnB,WAAO,mBAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AAEN,uBAAK,SAAU;AAEf,uBAAK,QAAS,mBAAK;AACnB,uBAAK,YAAa,KAAK,IAAI;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAO,QAAQ,YAAmB,UAAiB,aAA2D;AAE5G,QAAI,YAAY,QAAQ,MAAM;AAAW,aAAO,CAAC,OAAO,+CAA+C,UAAU;AAGjH,UAAM,QAAQ,YAAY,UAAU;AACpC,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,UAAI,CAAC,MAAM,SAAS,QAAQ;AAAG,eAAO,CAAC,OAAO,0BAA0B,iBAAiB,mCAAmC,MAAM,KAAK,IAAI,GAAG;AAAA,IAChJ,OAAO;AACL,UAAI,aAAa,SAAS,UAAU;AAAK,eAAO,CAAC,OAAO,mBAAmB,iBAAiB,kCAAkC,OAAO;AAAA,IACvI;AACA,WAAO,CAAC,MAAM,IAAI;AAAA,EACpB;AAAA,EAEA,QAAQ,UAA4C;AAClD,WAAO,cAAa,QAAQ,KAAK,OAAO,UAAU,mBAAK,GAAE;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,MAAM,UAAiB;AACzB,UAAM,aAAa,mBAAK;AAExB,QAAI,aAAa;AAAY;AAE7B,UAAM,CAAC,SAAS,QAAQ,IAAI,cAAa,QAAQ,YAAY,UAAU,mBAAK,GAAE;AAE9E,QAAI,CAAC;AAAS,YAAM,IAAI,MAAM,QAAQ;AAEtC,QAAI,mBAAK;AAAQ,cAAQ,IAAI,iBAAiB,iBAAiB,UAAU;AAGzE,uBAAK,QAAS;AAEd,UAAM,QAAQ,mBAAK,IAAG,QAAQ;AAC9B,QAAI,UAAU,MAAM;AAElB,yBAAK,SAAU;AAAA,IACjB;AACA,uBAAK,YAAa,KAAK,IAAI;AAE3B,eAAW,MAAM;AACf,WAAK,UAAU,UAAU,EAAE,UAAoB,WAAuB,CAAC;AACvE,UAAI,KAAK;AAAQ,aAAK,UAAU,QAAQ,EAAE,OAAO,SAAS,CAAC;AAAA,IAC7D,GAAG,CAAC;AAAA,EACN;AAAA,EAEA,IAAI,QAAe;AACjB,WAAO,mBAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,YAAmB;AACrB,WAAO,mBAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,UAAiB;AACnB,WAAO,KAAK,IAAI,IAAI,mBAAK;AAAA,EAC3B;AACF;AAjNO,IAAM,eAAN;AAEL;AAEA;AAEA;AAEA;AAEA;AAEA;AAuMF,IAAM,6BAA6B,CAAI,MAA0D;AAC/F,QAAM,SAAS,EAAE,UAAU;AAC3B,QAAM,cAAc,MAAM,QAAQ,EAAE,WAAW,IAAI,EAAE,cAAc,CAAC,EAAE,WAAW;AACjF,QAAM,IAAmC;AAAA,IACvC;AAAA,IACA;AAAA,IACA,QAAQ,EAAE,UAAU;AAAA,EACtB;AACA,SAAO;AACT;AAEA,IAAM,cAAc,CAAC,MAA0C,CAAC,MAA8B;AAE5F,QAAM,IAAI,IAAI,OAAO,OAAK,MAAM,MAAS;AAEzC,IAAE,KAAK,CAACA,IAAG,MAAM;AACf,UAAM,SAASA,GAAE,SAAS;AAC1B,UAAM,SAAS,EAAE,SAAS;AAE1B,QAAI,WAAW;AAAQ,aAAO;AAC9B,QAAI,SAAS;AAAQ,aAAO;AAC5B,WAAO;AAAA,EACT,CAAC;AACD,SAAO;AACT;AA8FO,IAAM,QAAQ,CAAI,IAAiB,WAAqC;AAC7E,QAAM,gBAAgB;AAEtB,QAAM,IAAwC,CAAC;AAC/C,aAAW,OAAO,OAAO,KAAK,MAAM,GAAG;AACrC,UAAM,SAAS,OAAO,GAAG;AACzB,QAAI,oBAAoB,MAAM,GAAG;AAG/B,QAAE,GAAG,IAAI,2BAA2B,MAAM;AAAA,IAC5C,WAAW,MAAM,QAAQ,MAAM,GAAG;AAGhC,QAAE,GAAG,IAAI;AAAA,QACP,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,QAAQ;AAAA,MACV;AAAA,IACF,OAAO;AAGL,QAAE,GAAG,IAAI;AAAA,QACP,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,aAAa,CAAC,MAA6B;AAAA,MAC7C;AAAA,IACF;AAAA,EACF;AAEA,QAAMC,SAAQ,CAAC,MAA2B;AACxC,QAAI;AACF,UAAI,OAAO,EAAE,SAAS,UAAa,EAAE,MAAM;AACzC,WAAG,KAAK;AAAA,MACV,WAAW,OAAO,EAAE,UAAU,QAAW;AAEvC,WAAG,QAAQ,EAAE;AAAA,MACf,WAAW,OAAO,EAAE,UAAU,UAAa,EAAE,OAAO;AAClD,WAAG,MAAM;AAAA,MACX,OAAO;AACL,cAAM,IAAI,MAAM,yFAAyF;AAAA,MAC3G;AACA,aAAO;AAAA,IACT,SAAS,IAAP;AACA,cAAQ,KAAK,EAAE;AACf,aAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,mBAAmB,CAAI,QAAuC,cAA6B;AAC/F,eAAW,UAAU,WAAW;AAC9B,UAAIA,OAAM,MAAM;AAAG,eAAO;AAC1B,UAAI,CAAC,OAAO;AAAQ;AAAA,IACtB;AACA,WAAO;AAAA,EACT;AAEA,QAAM,gBAAgB,CAAI,QAA4C,SAAY;AAChF,QAAI,CAAC;AAAQ,aAAO;AAEpB,QAAI,UAAU;AAEd,YAAQ,OAAO,QAAQ;AAAA,MACvB,KAAK;AACH,mBAAW,QAAQ,OAAO,aAAa;AACrC,gBAAM,IAAI,KAAK,IAAI;AACnB,cAAI,CAAC;AAAG;AACR,cAAIA,OAAM,CAAC,GAAG;AACZ,sBAAU;AACV;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF,KAAK;AACH,kBAAU,iBAAiB,QAAQ,CAAC,GAAG,YAAY,OAAO,YAAY,IAAI,OAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AACzF;AAAA,MACF,KAAK;AACH,kBAAU,iBAAiB,QAAQ,CAAC,GAAG,YAAY,OAAO,YAAY,IAAI,OAAK,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC;AACnG;AAAA,MACF;AACE,cAAM,IAAI,MAAM,wBAAwB,OAAO,2CAA2C;AAAA,IAC5F;AACA,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,CAAC,SAAY;AAE3B,QAAI,SAAS,EAAE,GAAG,KAAK;AACvB,QAAI,CAAC,UAAU,GAAG;AAAQ,QAAE,QAAQ;AACpC,QAAI,CAAC;AAAQ,eAAS,EAAE,WAAW;AAGnC,QAAI,UAAU,cAAc,QAAQ,IAAI;AACxC,QAAI,CAAC,SAAS;AACZ,eAAS,EAAE,YAAY;AACvB,gBAAU,cAAc,QAAQ,IAAI;AAAA,IACtC;AAAA,EACF;AACA,SAAO;AACT;","names":["a","drive"]}