{"version":3,"sources":["../src/collections/Map.ts"],"sourcesContent":["import {IsEqual, ToString} from \"../Util.js\";\r\n\r\n// âœ” UNIT TESTED!\r\n\r\n/**\r\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\r\n * what key value might be under.\r\n * \r\n * Having a comparer function is useful to check by value rather than object reference.\r\n * \r\n * @example Find key value based on string equality\r\n * ```js\r\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\r\n * ```\r\n * @param map Map to search\r\n * @param key Key to search\r\n * @param value Value to search\r\n * @param comparer Function to determine match\r\n * @returns True if key is found\r\n */\r\nexport const hasKeyValue = <K, V>(map:ReadonlyMap<K, V>, key:K, value:V, comparer:IsEqual<V>):boolean => {\r\n  if (!map.has(key)) return false;\r\n  const values = Array.from(map.values());\r\n  return values.some(v => comparer(v, value));\r\n};\r\n\r\nexport type GetOrGenerate<K, V, Z> = (key:K, args?:Z) => Promise<V>;\r\n\r\n/**\r\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\r\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\r\n * \r\n * See {@link getOrGenerateSync} for a synchronous version.\r\n * \r\n * ```\r\n * const m = getOrGenerate(new Map(), (key) => {\r\n *  return key.toUppercase();\r\n * });\r\n * \r\n * // Not contained in map, so it will run the uppercase function,\r\n * // setting the value to the key 'hello'.\r\n * const v = await m(`hello`);  // Yields 'HELLO'\r\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\r\n * ```\r\n * \r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const getOrGenerate = <K, V, Z>(map:Map<K, V>, fn:(key:K, args?:Z)=>Promise<V>|V):GetOrGenerate<K, V, Z> => async (key:K, args?:Z):Promise<V> => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let value = map.get(key);\r\n  if (value !== undefined) return Promise.resolve(value);\r\n  value = await fn(key, args);\r\n  if (value === undefined) throw new Error(`fn returned undefined`);\r\n  map.set(key, value);\r\n  return value;\r\n};\r\n\r\n/**\r\n * @inheritDoc getOrGenerate\r\n * @param map \r\n * @param fn \r\n * @returns \r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const getOrGenerateSync = <K, V, Z>(map:Map<K, V>, fn:(key:K, args?:Z)=>V) => (key:K, args?:Z):V => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let value = map.get(key);\r\n  if (value !== undefined) return value;\r\n  value = fn(key, args);\r\n  map.set(key, value);\r\n  return value;\r\n};\r\n\r\n/**\r\n * Adds items to a map only if their key doesn't already exist \r\n * \r\n * Uses provided {@link Util.ToString} function to create keys for items. Item is only added if it doesn't already exist.\r\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\r\n * \r\n * \r\n * @example\r\n * ```js\r\n * const map = new Map();\r\n * const peopleArray = [ _some people objects..._];\r\n * addUniqueByHash(map, p => p.name, ...peopleArray);\r\n * ```\r\n * @param set \r\n * @param hashFunc \r\n * @param values \r\n * @returns \r\n */\r\nexport const addUniqueByHash = <V>(set:ReadonlyMap<string, V>|undefined, hashFunc: ToString<V>, ...values:readonly V[]) => {\r\n  const s = set === undefined ? new Map() : new Map(set);\r\n  values.forEach(v => {\r\n    const vStr = hashFunc(v);\r\n    if (s.has(vStr)) return;\r\n    s.set(vStr, v);\r\n  });\r\n  return s;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if _any_ key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\r\n * if you only want to find a value under a certain key.\r\n * \r\n * Having a comparer function is useful to check by value rather than object reference.\r\n * @example Finds value where name is 'samantha', regardless of other properties\r\n * ```js\r\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\r\n * ```\r\n * \r\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\r\n * \r\n * @param map Map to search\r\n * @param value Value to find\r\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\r\n * @returns True if value is found\r\n */\r\nexport const hasAnyValue = <K, V>(map:ReadonlyMap<K, V>, value:V, comparer:IsEqual<V>):boolean => {\r\n  const entries = Array.from(map.entries());\r\n  return entries.some(kv => comparer(kv[1], value));\r\n};\r\n\r\n/**\r\n * Returns values where `predicate` returns true.\r\n * \r\n * If you just want the first match, use `find`\r\n * \r\n * @example All people over thirty\r\n * ```js\r\n * // for-of loop\r\n * for (const v of filter(people, person => person.age > 30)) {\r\n * \r\n * }\r\n * // If you want an array\r\n * const overThirty = Array.from(filter(people, person => person.age > 30));\r\n * ```\r\n * @param map Map\r\n * @param predicate Filtering predicate \r\n * @returns Values that match predicate\r\n */\r\n//eslint-disable-next-line func-style\r\nexport function * filter<V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean) {\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for (const v of map.values()) {\r\n    if (predicate(v)) yield v;\r\n  }\r\n}\r\n\r\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\r\n\r\n/**\r\n * Copies data to an array\r\n * @param map \r\n * @returns \r\n */\r\nexport const toArray = <V>(map:ReadonlyMap<string, V>):ReadonlyArray<V> => Array.from(map.values());\r\n\r\n/**\r\n * Returns the first found item that matches `predicate` or _undefined_.\r\n * \r\n * If you want all matches, use {@link filter}.\r\n * \r\n * @example First person over thirty\r\n * ```js\r\n * const overThirty = find(people, person => person.age > 30);\r\n * ```\r\n * @param map Map to search\r\n * @param predicate Function that returns true for a matching item\r\n * @returns Found item or _undefined_\r\n */\r\nexport const find = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):V|undefined =>  Array.from(map.values()).find(vv => predicate(vv));\r\n\r\n/**\r\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link mapToObj}.\r\n * \r\n * ```js\r\n * const map = new Map();\r\n * map.set(`name`, `Alice`);\r\n * map.set(`pet`, `dog`);\r\n * \r\n * const o = mapToObjTransform(map, v => {\r\n *  ...v,\r\n *  registered: true\r\n * });\r\n * \r\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\r\n * ```\r\n * \r\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\r\n * @param m\r\n * @param valueTransform \r\n * @typeParam T Value type of input map\r\n * @typeParam K Value type of destination map\r\n * @returns \r\n */\r\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const mapToObjTransform = <T, K>(m: ReadonlyMap<string, T>, valueTransform: (value: T) => K): {readonly [key: string]: K} => Array.from(m).reduce((obj: any, [key, value]) => {\r\n  const t = valueTransform(value);\r\n  /* eslint-disable-next-line functional/immutable-data */\r\n  obj[key] = t;\r\n  return obj;\r\n}, {});\r\n\r\n/**\r\n * Zips together an array of keys and values into an object. Requires that \r\n * `keys` and `values` are the same length.\r\n * \r\n * @example\r\n * ```js\r\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\r\n * Yields: { a: 0, b: 1, c: 2}\r\n *```\r\n  * @param keys String keys\r\n  * @param values Values\r\n  * @typeParam V Type of values\r\n  * @return Object with keys and values\r\n  */\r\nexport const zipKeyValue = <V>(keys:ReadonlyArray<string>, values:ArrayLike<V|undefined>) => {\r\n  if (keys.length !== values.length) throw new Error(`Keys and values arrays should be same length`);\r\n  return Object.fromEntries(keys.map((k, i) => [k, values[i]]));\r\n};\r\n\r\n\r\n//#region Functions by Kees C. Bakker\r\n// Functions by Kees C. Bakker\r\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\r\n\r\n/**\r\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\r\n * \r\n * @example\r\n * ```js\r\n * const mapOfStrings = new Map();\r\n * mapOfStrings.set(`a`, `10`);\r\n * mapOfStrings.get(`a`); // Yields `10` (a string)\r\n * \r\n * // Convert a map of string->string to string->number\r\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\r\n * \r\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\r\n * ```\r\n * \r\n * If you want to combine values into a single object, consider instead  {@link mapToObjTransform}.\r\n * @param source \r\n * @param transformer \r\n * @typeParam K Type of keys (generally a string)\r\n * @typeParam V Type of input map values\r\n * @typeParam R Type of output map values\r\n * @returns \r\n */\r\nexport const transformMap = <K, V, R>(\r\n  source: ReadonlyMap<K, V>,\r\n  transformer: (value: V, key: K) => R\r\n) => new Map(\r\n    Array.from(source, v => [v[0], transformer(v[1], v[0])])\r\n  );\r\n\r\n\r\n/**\r\n * Converts a `Map` to a plain object, useful for serializing to JSON\r\n * \r\n * @example\r\n * ```js\r\n * const str = JSON.stringify(mapToObj(map));\r\n * ```\r\n * @param m \r\n * @returns \r\n */\r\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\r\nexport const mapToObj = <T>(m: ReadonlyMap<string, T>): { readonly [key: string]: T} => Array.from(m).reduce((obj: any, [key, value]) => {\r\n  /* eslint-disable-next-line functional/immutable-data */\r\n  obj[key] = value;\r\n  return obj;\r\n}, {});\r\n\r\n/**\r\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\r\n * from contained values and for creating a new map based on transformed values from an input map.\r\n * \r\n * @example Get an array of ages from a map of Person objects\r\n * ```js\r\n * let person = { age: 29, name: `John`};\r\n * map.add(person.name, person);\r\n * \r\n * const ages = mapToArray(map, (key, person) => person.age);\r\n * // [29, ...]\r\n * ```\r\n * \r\n * In the above example, the `transformer` function returns a number, but it could\r\n * just as well return a transformed version of the input:\r\n * \r\n * ```js\r\n * // Return with random heights and uppercased name\r\n * mapToArray(map, (key, person) => ({\r\n *  ...person,\r\n *  height: Math.random(),\r\n *  name: person.name.toUpperCase();\r\n * }))\r\n * // Yields:\r\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\r\n * ```\r\n * @param m \r\n * @param transformer A function that takes a key and item, returning a new item.\r\n * @returns \r\n */\r\nexport const mapToArray = <K, V, R>(\r\n  m: ReadonlyMap<K, V>,\r\n  transformer: (key: K, item: V) => R\r\n):readonly R[] => Array.from(m.entries()).map(x => transformer(x[0], x[1]));\r\n// End Functions by Kees C. Bakker\r\n//#endregion\r\n"],"mappings":";;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBO,IAAM,cAAc,CAAO,KAAuB,KAAO,OAAS,aAAgC;AACvG,MAAI,CAAC,IAAI,IAAI,GAAG;AAAG,WAAO;AAC1B,QAAM,SAAS,MAAM,KAAK,IAAI,OAAO,CAAC;AACtC,SAAO,OAAO,KAAK,OAAK,SAAS,GAAG,KAAK,CAAC;AAC5C;AAuBO,IAAM,gBAAgB,CAAU,KAAe,OAA6D,OAAO,KAAO,SAAuB;AAEtJ,MAAI,QAAQ,IAAI,IAAI,GAAG;AACvB,MAAI,UAAU;AAAW,WAAO,QAAQ,QAAQ,KAAK;AACrD,UAAQ,MAAM,GAAG,KAAK,IAAI;AAC1B,MAAI,UAAU;AAAW,UAAM,IAAI,MAAM,uBAAuB;AAChE,MAAI,IAAI,KAAK,KAAK;AAClB,SAAO;AACT;AASO,IAAM,oBAAoB,CAAU,KAAe,OAA2B,CAAC,KAAO,SAAc;AAEzG,MAAI,QAAQ,IAAI,IAAI,GAAG;AACvB,MAAI,UAAU;AAAW,WAAO;AAChC,UAAQ,GAAG,KAAK,IAAI;AACpB,MAAI,IAAI,KAAK,KAAK;AAClB,SAAO;AACT;AAoBO,IAAM,kBAAkB,CAAI,KAAsC,aAA0B,WAAwB;AACzH,QAAM,IAAI,QAAQ,SAAY,oBAAI,IAAI,IAAI,IAAI,IAAI,GAAG;AACrD,SAAO,QAAQ,OAAK;AAClB,UAAM,OAAO,SAAS,CAAC;AACvB,QAAI,EAAE,IAAI,IAAI;AAAG;AACjB,MAAE,IAAI,MAAM,CAAC;AAAA,EACf,CAAC;AACD,SAAO;AACT;AAoBO,IAAM,cAAc,CAAO,KAAuB,OAAS,aAAgC;AAChG,QAAM,UAAU,MAAM,KAAK,IAAI,QAAQ,CAAC;AACxC,SAAO,QAAQ,KAAK,QAAM,SAAS,GAAG,IAAI,KAAK,CAAC;AAClD;AAqBO,iBAAqB,KAA4B,WAA4B;AAElF,aAAW,KAAK,IAAI,OAAO,GAAG;AAC5B,QAAI,UAAU,CAAC;AAAG,YAAM;AAAA,EAC1B;AACF;AASO,IAAM,UAAU,CAAI,QAAgD,MAAM,KAAK,IAAI,OAAO,CAAC;AAe3F,IAAM,OAAO,CAAI,KAA4B,cAA4C,MAAM,KAAK,IAAI,OAAO,CAAC,EAAE,KAAK,QAAM,UAAU,EAAE,CAAC;AA0B1I,IAAM,oBAAoB,CAAO,GAA2B,mBAAiE,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,KAAU,CAAC,KAAK,WAAW;AACnL,QAAM,IAAI,eAAe,KAAK;AAE9B,MAAI,OAAO;AACX,SAAO;AACT,GAAG,CAAC,CAAC;AAgBE,IAAM,cAAc,CAAI,MAA4B,WAAkC;AAC3F,MAAI,KAAK,WAAW,OAAO;AAAQ,UAAM,IAAI,MAAM,8CAA8C;AACjG,SAAO,OAAO,YAAY,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,OAAO,EAAE,CAAC,CAAC;AAC9D;AA8BO,IAAM,eAAe,CAC1B,QACA,gBACG,IAAI,IACL,MAAM,KAAK,QAAQ,OAAK,CAAC,EAAE,IAAI,YAAY,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,CACzD;AAcK,IAAM,WAAW,CAAI,MAA4D,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,KAAU,CAAC,KAAK,WAAW;AAEvI,MAAI,OAAO;AACX,SAAO;AACT,GAAG,CAAC,CAAC;AAgCE,IAAM,aAAa,CACxB,GACA,gBACgB,MAAM,KAAK,EAAE,QAAQ,CAAC,EAAE,IAAI,OAAK,YAAY,EAAE,IAAI,EAAE,EAAE,CAAC;","names":[]}