{"version":3,"sources":["../src/visual/index.ts","../src/visual/Drawing.ts","../src/visual/Plot.ts","../src/visual/Plot2.ts","../src/visual/SceneGraph.ts","../src/visual/Palette.ts","../src/visual/Video.ts"],"sourcesContent":["import * as Drawing from './Drawing.js';\r\nimport * as Svg from './Svg.js';\r\nimport * as Plot from './Plot.js';\r\nimport * as Plot2 from './Plot2.js';\r\n\r\nimport * as Palette from  './Palette';\r\nimport * as Colour from './Colour.js';\r\nimport * as SceneGraph from './SceneGraph.js';\r\n\r\n\r\n/**\r\n * Colour interpolation, scale generation and parsing\r\n * \r\n * Overview\r\n * * {@link interpolate}: Blend colours\r\n * * {@link scale}: Produce colour scale\r\n * * {@link opacity}: Give a colour opacity\r\n */\r\nexport {Colour};\r\n\r\nexport {Palette,  Drawing, Svg, Plot, Plot2, SceneGraph};\r\n\r\nexport * as Video from './Video.js';\r\n\r\n// @ts-ignore\r\n//eslint-disable-next-line functional/immutable-data\r\nif (window !== undefined) window.ixfx = {Drawing, Svg, Plot, Palette, Colour};","import * as Points from '../geometry/Point.js';\r\nimport * as Paths from '../geometry/Path.js';\r\nimport * as Lines from '../geometry/Line.js';\r\nimport {array as guardArray} from '../Guards.js';\r\nimport * as Circles from '../geometry/Circle.js';\r\nimport * as Arcs from '../geometry/Arc.js';\r\nimport * as Beziers from '../geometry/Bezier.js';\r\nimport * as Rects from '../geometry/Rect.js';\r\nimport * as Ellipses from'../geometry/Ellipse.js';\r\nimport * as Colours from '../visual/Colour.js';\r\n\r\n//import * as color2k from 'color2k';\r\n\r\nimport {stack, Stack} from '../collections/index.js';\r\nimport {resolveEl} from '../dom/Util.js';\r\nimport {roundUpToMultiple} from '~/Util.js';\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst PIPI = Math.PI * 2;\r\n\r\ntype CanvasCtxQuery = null | string | CanvasRenderingContext2D | HTMLCanvasElement;\r\n\r\n/**\r\n * Gets a 2d drawing context from canvas element or query, or throws an error\r\n * @param canvasElCtxOrQuery Canvas element reference or DOM query\r\n * @returns Drawing context.\r\n */\r\nexport const getCtx = (canvasElCtxOrQuery:CanvasCtxQuery): CanvasRenderingContext2D => {\r\n  if (canvasElCtxOrQuery === null) throw Error(`canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`);\r\n  if (canvasElCtxOrQuery === undefined) throw Error(`canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`);\r\n  \r\n  const ctx = (canvasElCtxOrQuery instanceof CanvasRenderingContext2D) ?\r\n    canvasElCtxOrQuery : (canvasElCtxOrQuery instanceof HTMLCanvasElement) ?\r\n      canvasElCtxOrQuery.getContext(`2d`) : (typeof canvasElCtxOrQuery === `string`) ?\r\n        resolveEl<HTMLCanvasElement>(canvasElCtxOrQuery).getContext(`2d`): canvasElCtxOrQuery;\r\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\r\n  return ctx;\r\n};\r\n\r\n/**\r\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\r\n * @param ctxOrCanvasEl Drawing context or canvs element reference\r\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\r\n * @returns \r\n */\r\nexport const makeHelper = (ctxOrCanvasEl:CanvasCtxQuery, canvasBounds?:Rects.Rect) => {\r\n  // TODO: Is there a way of automagically defining makeHelper to avoid repetition and keep typesafety and JSDoc?\r\n  const ctx = getCtx(ctxOrCanvasEl);\r\n  return {\r\n    paths(pathsToDraw: Paths.Path[], opts?: DrawingOpts): void {\r\n      paths(ctx, pathsToDraw, opts);\r\n    },\r\n    line(lineToDraw: Lines.Line|Lines.Line[], opts?: DrawingOpts): void {\r\n      line(ctx, lineToDraw, opts);\r\n    },\r\n    rect(rectsToDraw:Rects.RectPositioned|Rects.RectPositioned[], opts?:DrawingOpts & { filled?:boolean}): void {\r\n      rect(ctx, rectsToDraw, opts);\r\n    },\r\n    bezier(bezierToDraw: Beziers.QuadraticBezier|Beziers.CubicBezier, opts?:DrawingOpts): void {\r\n      bezier(ctx, bezierToDraw, opts);\r\n    },\r\n    connectedPoints(pointsToDraw: Points.Point[], opts?: DrawingOpts & {loop?: boolean}): void {\r\n      connectedPoints(ctx, pointsToDraw, opts);\r\n    },\r\n    pointLabels(pointsToDraw: Points.Point[], opts?:DrawingOpts): void {\r\n      pointLabels(ctx, pointsToDraw, opts);\r\n    },\r\n    dot(dotPosition: Points.Point|Points.Point[], opts?: DrawingOpts & {radius: number, outlined?: boolean, filled?: boolean}): void {\r\n      dot(ctx, dotPosition, opts);\r\n    },\r\n    circle(circlesToDraw:Circles.CirclePositioned|Circles.CirclePositioned[], opts:DrawingOpts):void {\r\n      circle(ctx, circlesToDraw, opts);\r\n    },\r\n    arc(arcsToDraw:Arcs.ArcPositioned|Arcs.ArcPositioned[], opts:DrawingOpts):void {\r\n      arc(ctx, arcsToDraw, opts);\r\n    },\r\n    textBlock(lines:string[], opts:DrawingOpts & { anchor:Points.Point, anchorPadding?:number, bounds?: Rects.RectPositioned}):void {\r\n      if (opts.bounds === undefined && canvasBounds !== undefined) opts = {...opts, bounds: {...canvasBounds, x:0, y:0 }};\r\n      textBlock(ctx, lines, opts);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Drawing options\r\n */\r\ntype DrawingOpts = {\r\n  /**\r\n   * Stroke style\r\n   */\r\n  readonly strokeStyle?:string\r\n  /**\r\n   * Fill style\r\n   */\r\n  readonly fillStyle?:string\r\n  /**\r\n   * If true, diagnostic helpers will be drawn\r\n   */\r\n  readonly debug?:boolean\r\n};\r\n\r\n/**\r\n * Creates a drawing op to apply provided options\r\n * @param opts Drawing options that apply\r\n * @returns Stack\r\n */\r\nconst optsOp = (opts:DrawingOpts):StackOp => coloringOp(opts.strokeStyle, opts.fillStyle);\r\n\r\n/**\r\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\r\n * @param ctx Context\r\n * @param opts Options\r\n * @returns \r\n */\r\nconst applyOpts = (ctx:CanvasRenderingContext2D, opts:DrawingOpts = {}):DrawingStack => {\r\n  if (ctx === undefined) throw Error(`ctx undefined`);\r\n\r\n  // Create a drawing stack, pushing an op generated from drawing options\r\n  const stack = drawingStack(ctx).push(optsOp(opts));\r\n  \r\n  // Apply stack to context\r\n  stack.apply();\r\n  return stack;\r\n};\r\n\r\n/**\r\n * Draws one or more arcs.\r\n * @param ctx \r\n * @param arcs \r\n * @param opts \r\n */\r\nexport const arc = (ctx:CanvasRenderingContext2D, arcs:Arcs.ArcPositioned|ReadonlyArray<Arcs.ArcPositioned>, opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (arc:Arcs.ArcPositioned) => {\r\n    ctx.beginPath();\r\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\r\n    ctx.stroke();\r\n  };\r\n\r\n  if (Array.isArray(arcs)) {\r\n    arcs.forEach(draw);\r\n  } else draw(arcs as Arcs.ArcPositioned);\r\n};\r\n\r\n/**\r\n * A drawing stack operation\r\n */\r\ntype StackOp = (ctx:CanvasRenderingContext2D) => void;\r\n\r\n/**\r\n * A drawing stack (immutable)\r\n */\r\ntype DrawingStack = Readonly<{\r\n  /**\r\n   * Push a new drawing op\r\n   * @param op Operation to add\r\n   * @returns stack with added op\r\n   */\r\n  push(op:StackOp):DrawingStack\r\n  /**\r\n   * Pops an operatiomn\r\n   * @returns Drawing stack with item popped\r\n   */\r\n  pop():DrawingStack\r\n  /**\r\n   * Applies drawing stack\r\n   */\r\n  apply():DrawingStack\r\n}>\r\n\r\n/**\r\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\r\n * @param strokeStyle \r\n * @param fillStyle \r\n * @returns \r\n */\r\nconst coloringOp = (strokeStyle:string|CanvasGradient|CanvasPattern|undefined, fillStyle:string|CanvasGradient|CanvasPattern|undefined):StackOp => {\r\n\r\n  const apply = (ctx:CanvasRenderingContext2D) => {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    if (fillStyle) ctx.fillStyle = fillStyle;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\r\n  };\r\n  return apply;\r\n};\r\n\r\n/**\r\n * Creates and returns an immutable drawing stack for a context\r\n * @param ctx Context\r\n * @param stk Initial stack operations\r\n * @returns \r\n */\r\nexport const drawingStack = (ctx:CanvasRenderingContext2D, stk?:Stack<StackOp>):DrawingStack => {\r\n  if (stk === undefined) stk = stack<StackOp>();\r\n\r\n  const push = (op:StackOp):DrawingStack => {\r\n    if (stk === undefined) stk = stack<StackOp>();\r\n    const s = stk.push(op);\r\n    op(ctx);\r\n    return drawingStack(ctx, s);\r\n  };\r\n\r\n  const pop = ():DrawingStack => {\r\n    const s = stk?.pop();\r\n    return drawingStack(ctx, s);\r\n  };\r\n\r\n  const apply = ():DrawingStack => {\r\n    if (stk === undefined) return drawingStack(ctx);\r\n    stk.forEach(op => op(ctx));\r\n    return drawingStack(ctx, stk);\r\n  };\r\n\r\n  return {push, pop, apply};\r\n};\r\n\r\nexport const lineThroughPoints = (ctx:CanvasRenderingContext2D, points:readonly Points.Point[], opts?:DrawingOpts):void => {\r\n  applyOpts(ctx, opts);\r\n  \r\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\r\n  ctx.moveTo((points[0].x), points[0].y);\r\n\r\n  points.forEach((p, index) => {\r\n    if (index + 2 >= points.length) return;\r\n    const pNext = points[index+1];\r\n    const mid = {\r\n      x: (p.x + pNext.x) / 2,\r\n      y: (p.y + pNext.y) / 2\r\n    };\r\n    const cpX1 = (mid.x + p.x) / 2;\r\n    const cpX2 = (mid.x + pNext.x) / 2;\r\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\r\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\r\n  });\r\n};\r\n\r\n/**\r\n * Draws one or more circles. Will draw outline/fill depending on\r\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\r\n * @param ctx \r\n * @param circlesToDraw \r\n * @param opts \r\n */\r\nexport const circle = (ctx:CanvasRenderingContext2D, circlesToDraw:Circles.CirclePositioned|readonly Circles.CirclePositioned[], opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (c:Circles.CirclePositioned) => {\r\n    ctx.beginPath();\r\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\r\n    if (opts.strokeStyle) ctx.stroke();\r\n    if (opts.fillStyle) ctx.fill();\r\n  };\r\n  if (Array.isArray(circlesToDraw)) circlesToDraw.forEach(draw);\r\n  else draw(circlesToDraw as Circles.CirclePositioned);\r\n};\r\n\r\n/**\r\n * Draws one or more ellipses. Will draw outline/fill depending on\r\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\r\n * @param ctx \r\n * @param ellipsesToDraw \r\n * @param opts \r\n */\r\nexport const ellipse = (ctx:CanvasRenderingContext2D, ellipsesToDraw:Ellipses.EllipsePositioned|readonly Ellipses.EllipsePositioned[], opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (e:Ellipses.EllipsePositioned) => {\r\n    ctx.beginPath();\r\n    const rotation = e.rotation ?? 0;\r\n    const startAngle =e.startAngle ?? 0;\r\n    const endAngle = e.endAngle ?? PIPI;\r\n    ctx.ellipse(e.x, e.y, e.radiusX, e.radiusY, rotation, startAngle, endAngle);\r\n    if (opts.strokeStyle) ctx.stroke();\r\n    if (opts.fillStyle) ctx.fill();\r\n  };\r\n  if (Array.isArray(ellipsesToDraw)) ellipsesToDraw.forEach(draw);\r\n  else draw(ellipsesToDraw as Ellipses.EllipsePositioned);\r\n};\r\n\r\n/**\r\n * Draws one or more paths.\r\n * supported paths are quadratic beziers and lines.\r\n * @param ctx\r\n * @param pathsToDraw \r\n * @param opts \r\n */\r\nexport const paths = (ctx: CanvasRenderingContext2D, pathsToDraw: readonly Paths.Path[]|Paths.Path, opts: Readonly<{readonly strokeStyle?: string, readonly debug?: boolean}> = {}) =>  {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (path:Paths.Path) => {\r\n    // Call appropriate drawing function depending on the type of path\r\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\r\n    else if (Lines.isLine(path)) line(ctx, path, opts);\r\n    else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n  };\r\n\r\n  if (Array.isArray(pathsToDraw)) pathsToDraw.forEach(draw);\r\n  else draw(pathsToDraw as Paths.Path);\r\n};\r\n\r\n/**\r\n * Draws a line between all the given points.\r\n *\r\n * @param ctx\r\n * @param pts\r\n */\r\nexport const connectedPoints = (ctx: CanvasRenderingContext2D, pts: readonly Points.Point[], opts: {readonly loop?: boolean, readonly strokeStyle?: string} = {}) => {\r\n  const shouldLoop = opts.loop ?? false;\r\n\r\n  guardArray(pts);\r\n  if (pts.length === 0) return;\r\n\r\n  // Throw an error if any point is invalid\r\n  pts.forEach((pt, i) => Points.guard(pt, `Index ${i}`));\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  // Draw points\r\n  ctx.beginPath();\r\n  ctx.moveTo(pts[0].x, pts[0].y);\r\n  pts.forEach((pt) => ctx.lineTo(pt.x, pt.y));\r\n\r\n  if (shouldLoop) ctx.lineTo(pts[0].x, pts[0].y);\r\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\r\n  ctx.stroke();\r\n};\r\n\r\n/**\r\n * Draws labels for a set of points\r\n * @param ctx \r\n * @param pts Points to draw\r\n * @param opts \r\n * @param labels Labels for points\r\n */\r\nexport const pointLabels = (ctx: CanvasRenderingContext2D, pts: readonly Points.Point[], opts: {readonly fillStyle?:string} = {}, labels?:readonly string[]) => {\r\n  if (pts.length === 0) return;\r\n\r\n  // Throw an error if any point is invalid\r\n  pts.forEach((pt, i) => Points.guard(pt, `Index ${i}`));\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  pts.forEach((pt, i) => {\r\n    const label = (labels !== undefined && i<labels.length) ? labels[i] : i.toString();\r\n    ctx.fillText(label.toString(), pt.x, pt.y);    \r\n  });\r\n};\r\n\r\n/**\r\n * Returns `point` with the canvas's translation matrix applied\r\n * @param ctx \r\n * @param point \r\n * @returns \r\n */\r\nexport const translatePoint = (ctx:CanvasRenderingContext2D, point: Points.Point): Points.Point => {\r\n  const m = ctx.getTransform();\r\n  return {\r\n    x: point.x * m.a + point.y * m.c + m.e,\r\n    y: point.x * m.b + point.y * m.d + m.f\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a new HTML IMG element with a snapshot of the\r\n * canvas. Element will need to be inserted into the document.\r\n * \r\n * ```\r\n * const myCanvas = document.getElementById('someCanvas');\r\n * const el = copyToImg(myCanvas);\r\n * document.getElementById('images').appendChild(el);\r\n * ```\r\n * @param canvasEl \r\n * @returns \r\n */\r\nexport const copyToImg = (canvasEl:HTMLCanvasElement): HTMLImageElement => {\r\n  const img = document.createElement(`img`);\r\n  //eslint-disable-next-line functional/immutable-data\r\n  img.src = canvasEl.toDataURL(`image/jpeg`);\r\n  return img;\r\n};\r\n\r\n/**\r\n * Draws filled circle(s) at provided point(s)\r\n * @param ctx\r\n * @param pos \r\n * @param opts \r\n */\r\nexport const dot = (ctx: CanvasRenderingContext2D, pos: Points.Point|readonly Points.Point[], opts?: DrawingOpts & {readonly radius?: number, readonly outlined?: boolean, readonly filled?: boolean})  => {\r\n  if (opts === undefined) opts = {};\r\n  const radius = opts.radius ?? 10;\r\n  \r\n  applyOpts(ctx, opts);\r\n\r\n  ctx.beginPath();\r\n\r\n  // x&y for arc is the center of circle\r\n  if (Array.isArray(pos)) {\r\n    pos.forEach(p => {\r\n      ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\r\n    });\r\n  } else {\r\n    const p = pos as Points.Point;\r\n    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\r\n  }\r\n\r\n  if (opts.filled || !opts.outlined) ctx.fill();\r\n  if (opts.outlined) ctx.stroke();\r\n};\r\n\r\n\r\n/**\r\n * Draws a cubic or quadratic bezier\r\n * @param ctx \r\n * @param bezierToDraw \r\n * @param opts \r\n */\r\nexport const bezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.QuadraticBezier|Beziers.CubicBezier, opts?: DrawingOpts) => {\r\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\r\n    quadraticBezier(ctx, bezierToDraw, opts);\r\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\r\n    cubicBezier(ctx, bezierToDraw, opts);\r\n  }\r\n};\r\n\r\nconst cubicBezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.CubicBezier, opts: DrawingOpts = {}) => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let stack = applyOpts(ctx, opts);\r\n\r\n  const {a, b, cubic1, cubic2} = bezierToDraw;\r\n  const isDebug = opts.debug ?? false;\r\n\r\n  if (isDebug) {\r\n    /*\r\n     * const ss = ctx.strokeStyle;\r\n     * ctx.strokeStyle = ss;\r\n     */\r\n  }\r\n  ctx.beginPath();\r\n  ctx.moveTo(a.x, a.y);\r\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\r\n  ctx.stroke();\r\n\r\n  if (isDebug) {\r\n    stack = stack.push(optsOp({...opts, \r\n      strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\r\n      fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4)}));\r\n\r\n    stack.apply();\r\n    ctx.moveTo(a.x, a.y);\r\n    ctx.lineTo(cubic1.x, cubic1.y);\r\n    ctx.stroke();\r\n    ctx.moveTo(b.x, b.y);\r\n    ctx.lineTo(cubic2.x, cubic2.y);\r\n    ctx.stroke();\r\n\r\n    ctx.fillText(`a`, a.x + 5, a.y);\r\n    ctx.fillText(`b`, b.x + 5, b.y);\r\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\r\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\r\n\r\n    dot(ctx, cubic1, {radius: 3});\r\n    dot(ctx, cubic2, {radius: 3});\r\n    dot(ctx, a, {radius: 3});\r\n    dot(ctx, b, {radius: 3});\r\n    stack = stack.pop();\r\n    stack.apply();\r\n  }\r\n};\r\n\r\nconst quadraticBezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.QuadraticBezier, opts: DrawingOpts = {}) => {\r\n  const {a, b, quadratic} = bezierToDraw;\r\n  const isDebug = opts.debug ?? false;\r\n  // eslint-disable-next-line functional/no-let\r\n  let stack = applyOpts(ctx, opts);\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(a.x, a.y);\r\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\r\n  ctx.stroke();\r\n\r\n  if (isDebug) {\r\n    /*\r\n     * const fs = ctx.fillStyle;\r\n     * const ss = ctx.strokeStyle;\r\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\r\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\r\n     */\r\n    stack = stack.push(optsOp({...opts, \r\n      strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\r\n      fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4)}));\r\n    connectedPoints(ctx, [a, quadratic, b]);\r\n\r\n    ctx.fillText(`a`, a.x + 5, a.y);\r\n    ctx.fillText(`b`, b.x + 5, b.y);\r\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\r\n    dot(ctx, quadratic, {radius: 3});\r\n    dot(ctx, a, {radius: 3});\r\n    dot(ctx, b, {radius: 3});\r\n    /*\r\n     * ctx.fillStyle = fs;\r\n     * ctx.strokeStyle = ss;\r\n     */\r\n    stack = stack.pop();\r\n    stack.apply();\r\n  }\r\n};\r\n\r\n/**\r\n * Draws one or more lines\r\n * @param ctx\r\n * @param toDraw \r\n * @param opts \r\n */\r\nexport const line = (ctx: CanvasRenderingContext2D, toDraw: Lines.Line|readonly Lines.Line[], opts: {readonly strokeStyle?: string, readonly debug?: boolean} = {}) => {\r\n  const isDebug = opts.debug ?? false;\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (d:Lines.Line) => {\r\n    const {a, b} = d;\r\n    ctx.beginPath();\r\n    ctx.moveTo(a.x, a.y);\r\n    ctx.lineTo(b.x, b.y);\r\n    if (isDebug) { \r\n      ctx.fillText(`a`, a.x, a.y);\r\n      ctx.fillText(`b`, b.x, b.y);\r\n      dot(ctx, a, {radius: 5, strokeStyle: `black`});\r\n      dot(ctx, b, {radius: 5, strokeStyle: `black`});\r\n    }\r\n    ctx.stroke();\r\n  };\r\n\r\n  if (Array.isArray(toDraw)) toDraw.forEach(draw);\r\n  else draw(toDraw as Lines.Line);\r\n};\r\n\r\n/**\r\n * Draws one or more rectangles\r\n * @param ctx\r\n * @param toDraw \r\n * @param opts \r\n */\r\nexport const rect = (ctx: CanvasRenderingContext2D, toDraw: Rects.RectPositioned|readonly Rects.RectPositioned[], opts: DrawingOpts & {readonly filled?:boolean} = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (d:Rects.RectPositioned) => {\r\n    if (opts.filled) ctx.fillRect(d.x, d.y, d.width, d.height);\r\n    ctx.strokeRect(d.x, d.y, d.width, d.height);\r\n\r\n    if (opts.debug) {\r\n      pointLabels(ctx, Rects.getCorners(d), undefined, [`NW`, `NE`, `SE`, `SW`]);\r\n    }\r\n  };\r\n\r\n  if (Array.isArray(toDraw)) toDraw.forEach(draw);\r\n  else draw(toDraw as Rects.RectPositioned);\r\n};\r\n\r\n/**\r\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\r\n * text is empty or undefined, 0 is returned.\r\n * @param ctx \r\n * @param text \r\n * @param widthMultiple \r\n * @returns \r\n */\r\nexport const textWidth = (ctx:CanvasRenderingContext2D, text?:string|null, padding = 0, widthMultiple?:number):number => {\r\n  if (text === undefined || text === null || text.length === 0) return 0;\r\n  const m = ctx.measureText(text);\r\n  if (widthMultiple) return roundUpToMultiple(m.width, widthMultiple) + padding;\r\n  return m.width + padding;\r\n};\r\n\r\n/**\r\n * Draws a block of text. Each array item is considered a line.\r\n * @param ctx\r\n * @param lines \r\n * @param opts \r\n */\r\nexport const textBlock = (ctx:CanvasRenderingContext2D, lines:readonly string[], opts:DrawingOpts & {readonly anchor:Points.Point, readonly anchorPadding?:number, readonly bounds?: Rects.RectPositioned}) => {\r\n  applyOpts(ctx, opts);\r\n  const anchorPadding = opts.anchorPadding ?? 0;\r\n\r\n  const anchor = opts.anchor;\r\n  const bounds = opts.bounds ?? {x:0, y:0, width:1000000, height:1000000};\r\n\r\n  // Measure each line\r\n  const blocks = lines.map(l => ctx.measureText(l));\r\n\r\n  // Get width and height\r\n  const widths = blocks.map(tm => tm.width);\r\n  const heights = blocks.map(tm => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);\r\n\r\n  // Find extremes\r\n  const maxWidth = Math.max(...widths);\r\n  const totalHeight = heights.reduce((acc, val) => acc+val, 0);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let {x, y} = anchor;\r\n\r\n  if (anchor.x + maxWidth > bounds.width) x = bounds.width - (maxWidth + anchorPadding);\r\n  else x -= anchorPadding;\r\n  \r\n  if (x < bounds.x) x = bounds.x + anchorPadding;\r\n\r\n  if (anchor.y + totalHeight > bounds.height) y = bounds.height - (totalHeight + anchorPadding);\r\n  else y -= anchorPadding;\r\n\r\n  if (y < bounds.y) y = bounds.y + anchorPadding;\r\n\r\n  lines.forEach((line, i) => {\r\n    ctx.fillText(line, x, y);\r\n    y += heights[i];\r\n  });\r\n};\r\n\r\nexport type HorizAlign = `left` | `right` | `center`;\r\nexport type VertAlign = `top` | `center` | `bottom`;\r\n\r\n/**\r\n * Draws an aligned text block\r\n */\r\nexport const textBlockAligned = (ctx:CanvasRenderingContext2D, text:readonly string[]|string, opts:DrawingOpts & { readonly bounds: Rects.RectPositioned, readonly horiz?: HorizAlign, readonly vert?:VertAlign}) => {\r\n  const {bounds} = opts;\r\n  const {horiz = `left`, vert = `top`} = opts;\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let lines:readonly string[];\r\n  if (typeof text === `string`) lines = [text];\r\n  else lines = text;\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  ctx.save();\r\n  ctx.translate(bounds.x, bounds.y);\r\n  //eslint-disable-next-line functional/immutable-data\r\n  ctx.textAlign = `left`;\r\n  //eslint-disable-next-line functional/immutable-data\r\n  ctx.textBaseline = `top`;\r\n  const middleX = bounds.width / 2;\r\n  const middleY = bounds.height / 2;\r\n\r\n  // Measure each line\r\n  const blocks = lines.map(l => ctx.measureText(l));\r\n  const heights = blocks.map(tm => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);\r\n  const totalHeight = heights.reduce((acc, val) => acc+val, 0);\r\n  \r\n  //eslint-disable-next-line functional/no-let\r\n  let y = 0;\r\n  if (vert === `center`) y = middleY - totalHeight /2;\r\n  else if (vert === `bottom`) {\r\n    y = bounds.height - totalHeight;\r\n  } \r\n\r\n  lines.forEach((line, i) => {\r\n    //eslint-disable-next-line functional/no-let\r\n    let x = 0;\r\n    if (horiz === `center`) x  = middleX - blocks[i].width / 2;\r\n    else if (horiz === `right`) x = bounds.width - blocks[i].width;\r\n    ctx.fillText(lines[i], x, y);\r\n    y += heights[i];\r\n  });\r\n\r\n  ctx.restore();\r\n};","/* eslint-disable */\r\nimport { minMaxAvg } from '../collections/NumericArrays.js';\r\nimport { CircularArray, MapOfMutable } from '../collections/Interfaces.js';\r\nimport { mapCircular, mapArray} from \"../collections/MapMultiMutable.js\"\r\n\r\nimport { Point} from \"../geometry/Point.js\";\r\nimport { resolveEl, parentSizeCanvas } from \"../dom/Util.js\";\r\nimport {Rect} from '~/geometry/Rect.js';\r\nimport {Colour} from './index.js';\r\n\r\nexport type Plotter = {\r\n  add(value:number, series?:string, skipDrawing?:boolean):void\r\n  drawValue(index:number):void\r\n  clear():void\r\n  dispose():void\r\n}\r\n\r\ntype Series = {\r\n  min:number,\r\n  max:number,\r\n  range:number,\r\n  name:string,\r\n  colour:string\r\n};\r\n\r\ntype DrawingOpts = PlotOpts & {\r\n  x:Axis\r\n  y:Axis\r\n  ctx: CanvasRenderingContext2D\r\n  textHeight: number\r\n  capacity:number\r\n  coalesce:boolean\r\n  margin:number\r\n  canvasSize:Rect\r\n  clearCanvas:boolean\r\n  translucentPlot?:boolean\r\n  highlightIndex?:number\r\n  leadingEdgeDot:boolean\r\n  debug:boolean\r\n  digitsPrecision:number\r\n  lineWidth:number\r\n}\r\n\r\n/**\r\n * Properties for an axis\r\n */\r\nexport type Axis = {\r\n  allowedSeries?:string[]\r\n  /**\r\n   * Name of axis, eg `x`\r\n   */\r\n  name:string,\r\n  /**\r\n   * Colour to use for axis labels\r\n   */\r\n  colour?:string,\r\n  /**\r\n   * Forced scale for values\r\n   */\r\n  scaleRange?:[number,number],\r\n  /**\r\n   * Forced range for labelling, by default\r\n   * uses scaleRange\r\n   */\r\n  labelRange?:[number,number],\r\n  /**\r\n   * Width of axis line\r\n   */\r\n  lineWidth:number,\r\n  /**\r\n   * How line ends\r\n   */\r\n  endWith: `none` | `arrow`,\r\n  /**\r\n   * Where to place the name of the axis\r\n   */\r\n  namePosition: `none` | `end` | `side`,\r\n  /**\r\n   * Width for y axis, height for x axis\r\n   */\r\n  textSize: number,\r\n  /**\r\n   * If true, axis labels (ie numeric scale) are shown. Default: true\r\n   */\r\n  showLabels:boolean,\r\n  /**\r\n   * If true, a line is drawn to represent axis. Default: true\r\n   */\r\n  showLine:boolean\r\n}\r\n\r\nexport type SeriesColours = {\r\n  [id:string]: string|undefined\r\n};\r\n\r\n/**\r\n * Plotter options\r\n */\r\nexport type PlotOpts = {\r\n  debug?:boolean,\r\n  seriesColours?:SeriesColours,\r\n  /**\r\n   * Default: 2\r\n   */\r\n  digitsPrecision?:number,\r\n  x?:Axis,\r\n  y?:Axis,\r\n  plotSize?:Rect\r\n  autoSizeCanvas?:boolean\r\n  style?:`connected` | `dots` | `none`\r\n  //palette?: Palette.Palette\r\n  /**\r\n   * Number of items to keep in the circular array\r\n   * Default: 10\r\n   */\r\n  capacity?:number\r\n  //showYAxis?:boolean\r\n  //showXAxis?:boolean\r\n  //yAxes?: string[]|string\r\n  textHeight?: number\r\n  /**\r\n   * Width of plotted line\r\n   */\r\n  lineWidth?:number\r\n  /**\r\n   * If true, sub-pixel data points are ignored\r\n   */\r\n  coalesce?:boolean\r\n  /**\r\n   * Fixed range to scale Y values. By default normalises values\r\n   * as they come in. This will also determine the y-axis labels and drawing\r\n   */\r\n  //fixedRange?:[number,number]\r\n  /**\r\n   * How many horizontal pixels per data point. If unspecified,\r\n   * it will scale based on width of canvas and capacity.\r\n   */\r\n  //dataXScale?:number\r\n}\r\n\r\nconst piPi = Math.PI *2;\r\n\r\nexport const defaultAxis = (name:string):Axis => ({\r\n  endWith: `none`,\r\n  lineWidth: 1,\r\n  namePosition: 'none',\r\n  name: name,\r\n  showLabels: name === `y`,\r\n  showLine: true,\r\n  textSize: 20\r\n });\r\n\r\nexport const calcScale = (buffer:BufferType, seriesColours?:SeriesColours) => {\r\n  const seriesNames = buffer.keys();\r\n  const scales:Series[] = [];\r\n  seriesNames.forEach(s => {\r\n    const series = buffer.get(s);\r\n    if (series === undefined) return;\r\n\r\n    let {min,max} = minMaxAvg(series);\r\n    let range = max - min;\r\n    \r\n    let colour;\r\n    if (seriesColours !== undefined) {\r\n      colour = seriesColours[s];\r\n    }\r\n    if (colour == undefined) colour = Colour.getCssVariable(`yellow`, `white`);\r\n     \r\n    if (range === 0) {\r\n      range = min;\r\n      min = min - range/2;\r\n      max = max + range/2;\r\n    }\r\n    scales.push({\r\n      min, max, range,\r\n      name: s,\r\n      colour: colour\r\n    })\r\n  });\r\n  return scales;\r\n}\r\n\r\nexport const add = (buffer:BufferType, value:number, series:string = \"\") => {\r\n  buffer.addKeyedValues(series, value);\r\n}\r\n\r\ntype BufferType = MapOfMutable<number, CircularArray<number>> | MapOfMutable<number, ReadonlyArray<number>>;\r\n\r\nexport const drawValue = (index:number, buffer:BufferType, drawing:DrawingOpts) => {\r\n  const c =\r\n  drawing =  {\r\n    ...drawing,\r\n    translucentPlot: true,\r\n    leadingEdgeDot: false\r\n  };\r\n  draw(buffer, drawing);\r\n  \r\n  drawing =  {\r\n    ...drawing,\r\n    highlightIndex: index,\r\n    leadingEdgeDot: true,\r\n    translucentPlot: false,\r\n    style: `none`,\r\n    clearCanvas: false\r\n  };\r\n  draw(buffer, drawing);\r\n};\r\n\r\nconst scaleWithFixedRange = (buffer:BufferType, range:[number,number], drawing:DrawingOpts) => calcScale(buffer, drawing.seriesColours).map((s) => ({...s, range: range[1] - range[0], min: range[0], max: range[1]}));\r\n\r\n/**\r\n * Draws a `buffer` of data with `drawing` options.\r\n * \r\n * @param buffer \r\n * @param drawing \r\n */\r\nexport const draw = (buffer:BufferType, drawing:DrawingOpts) => {\r\n  const {x:xAxis, y:yAxis, ctx, canvasSize} = drawing;\r\n  const margin = drawing.margin;\r\n  const cap = drawing.capacity === 0 ? buffer.lengthMax : drawing.capacity;\r\n  const series = drawing.y.scaleRange ? scaleWithFixedRange(buffer, drawing.y.scaleRange, drawing) : calcScale(buffer, drawing.seriesColours);\r\n\r\n  if (drawing.clearCanvas) ctx.clearRect(0,0,canvasSize.width,canvasSize.height);\r\n  \r\n  if (drawing.debug) {\r\n    ctx.strokeStyle = `orange`;\r\n    ctx.strokeRect(0,0,canvasSize.width, canvasSize.height); \r\n  }\r\n  \r\n  // Move in for margin\r\n  ctx.translate(margin, margin);\r\n\r\n  // Calculate/use plot area\r\n  const plotSize = drawing.plotSize ?? plotSizeFromBounds(canvasSize, drawing);\r\n\r\n  // Draw vertical axes\r\n  const axisSize = {height: plotSize.height + margin + margin, width:plotSize.width};\r\n\r\n  if (yAxis.showLabels || yAxis.showLine) {\r\n    // Draw the labels for each series\r\n    series.forEach(s => {\r\n      if (yAxis.allowedSeries !== undefined) {\r\n        if (!yAxis.allowedSeries.includes(s.name)) return;\r\n      }\r\n      drawYSeriesScale(s, axisSize, drawing);\r\n    });\r\n\r\n    // Draw vertical line\r\n    if (yAxis.showLine) drawYLine(axisSize, series[0], drawing);\r\n  }\r\n\r\n  // Draw x/horizontal axis if needed\r\n  if (xAxis.showLabels || xAxis.showLine) {\r\n    const yPos = yAxis.labelRange ? yAxis.labelRange[0] : series[0].min;\r\n    drawXAxis(plotSize.width, calcYForValue(yPos, series[0], plotSize.height)+margin + xAxis.lineWidth, drawing);\r\n  }\r\n\r\n  const plotDrawing = {\r\n    ...drawing,\r\n    plotSize}\r\n    //,\r\n    //dataXScale: drawing.dataXScale ?? plotSize.width / (cap -1)\r\n  //};\r\n\r\n  // Draw data for each series\r\n  series.forEach(s => {\r\n    const data = buffer.getSource(s.name);\r\n    if (data === undefined) return;\r\n    \r\n    let leadingEdgeIndex = (buffer.typeName === `circular`)  ? (data as CircularArray<number>).pointer - 1: data.length -1;\r\n    if (drawing.highlightIndex !== undefined) leadingEdgeIndex = drawing.highlightIndex; \r\n    ctx.save();\r\n    ctx.translate(0, margin + margin);\r\n    drawSeriesData(s, data, plotSize, plotDrawing, leadingEdgeIndex);\r\n    ctx.restore();\r\n  });\r\n\r\n  ctx.resetTransform();\r\n}\r\n\r\n/**\r\n * Draw vertical axis\r\n * @param series \r\n * @param height \r\n * @param drawing \r\n */\r\nconst drawYSeriesScale = (series:Series, plotSize:Rect, drawing:DrawingOpts) => {\r\n  const {ctx, y, digitsPrecision, margin} = drawing;\r\n  const {width, height} = plotSize;\r\n\r\n  if (drawing.debug) {\r\n    ctx.strokeStyle = `purple`;\r\n    ctx.strokeRect(0,0, y.textSize, height + margin);  \r\n  }\r\n  \r\n  ctx.fillStyle = series.colour.length > 0 ? series.colour : `white`;\r\n\r\n  // Override colour with axis-defined colour\r\n  if (y.colour) ctx.fillStyle = y.colour;\r\n\r\n  // Draw labels\r\n  const min = y.labelRange ? y.labelRange[0] : series.min;\r\n  const max = y.labelRange ? y.labelRange[1] : series.max;\r\n  const range = y.labelRange ? max - min : series.range;\r\n  const mid = min + (range / 2)\r\n  const halfHeight = drawing.textHeight / 2;\r\n\r\n  ctx.textBaseline = `top`;\r\n  ctx.fillText(min.toFixed(digitsPrecision), 0, calcYForValue(min, series, height)-halfHeight);\r\n  ctx.fillText(mid.toFixed(digitsPrecision), 0, calcYForValue(mid, series, height)-halfHeight);\r\n  ctx.fillText(max.toFixed(digitsPrecision), 0, calcYForValue(max, series, height) - margin);\r\n\r\n  ctx.translate(y.textSize + margin, 0);\r\n}\r\n\r\nconst drawYLine = (plotSize:Rect, series:Series, drawing:DrawingOpts) => {\r\n  const {ctx, y} = drawing;\r\n  const {width, height} = plotSize;\r\n  \r\n  const min = y.labelRange ? y.labelRange[0] : series.min;\r\n  const max = y.labelRange ? y.labelRange[1] : series.max;\r\n\r\n  const minPos = calcYForValue(min, series, height);\r\n  const maxPos = calcYForValue(max, series, height);\r\n\r\n  // Draw line\r\n  ctx.translate(y.lineWidth, 0);\r\n  ctx.lineWidth = y.lineWidth;\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, minPos);\r\n  ctx.lineTo(0, maxPos);\r\n  ctx.strokeStyle = series.colour;\r\n  if (y.colour) ctx.strokeStyle = y.colour;\r\n  ctx.stroke();\r\n  ctx.translate(y.lineWidth, 0);\r\n};\r\n\r\nconst drawXAxis = (width:number, yPos:number, drawing:DrawingOpts) => {\r\n  const {ctx, x, y} = drawing;\r\n\r\n  if (!x.showLine) return;\r\n\r\n  if (x.colour) ctx.strokeStyle = x.colour;\r\n  ctx.lineWidth = x.lineWidth;\r\n  ctx.beginPath();\r\n\r\n  // Assumes ctx is translated after drawing Y axis\r\n  ctx.moveTo(0, yPos);//height-1);\r\n  ctx.lineTo(width, yPos);//height -1);\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Draw series data\r\n * @param series \r\n * @param values \r\n * @param plotSize \r\n * @param drawing \r\n */\r\nconst drawSeriesData = (series:Series, values:ArrayLike<number>, plotSize:Rect, drawing:DrawingOpts, leadingEdgeIndex:number) => {\r\n  const {ctx, lineWidth, translucentPlot = false, margin, x:xAxis} = drawing;\r\n  const style = drawing.style ?? `connected`;\r\n  const height = plotSize.height - margin;\r\n\r\n  let dataXScale = 1;\r\n  if (xAxis.scaleRange) {\r\n    const xAxisRange = xAxis.scaleRange[1] - xAxis.scaleRange[0];\r\n    dataXScale = plotSize.width / xAxisRange;\r\n  } else {\r\n    if (drawing.capacity === 0) dataXScale = plotSize.width / values.length;\r\n    else dataXScale = plotSize.width / drawing.capacity;\r\n  }\r\n\r\n  // Step through data faster if per-pixel density is above one\r\n  const incrementBy = drawing.coalesce ? \r\n    dataXScale! < 0 ? Math.floor((1/dataXScale!)) : 1\r\n    : 1;\r\n\r\n  let x = 0;\r\n  let leadingEdge:Point|undefined;\r\n  \r\n  if (drawing.debug) {\r\n    ctx.strokeStyle = `green`;\r\n    ctx.strokeRect(0,0, plotSize.width, plotSize.height);\r\n  }\r\n\r\n  const colourTransform = (c:string) => {\r\n    if (translucentPlot) return Colour.opacity(c, 0.2);\r\n    return c;\r\n  }\r\n\r\n  if (style === `dots`) { \r\n    ctx.fillStyle = colourTransform(series.colour);// colourTransform(drawing.palette.getOrAdd(`series${series.name}`));\r\n  } else if (style === `none`) {\r\n  } else {\r\n    ctx.beginPath();\r\n    ctx.lineWidth = lineWidth;\r\n    ctx.strokeStyle = colourTransform(series.colour); //colourTransform(drawing.palette.getOrAdd(`series${series.name}`));\r\n  } \r\n\r\n  for (let i=0; i<values.length; i += incrementBy) {\r\n    let y = calcYForValue(values[i], series, height) -1;// (1 - (values[i] - series.min) / series.range) * height;\r\n    \r\n    if (style === `dots`) {\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, lineWidth, 0, piPi);\r\n      ctx.fill();\r\n    } else if (style === `none`) {\r\n    } else  {\r\n      if (i == 0) ctx.moveTo(x, y);\r\n      ctx.lineTo(x, y);\r\n    }\r\n    \r\n    if (i === leadingEdgeIndex) {\r\n      leadingEdge = {x, y}\r\n    }\r\n    x += dataXScale;\r\n  }\r\n\r\n  if (style === `connected`) {\r\n    ctx.stroke();\r\n  }\r\n\r\n  // Draw a circle at latest data point\r\n  if (leadingEdge !== undefined && drawing.leadingEdgeDot) {\r\n    ctx.beginPath();\r\n    ctx.fillStyle = colourTransform(series.colour);// drawing.palette.getOrAdd(`series${series.name}`));\r\n    ctx.arc(leadingEdge.x, leadingEdge.y, 3, 0, 2 * Math.PI);\r\n    ctx.fill();\r\n  }\r\n}\r\n\r\nconst calcYForValue = (v:number, series:Series, height:number) => (1 - (v - series.min) / series.range) * height ;\r\n\r\nconst calcSizing = (margin:number, x:Axis, y:Axis) => {\r\n  let fromLeft = margin;\r\n  if (y.showLabels) fromLeft += y.textSize;\r\n  if (y.showLine) fromLeft += y.lineWidth;\r\n  if (y.showLabels || y.showLine) fromLeft += margin + margin;\r\n  let fromRight = margin;\r\n\r\n  let fromTop = margin + margin;\r\n  let fromBottom = margin + margin;\r\n  if (x.showLabels) fromBottom += x.textSize;\r\n  else fromBottom += margin;\r\n  if (x.showLine) fromBottom += x.lineWidth;\r\n  if (x.showLabels || x.showLine) fromBottom += margin;\r\n\r\n  return {\r\n    left: fromLeft,\r\n    right: fromRight,\r\n    top: fromTop,\r\n    bottom: fromBottom\r\n  };\r\n}\r\n\r\nconst plotSizeFromBounds = (bounds:Rect, opts:{margin:number, y:Axis, x:Axis}):Rect => {\r\n  const { width, height } = bounds;\r\n  const sizing = calcSizing(opts.margin, opts.x, opts.y);\r\n  return {\r\n    width: width - sizing.left - sizing.right, \r\n    height: height - sizing.top - sizing.bottom\r\n  }\r\n};\r\n\r\nconst canvasSizeFromPlot = (plot:Rect, opts:{margin:number, y:Axis, x:Axis}):Rect => {\r\n  const { width, height } = plot;\r\n  const sizing = calcSizing(opts.margin, opts.x, opts.y);\r\n  return {\r\n    width: plot.width + sizing.left + sizing.right,\r\n    height: plot.height + sizing.top + sizing.bottom\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a simple horizontal data plot within a DIV.\r\n * \r\n * ```\r\n * const p = plot(`#parentDiv`);\r\n * p.add(10);\r\n * p.clear();\r\n * \r\n * // Plot data using series\r\n * p.add(-1, `temp`);\r\n * p.add(0.4, `humidty`);\r\n * ```\r\n * \r\n * Options can be specified to customise plot\r\n * ```\r\n * const p = plot(`#parentDiv`, {\r\n *  capacity: 100,     // How many data points to store (default: 10)\r\n *  showYAxis: false,  // Toggle whether y axis is shown (default: true)\r\n *  lineWidth: 2,      // Width of plot line (default: 2)\r\n *  yAxes:  [`temp`],  // Only show these y axes (by default all are shown)\r\n *  palette: Palette,  // Colour palette instance to use\r\n *  coalesce: true,    // If true, sub-pixel data points are skipped, improving performance for dense plots at the expense of plot precision\r\n * });\r\n * ```\r\n * \r\n * For all `capacity` values other than `0`, a circular array is used to track data. Otherwise an array is used that will\r\n * grow infinitely.\r\n * \r\n * By default, will attempt to use CSS variable `--series[seriesName]` for axis colours.\r\n *  `--series[name]-axis` for titles. Eg `--seriesX`. For data added without a named series,\r\n * it will use `--series` and `--series-axis`.\r\n * @param parentElOrQuery\r\n * @param opts\r\n * @return Plotter instance\r\n */\r\nexport const plot = (parentElOrQuery:string|HTMLElement, opts:PlotOpts):Plotter => {\r\n  if (parentElOrQuery === null) throw new Error(`parentElOrQuery is null. Expected string or element`);\r\n\r\n  const parentEl = resolveEl(parentElOrQuery);\r\n  let canvasEl:HTMLCanvasElement;\r\n  let destroyCanvasEl = true;\r\n  let plotSize:Rect|undefined = opts.plotSize;\r\n  let canvasSize:Rect\r\n  if (parentEl.nodeName === `CANVAS`)  {\r\n    // Use provided canvas\r\n    canvasEl = parentEl as HTMLCanvasElement;  \r\n    destroyCanvasEl = false;\r\n    canvasSize = {width: canvasEl.width, height: canvasEl.height};\r\n  } else {\r\n    // Create a CANVAS that fills parent\r\n    //console.log('not reusing');\r\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\r\n    parentEl.append(canvasEl);\r\n    plotSize = opts.plotSize;\r\n    canvasSize = {width: canvasEl.width, height: canvasEl.height};\r\n  }\r\n  \r\n  const ctx = canvasEl.getContext(`2d`)!;\r\n  const capacity = opts.capacity ?? 10;\r\n  const buffer = capacity > 0 ? mapCircular<number>({ capacity }) : mapArray<number>();\r\n  const metrics = ctx.measureText('Xy');\r\n  const coalesce = opts.coalesce ?? true;\r\n\r\n  // Sanity-check\r\n  if (ctx === null) throw new Error(`Drawing context not available`);\r\n\r\n  const xAxis = opts.x ?? defaultAxis(`x`);\r\n  let yAxis = opts.y ?? defaultAxis(`y`);\r\n\r\n  let drawingOpts = {\r\n    ...opts,\r\n    y: yAxis,\r\n    x: xAxis,\r\n\r\n    capacity, coalesce, plotSize, canvasSize, ctx,\r\n    textHeight: opts.textHeight ?? metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\r\n    // palette: opts.palette ?? Palette.create(),\r\n    style: opts.style ?? `connected`,\r\n    margin: 3,\r\n    yLabelWidth: 25,\r\n    clearCanvas:true,\r\n    leadingEdgeDot:true,\r\n    debug: opts.debug ?? false,\r\n    digitsPrecision: opts.digitsPrecision ?? 2,\r\n    lineWidth: opts.lineWidth ?? 2\r\n  };\r\n\r\n  if (plotSize) {\r\n    // Size canvas based on given plot size\r\n    //console.log(`Canvas size from plot`);\r\n    const canvasSize = canvasSizeFromPlot(plotSize, drawingOpts);\r\n    canvasEl.width = canvasSize.width;\r\n    canvasEl.height = canvasSize.height;\r\n    //console.log(`Canvas size from plot: ${canvasSize.width},${canvasSize.height} plot: ${plotSize.width}, ${plotSize.height}`);\r\n    drawingOpts.canvasSize = canvasSize;\r\n  } else {\r\n    //console.log(`Assuming canvas is sized`);\r\n  }\r\n\r\n  //console.log(drawingOpts);\r\n  if (opts.autoSizeCanvas) {\r\n    console.log(`autoSizeCanvas`);\r\n    parentSizeCanvas(canvasEl, (args) => {\r\n      const bounds = args.bounds;\r\n      drawingOpts = {\r\n        ...drawingOpts, \r\n        plotSize: plotSizeFromBounds(bounds, drawingOpts),\r\n        canvasSize: bounds\r\n      };\r\n      draw(buffer, drawingOpts);\r\n\r\n    });\r\n  }\r\n\r\n  return {\r\n    drawValue: (index:number) => {\r\n      drawValue(index, buffer, drawingOpts);\r\n    },\r\n    dispose: () => {\r\n      if (destroyCanvasEl) canvasEl.remove();\r\n    },\r\n    add: (value:number, series = \"\", skipDrawing = false) => {\r\n      add(buffer, value, series);\r\n      if (skipDrawing) return;\r\n      draw(buffer, drawingOpts)\r\n    },\r\n    clear:() => {\r\n      buffer.clear();\r\n    }\r\n  }\r\n}\r\n\r\n","/* eslint-disable */\r\nimport {minIndex} from '~/collections/NumericArrays.js';\r\nimport {PointCalculableShape} from '~/geometry/Point.js';\r\nimport {Arrays} from '../collections/index.js';\r\nimport { Points, Rects} from '../geometry/index.js';\r\nimport {clamp, flip, getFieldByPath, getFieldPaths, ifNaN, roundUpToMultiple, scale} from '../Util.js';\r\nimport { parentSizeCanvas } from \"../dom/Util.js\";\r\nimport * as Sg from './SceneGraph.js';\r\n\r\nimport {textWidth} from './Drawing.js';\r\n\r\ninterface DataSource {\r\n  dirty:boolean\r\n  type: string\r\n  get range():DataRange\r\n  add(value:number):void\r\n}\r\n\r\n/**\r\n * Plot options\r\n */\r\nexport type Opts = {\r\n  /**\r\n   * If true, Canvas will be resized to fit parent\r\n   */\r\n  autoSize?:boolean\r\n  /**\r\n   * Colour for axis lines & labels\r\n   */\r\n  axisColour?:string\r\n  /**\r\n   * Width for axis lines\r\n   */\r\n  axisWidth?:number\r\n}\r\n\r\n/**\r\n * Series options\r\n */\r\nexport type SeriesOpts = {\r\n  /**\r\n   * Colour for series\r\n   */\r\n  colour:string\r\n  /**\r\n   * Visual width/height (depends on drawingStyle)\r\n   */\r\n  width?:number\r\n  /**\r\n   * How series should be rendered\r\n   */\r\n  drawingStyle?: `line`|`dotted`|`bar`\r\n  /**\r\n   * Preferred data range\r\n   */\r\n  axisRange?:DataRange\r\n  /**\r\n   * If true, range will stay at min/max, rather than continuously adapting\r\n   * to the current data range.\r\n   */\r\n  visualRangeStretch?:boolean\r\n};\r\n\r\ntype DataPoint = {\r\n  value:number\r\n  index:number\r\n  title?:string\r\n};\r\n\r\n\r\ntype DataHitPoint = (pt:Points.Point) => [point: DataPoint|undefined, distance: number];\r\n\r\n\r\nclass ArrayDataSource implements DataSource {\r\n  data:number[];\r\n  series:Series;\r\n  dirty = false;\r\n  type = `array`;\r\n\r\n  _range:Arrays.MinMaxAvgTotal|undefined;\r\n  \r\n  constructor(series:Series) {\r\n    this.series = series;\r\n    this.data = [];\r\n    this.dirty = true;\r\n  }\r\n\r\n  set(data:number[]) {\r\n    this.data = data;\r\n    this.dirty = true;\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  get range():DataRange {\r\n    if (!this.dirty && this._range !== undefined) return this._range;\r\n    this.dirty = false;\r\n    this._range = Arrays.minMaxAvg(this.data);\r\n    return {...this._range, changed: true};\r\n  }\r\n\r\n  add(value:number) {\r\n    this.data = [...this.data, value];\r\n    this.dirty = true;\r\n  }\r\n}\r\n\r\nclass StreamingDataSource extends ArrayDataSource {\r\n  desiredDataPointMinWidth = 5;\r\n  \r\n  constructor(series:Series) {\r\n    super(series);\r\n  }\r\n\r\n  add(value:number) {\r\n    const lastWidth = this.series.lastPxPerPt;\r\n    if (lastWidth > -1 && lastWidth < this.desiredDataPointMinWidth) { \r\n      // Remove older data\r\n      const pts = Math.floor(this.desiredDataPointMinWidth / lastWidth);\r\n      const d = [...this.data.slice(pts), value];\r\n      super.set(d);\r\n    } else super.add(value);\r\n  }\r\n}\r\n\r\ntype DataRange = {\r\n  min:number,\r\n  max:number,\r\n  changed?:boolean\r\n}\r\n\r\nclass Series {\r\n  name:string;\r\n  colour:string;\r\n  source: DataSource\r\n  drawingStyle:`line`|`dotted`|`bar`;\r\n  width = 3;\r\n  dataHitPoint: DataHitPoint|undefined;\r\n  tooltip?:string;\r\n  precision = 2;\r\n\r\n  // How many pixels wide per data point on last draw\r\n  lastPxPerPt = -1;\r\n\r\n  protected _visualRange:DataRange;\r\n  protected _visualRangeStretch:boolean;\r\n\r\n  constructor(name:string, sourceType:`array`|`stream`, private plot:Plot, opts:SeriesOpts) {\r\n    this.name = name;\r\n\r\n    this.drawingStyle = opts.drawingStyle ?? `line`;\r\n    this.colour = opts.colour;\r\n    this.width = opts.width ?? 3;\r\n    this._visualRange = opts.axisRange ?? {min:Number.NaN,max:Number.NaN};\r\n    this._visualRangeStretch = opts.visualRangeStretch ?? true;\r\n\r\n    if(sourceType === `array`) {\r\n      this.source = new ArrayDataSource(this);\r\n    } else if (sourceType === `stream`) {\r\n      this.source = new StreamingDataSource(this);\r\n    } else throw new Error(`Unknown sourceType. Expected array|stream`);\r\n  }\r\n\r\n  formatValue(v:number) {\r\n    return v.toFixed(this.precision);\r\n  }\r\n\r\n  get visualRange():DataRange {\r\n    let vr = this._visualRange;\r\n    const sourceRange = this.source.range;\r\n    let changed = false;\r\n    if (sourceRange.changed) { \r\n      if (this._visualRangeStretch) {\r\n        // Stretch range to lowest/highest-seen min/max\r\n        const rmin = Math.min(ifNaN(vr.min, sourceRange.min), sourceRange.min);\r\n        const rmax = Math.max(ifNaN(vr.max, sourceRange.max), sourceRange.max);\r\n        if (rmin !== vr.min || rmax !== vr.max) {\r\n          // Changed\r\n          vr = {min:rmin, max:rmax};\r\n          changed = true;\r\n        }\r\n      } else {\r\n        // Use actual range of data\r\n        if (!isRangeEqual(sourceRange, vr)) {\r\n          vr = sourceRange;\r\n          changed = true;\r\n        }\r\n      }\r\n    }\r\n    this._visualRange = vr;\r\n    return {...vr, changed};\r\n  }\r\n\r\n  scaleValue(value:number): number {\r\n    if (this.source === undefined) return value;\r\n    const r = this.visualRange;\r\n    if (r.min == r.max) {\r\n      // No real scale - only received the same value for this series\r\n      return 0.5;\r\n    }\r\n    return scale(value, r.min, r.max);\r\n  }\r\n\r\n  add(value:number) {\r\n    this.source.add(value);\r\n    this.plot.plotArea.needsDrawing = true;\r\n  }\r\n}\r\n\r\nclass PlotArea extends Sg.CanvasBox {\r\n  paddingPx = 3;\r\n  piPi = Math.PI*2;\r\n  // If pointer is more than this distance away from a data point, it's ignored\r\n  pointerDistanceThreshold = 20;\r\n  lastRangeChange = 0;\r\n  pointer:Points.Point|undefined;\r\n\r\n  constructor(private plot:Plot) {\r\n    super(plot, plot.canvasEl, `PlotArea`);\r\n  }\r\n  \r\n  clear() {\r\n    this.lastRangeChange = 0;\r\n    this.pointer = undefined;\r\n  }\r\n\r\n  protected measureSelf(opts: Sg.MeasureState, parent?: Sg.Measurement): Rects.Rect | Rects.RectPositioned | undefined {\r\n    const axisY = opts.getSize(`AxisY`);\r\n    if (axisY === undefined) return;\r\n    \r\n    const legend = opts.getSize(`Legend`);\r\n    if (legend === undefined) return;\r\n\r\n    const axisX = opts.getSize(`AxisX`);\r\n    if (axisX === undefined) return;\r\n\r\n    return {\r\n      x: axisY.width,\r\n      y: 0,\r\n      width: opts.bounds.width - axisY.width,\r\n      height: opts.bounds.height - legend.height - axisX.height,\r\n    };\r\n  }\r\n\r\n  protected onNotify(msg: string, source: Sg.Box): void {\r\n    if (msg === `measureApplied` && source === this.plot.axisY) this._needsLayout = true;  \r\n    if (msg === `measureApplied` && source === this.plot.legend) this._needsLayout = true;  \r\n\r\n  }\r\n\r\n  // protected onClick(p: Points.Point): void {\r\n  //   this.plot.frozen = !this.plot.frozen;    \r\n  // }\r\n\r\n  protected onPointerLeave(): void {\r\n    const series = [...this.plot.series.values()];\r\n    series.forEach(series => {\r\n      series.tooltip = undefined;\r\n    });\r\n    this.pointer = undefined;\r\n    this.plot.legend.onLayoutNeeded();\r\n\r\n  }\r\n\r\n  protected onPointerMove(p: Points.Point): void {\r\n    this.pointer = p;\r\n    this.plot.legend.onLayoutNeeded();\r\n  }\r\n\r\n  protected measurePreflight(): void {\r\n    this.updateTooltip();\r\n      \r\n  }\r\n\r\n  updateTooltip() {\r\n    const p = this.pointer;\r\n    if (p === undefined) return;\r\n    const series = [...this.plot.series.values()];\r\n    series.forEach(series => {\r\n      if (p === undefined) { \r\n        series.tooltip = undefined;\r\n        return;\r\n      }\r\n      if (series.dataHitPoint === undefined) return;\r\n      const v = series.dataHitPoint(p);\r\n      if (v[0] === undefined) return;\r\n      if (v[1] > this.pointerDistanceThreshold) return; // too far away\r\n      series.tooltip = series.formatValue(v[0].value);\r\n      //this.plot.legend.onLayoutNeeded();\r\n    });\r\n    this.plot.legend.needsDrawing = true;\r\n  }\r\n\r\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\r\n    if (this.plot.frozen) return;\r\n    const series = [...this.plot.series.values()];\r\n    ctx.clearRect(0, 0, this.visual.width, this.visual.height);\r\n\r\n    series.forEach(series => {      \r\n      if (series.source.type === `array` || series.source.type === `stream`) {\r\n        const arraySeries = series.source as ArrayDataSource;\r\n        if (arraySeries.data === undefined) return;\r\n        const d = [...arraySeries.data];\r\n        this.drawDataSet(series, d, ctx);\r\n      }\r\n      else console.warn(`Unknown data source type ${series.source.type}`);\r\n    });\r\n  }\r\n\r\n  computeY(series:Series, rawValue:number) {\r\n    const s = series.scaleValue(rawValue);\r\n    return (flip(s)*this.visual.height) + this.paddingPx;\r\n  }\r\n\r\n  drawDataSet(series:Series, d:number[], ctx:CanvasRenderingContext2D): void {\r\n    const padding = this.paddingPx + series.width;\r\n    const v = Rects.subtract(this.visual, padding*2, padding*3.5);\r\n    const pxPerPt = v.width/ d.length;\r\n    \r\n    series.lastPxPerPt = pxPerPt;\r\n    let x = padding;\r\n    \r\n    ctx.strokeStyle = series.colour;\r\n    ctx.lineWidth = series.width;\r\n    const shapes:(DataPoint & PointCalculableShape)[] = [];\r\n  \r\n    series.dataHitPoint = (pt:Points.Point):[DataPoint,number] => {\r\n      const distances = shapes.map(v => Points.distanceToExterior(pt, v));\r\n      const i = minIndex(...distances);\r\n      const closest = shapes[i];\r\n      if (closest === undefined) [undefined,0];\r\n      return [closest, distances[i]];\r\n    };\r\n\r\n    if (series.drawingStyle === `line`) {\r\n      let y = 0;\r\n      ctx.beginPath();\r\n\r\n      for (let i=0;i<d.length;i++) {\r\n        const scaled = clamp(series.scaleValue(d[i]));\r\n     \r\n        y = padding + this.paddingPx + (v.height * flip(scaled));\r\n        shapes.push({x, y, index:i, value:d[i]});\r\n\r\n        if (i == 0) ctx.moveTo(x+pxPerPt/2, y);\r\n        else ctx.lineTo(x+pxPerPt/2,y);\r\n       \r\n        if (y>this.visual.height) console.log(y + ' h: ' + this.visual.height);\r\n        x += pxPerPt;\r\n      }\r\n      ctx.strokeStyle = series.colour;\r\n      ctx.stroke();\r\n    } else if (series.drawingStyle === `dotted`) {\r\n      let y = 0;\r\n      ctx.fillStyle = series.colour;\r\n      for (let i=0;i<d.length;i++) {\r\n        const scaled = series.scaleValue(d[i]);\r\n        y = padding + (v.height * flip(scaled));\r\n        ctx.beginPath();\r\n        ctx.arc(x + pxPerPt/2, y, series.width, 0, this.piPi);\r\n        ctx.fill();\r\n        shapes.push({radius: series.width, x, y, index:i, value: d[i]});\r\n        x += pxPerPt;\r\n      }\r\n    } else if (series.drawingStyle === `bar`) {\r\n      ctx.fillStyle = series.colour;\r\n      const interBarPadding = Math.ceil(pxPerPt*0.1);\r\n      for (let i=0;i<d.length;i++) {\r\n        const scaled = series.scaleValue(d[i]);\r\n        const h = (v.height) * scaled;\r\n        const r = {\r\n          x: x + interBarPadding,\r\n          y: v.height - h + padding,\r\n          width: pxPerPt-interBarPadding,\r\n          height: h,\r\n          index: i,\r\n          value: d[i]\r\n        };\r\n        ctx.fillRect(r.x, r.y, r.width, r.height);\r\n        shapes.push(r);\r\n        x += pxPerPt;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Legend extends Sg.CanvasBox {\r\n  sampleSize = {width:10, height: 10};\r\n  padding = 3;\r\n  widthSnapping = 20;\r\n\r\n  constructor(private plot:Plot) {\r\n    super(plot, plot.canvasEl, `Legend`);\r\n  }\r\n\r\n  clear() {\r\n  }\r\n\r\n  protected measureSelf(opts: Sg.MeasureState, parent?: Sg.Measurement): Rects.Rect | Rects.RectPositioned | undefined {\r\n    const yAxis = opts.measurements.get(`AxisY`);\r\n    const sample = this.sampleSize;\r\n    const widthSnapping= this.widthSnapping;\r\n    const padding = this.padding;\r\n    const ctx = (opts as Sg.CanvasMeasureState).ctx;\r\n    if (yAxis === undefined) return;\r\n\r\n    const usableWidth = opts.bounds.width - yAxis.size.width;\r\n\r\n    const series = this.plot.seriesArray();\r\n    let width = padding;\r\n    for (let i=0;i<series.length;i++) {\r\n      width += sample.width + padding;\r\n      width += textWidth(ctx, series[i].name, padding, widthSnapping);\r\n      width += textWidth(ctx, series[i].tooltip, padding, widthSnapping);\r\n     }\r\n\r\n    const rows = Math.max(1, Math.ceil(width / usableWidth));\r\n    const h = rows * (this.sampleSize.height + this.padding + this.padding);\r\n    return {\r\n      x: yAxis.size.width,\r\n      y: opts.bounds.height - h,\r\n      width: usableWidth,\r\n      height: h\r\n    };\r\n  }\r\n    \r\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\r\n    const series = this.plot.seriesArray();\r\n    const sample = this.sampleSize;\r\n    const padding = this.padding;\r\n    const widthSnapping= this.widthSnapping;\r\n\r\n    let x = padding;\r\n    let y = padding;\r\n    \r\n    ctx.clearRect(0, 0, this.visual.width, this.visual.height);\r\n\r\n    for (let i=0;i<series.length;i++) {\r\n      const s = series[i];\r\n      ctx.fillStyle = s.colour;\r\n      ctx.fillRect(x, y, sample.width, sample.height);\r\n      x += sample.width + padding;\r\n      ctx.textBaseline = `middle`;\r\n      \r\n      ctx.fillText(s.name, x, y + (sample.height/2));\r\n      x += textWidth(ctx, s.name, padding, widthSnapping);\r\n      \r\n      if (s.tooltip) {\r\n        ctx.fillStyle = this.plot.axisColour;\r\n        ctx.fillText(s.tooltip, x, y+ (sample.height/2));\r\n        x += textWidth(ctx, s.tooltip, padding, widthSnapping);\r\n      }\r\n      x += padding;\r\n      if (x > this.visual.width - 100) {\r\n        x = padding;\r\n        y += sample.height + padding + padding;\r\n      }\r\n    }\r\n  }\r\n\r\n  protected onNotify(msg: string, source: Sg.Box): void {\r\n    if (msg === `measureApplied` && source === (this._parent as Plot).axisY) this._needsLayout = true;  \r\n  }\r\n}\r\n\r\nclass AxisX extends Sg.CanvasBox {\r\n  paddingPx = 2;\r\n  colour?:string;\r\n\r\n  constructor(private plot:Plot) {\r\n    super(plot, plot.canvasEl,`AxisX`);\r\n  }\r\n\r\n  clear() {\r\n  }\r\n\r\n  protected onNotify(msg: string, source: Sg.Box): void {\r\n    if (msg === `measureApplied` && source === this.plot.axisY) this._needsLayout = true;  \r\n    if (msg === `measureApplied` && source === this.plot.legend) {\r\n      this.onLayoutNeeded();\r\n    }  \r\n  }\r\n\r\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\r\n    const plot = this.plot;\r\n    const v = this.visual;\r\n    const width = plot.axisWidth;\r\n\r\n    const colour = this.colour ?? plot.axisColour;\r\n    ctx.strokeStyle = colour;\r\n\r\n    ctx.clearRect(0,0,v.width, v.height);\r\n    ctx.beginPath();\r\n    ctx.lineWidth = width;    \r\n    ctx.moveTo(0, width/2);\r\n    ctx.lineTo(v.width, width/2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  protected measureSelf(opts: Sg.MeasureState, parent?: Sg.Measurement): Rects.Rect | Rects.RectPositioned | undefined {\r\n    const plot = this.plot;\r\n    \r\n    const yAxis = opts.measurements.get(`AxisY`);\r\n    if (yAxis === undefined) return;\r\n    \r\n    const legend = opts.measurements.get(`Legend`);\r\n    if (legend === undefined) return;\r\n\r\n    const h = plot.axisWidth + this.paddingPx;\r\n    return {\r\n      x: yAxis.size.width,\r\n      y: opts.bounds.height - h - legend.size.height,\r\n      width: opts.bounds.width - yAxis.size.width,\r\n      height: h\r\n    }\r\n  }\r\n}\r\n\r\nconst isRangeEqual = (a:DataRange, b:DataRange) =>  a.max === b.max && a.min === b.min;\r\nconst isRangeSinglePoint = (a:DataRange) => a.max === a.min;\r\n\r\nclass AxisY extends Sg.CanvasBox {\r\n  // Number of digits axis will be expected to show as a data legend\r\n  private _maxDigits = 1;\r\n\r\n  seriesToShow:string|undefined;\r\n  paddingPx = 2;\r\n  colour?:string;\r\n  \r\n  lastRange:DataRange;\r\n  lastPlotAreaHeight = 0;\r\n\r\n  constructor(private plot:Plot) {\r\n    super(plot, plot.canvasEl, `AxisY`);\r\n    this.lastRange = {min:0,max:0};\r\n  }\r\n\r\n  clear() {\r\n    this.lastRange = {min:0,max:0};\r\n    this.lastPlotAreaHeight = 0;\r\n  }\r\n\r\n  protected measurePreflight(): void {\r\n    const series = this.getSeries();\r\n    if (series !== undefined && !isRangeEqual(series.visualRange, this.lastRange)) {\r\n      this._needsLayout = true;\r\n      this.needsDrawing = true;\r\n    }\r\n  }\r\n\r\n  protected onNotify(msg: string, source: Sg.Box): void {\r\n    const pa = this.plot.plotArea;\r\n    if (msg === `measureApplied` && source === pa) {\r\n      if (pa.visual.height !== this.lastPlotAreaHeight) {\r\n        this.lastPlotAreaHeight = pa.visual.height;\r\n        this.needsDrawing = true;  \r\n      }\r\n    }  \r\n  }\r\n\r\n  protected measureSelf(opts: Sg.MeasureState): Rects.RectPositioned {\r\n    //this.debugLog(`measureSelf. needsLayout: ${this._needsLayout} needsDrawing: ${this.needsDrawing}`);\r\n    \r\n    const copts = opts as Sg.CanvasMeasureState;\r\n    const paddingPx = this.paddingPx;\r\n    let width = this.plot.axisWidth + paddingPx;\r\n\r\n    const series = this.getSeries();\r\n    if (series !== undefined) {\r\n      const r = series.visualRange;\r\n      this._maxDigits = Math.ceil(r.max).toString().length + series.precision + 1;\r\n\r\n      const textToMeasure = `9`.repeat(this._maxDigits);\r\n      width += textWidth(copts.ctx, textToMeasure, paddingPx*2);\r\n    }\r\n    const w = opts.resolveToPx(this.desiredSize?.width, width);\r\n    return {\r\n      x:0,\r\n      y:0,\r\n      width: w,\r\n      height: opts.bounds.height\r\n    }\r\n  }\r\n\r\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\r\n    const s = this.getSeries();\r\n    if (s !== undefined) this.seriesAxis(s, ctx);\r\n    else {\r\n      if (this.seriesToShow === undefined) return;\r\n      console.warn(`Plot AxisY series '${this.seriesToShow}' is missing.`);\r\n    }  \r\n  }\r\n\r\n  getSeries():Series|undefined {\r\n    if (this.seriesToShow === undefined) {\r\n      // Pick first series\r\n      return this.plot.seriesArray()[0];\r\n    } else {\r\n      // Try designated series name\r\n      return this.plot.series.get(this.seriesToShow);\r\n    }\r\n  }\r\n\r\n  seriesAxis(series:Series, ctx:CanvasRenderingContext2D) {\r\n    const plot = this.plot;\r\n    const plotArea = plot.plotArea;\r\n    const v = this.visual;\r\n    const paddingPx = this.paddingPx;\r\n    const r = series.visualRange;\r\n    const width = plot.axisWidth;\r\n\r\n    const colour = this.colour ?? plot.axisColour;\r\n    ctx.strokeStyle = colour;\r\n    ctx.fillStyle = colour;\r\n\r\n    if (Number.isNaN(r.min)  && Number.isNaN(r.max)) return; // Empty\r\n    this.lastRange = r;\r\n    ctx.clearRect(0,0,v.width, v.height);\r\n \r\n    ctx.beginPath();\r\n    ctx.lineWidth = width;    \r\n    const lineX = v.width - width/2;\r\n    ctx.moveTo(lineX, plotArea.paddingPx + (width));\r\n    ctx.lineTo(lineX, plotArea.visual.height + width);\r\n    ctx.stroke();\r\n\r\n    ctx.textBaseline = `top`;\r\n    const fromRight = v.width - (paddingPx *4);\r\n\r\n    if (isRangeSinglePoint(r)) {\r\n      drawText(ctx, series.formatValue(r.max), size => [\r\n        fromRight-size.width, \r\n        plotArea.computeY(series, r.max) - (paddingPx*4)\r\n      ]);\r\n    } else {\r\n      // Draw min/max data labels\r\n      drawText(ctx, series.formatValue(r.max), size => [\r\n        fromRight-size.width, \r\n        plotArea.computeY(series, r.max) + (width/2)\r\n      ]);\r\n      drawText(ctx, series.formatValue(r.min), size => [\r\n        fromRight-size.width,\r\n        plotArea.computeY(series, r.min) - 5\r\n      ]);\r\n    }\r\n  }\r\n}\r\n\r\nconst drawText = (ctx:CanvasRenderingContext2D, text:string, position:(size:TextMetrics) => [x:number,y:number]) => {\r\n  const size = ctx.measureText(text);\r\n  const xy = position(size);\r\n  ctx.fillText(text, xy[0], xy[1]);\r\n}\r\n\r\n/**\r\n * Canvas-based data plotter.\r\n * \r\n * ```\r\n * const p = new Plot(document.getElementById(`myCanvas`), opts);\r\n * \r\n * // Plot 1-5 as series  test'\r\n * p.createSeries(`test`, `array`, [1,2,3,4,5]);\r\n * \r\n * // Create a streaming series, add a random number\r\n * const s = p.createSeries(`test2`, `stream`);\r\n * s.add(Math.random());\r\n * ```\r\n * \r\n * \r\n * `createSeries` returns the {@link Series} instance with properties for fine-tuning\r\n */\r\nexport class Plot extends Sg.CanvasBox {\r\n  plotArea:PlotArea;\r\n  legend:Legend;\r\n  axisX:AxisX;\r\n  axisY:AxisY;\r\n  axisColour:string;\r\n  axisWidth:number;\r\n  series:Map<string,Series>;\r\n  private _frozen = false;\r\n\r\n  defaultSeriesOpts?:SeriesOpts;\r\n  constructor(canvasEl:HTMLCanvasElement, opts:Opts = {}) {\r\n      \r\n    if (canvasEl === undefined) throw new Error(`canvasEl undefined`);\r\n    super(undefined, canvasEl, `Plot`);\r\n  \r\n    if (opts.autoSize) {\r\n      parentSizeCanvas(canvasEl, evt => {\r\n        this.update(true);\r\n      });\r\n    }\r\n\r\n    this.axisColour = opts.axisColour ?? `black`;\r\n    this.axisWidth = opts.axisWidth ?? 3;\r\n    this.series = new Map();\r\n    this.plotArea = new PlotArea(this);\r\n    this.legend = new Legend(this);\r\n    this.axisX = new AxisX(this);\r\n    this.axisY = new AxisY(this);\r\n  }\r\n\r\n  clear() {\r\n    this.series = new Map();\r\n    this.plotArea.clear();\r\n    this.legend.clear();\r\n    this.axisX.clear();\r\n    this.axisY.clear();\r\n    this.update(true);\r\n  }\r\n\r\n  get frozen():boolean {\r\n    return this._frozen;\r\n  }\r\n\r\n  set frozen(v:boolean) {\r\n    this._frozen = v;\r\n    if (v) {\r\n      this.canvasEl.classList.add(`frozen`);\r\n      this.canvasEl.title = `Plot frozen. Tap to unfreeze`;\r\n    } else {\r\n      this.canvasEl.title = ``;\r\n      this.canvasEl.classList.remove(`frozen`);\r\n    } \r\n  }\r\n\r\n  seriesArray():Series[] {\r\n    return [...this.series.values()];\r\n  }\r\n\r\n  get seriesLength():number {\r\n    return this.series.size;\r\n  }\r\n\r\n  plot(o:any) {\r\n    const paths = getFieldPaths(o);\r\n    paths.forEach(p => {\r\n      let s = this.series.get(p);\r\n      if (s === undefined) {\r\n        s = this.createSeries(p, `stream`);\r\n        s.drawingStyle = `line`;\r\n      }\r\n      s.add(getFieldByPath(o, p));\r\n    })\r\n  }\r\n\r\n  createSeriesFromObject(o:any, prefix:string = ``):Series[] {\r\n    const keys = Object.keys(o);\r\n    const create = (key:string):Series[] => {\r\n      const v = o[key];\r\n      if (typeof v === `object`) {\r\n        return this.createSeriesFromObject(v, prefix + key +'.');\r\n      } else if (typeof v === `number`) {\r\n        return [this.createSeries(key, `stream`)];\r\n      } else {\r\n        return [];\r\n      }\r\n    }\r\n    return keys.flatMap(create);\r\n  }\r\n\r\n  createSeries(name?:string, type:`stream`|`array` = `array`, initialData?:number[]):Series {\r\n    const len = this.seriesLength;\r\n\r\n    if (name === undefined) name = `series-${len}`;\r\n    if (this.series.has(name)) throw new Error(`Series name '${name}' already in use`);\r\n \r\n    let opts:SeriesOpts = {\r\n      colour: `hsl(${len*25 % 360}, 70%,50%)`\r\n    }\r\n    if (this.defaultSeriesOpts) opts = {...this.defaultSeriesOpts, ...opts};\r\n    \r\n    const s = new Series(name, type, this, opts);\r\n    if (type === `array` && initialData !== undefined) {\r\n      (s.source as ArrayDataSource).set(initialData);\r\n    }\r\n    \r\n    this.series.set(name, s);\r\n    this.setReady(true, true);\r\n    this.plotArea.needsDrawing = true;\r\n    return s;\r\n  }\r\n}","/* eslint-disable */\r\nimport {asapScheduler} from 'rxjs';\r\nimport {Arrays} from '~/collections/index.js';\r\nimport {Points} from '~/geometry/index.js';\r\nimport * as Rects from '../geometry/Rect.js';\r\nimport {hue as randomHue} from  '../Random.js';\r\n\r\nexport type Measurement = {\r\n  size: Rects.Rect|Rects.RectPositioned\r\n  ref: Box\r\n  children: Array<Measurement|undefined>\r\n}\r\n\r\nexport type PxUnit = {\r\n  value: number;\r\n  type: `px`;\r\n}\r\n\r\nexport type BoxUnit = PxUnit;\r\n\r\nexport type BoxRect = {\r\n  x?: BoxUnit\r\n  y?: BoxUnit\r\n  width?: BoxUnit\r\n  height?: BoxUnit \r\n}\r\n\r\nconst unitIsEqual = (a:BoxUnit, b:BoxUnit):boolean => {\r\n  if (a.type ===`px` && b.type === `px`) {\r\n    return (a.value === b.value)\r\n  }\r\n  return false;\r\n}\r\n\r\nconst boxRectIsEqual = (a:BoxRect|undefined, b:BoxRect|undefined):boolean => {\r\n  if (a === undefined && b === undefined) return true;\r\n  if (a === undefined) return false;\r\n  if (b === undefined) return false;\r\n  if (a.x && b.x) {\r\n    if (!unitIsEqual(a.x, b.x)) return false;\r\n  }\r\n  if (a.y && b.y) {\r\n    if (!unitIsEqual(a.y, b.y)) return false;\r\n  }\r\n  if (a.width && b.width) {\r\n    if (!unitIsEqual(a.width, b.width)) return false;\r\n  }\r\n  if (a.height && b.height) {\r\n    if (!unitIsEqual(a.height, b.height)) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport class MeasureState {\r\n  bounds: Rects.Rect;\r\n  pass: number;\r\n  measurements: Map<string, Measurement>;\r\n  \r\n  constructor(bounds:Rects.Rect) {\r\n    this.bounds = bounds;\r\n    this.pass = 0;\r\n    this.measurements = new Map<string, Measurement>();\r\n  }\r\n\r\n  getSize(id:string):Rects.Rect|undefined {\r\n    const s = this.measurements.get(id);\r\n    if (s === undefined) return;\r\n    if (Rects.isPlaceholder(s.size)) return;\r\n    return s.size;\r\n  }\r\n  \r\n  resolveToPx(u:BoxUnit|undefined, defaultValue:number):number {\r\n    if (u === undefined) return defaultValue; //throw new Error(`unit undefined`);\r\n    if (u.type === `px`) return u.value;\r\n    throw new Error(`Unknown unit type ${u.type}`);\r\n  }\r\n}\r\n\r\nexport abstract class Box {\r\n  visual:Rects.RectPositioned = Rects.placeholderPositioned;\r\n  private _desiredSize:BoxRect|undefined;\r\n  private _lastMeasure:Rects.RectPositioned | Rects.Rect|undefined\r\n\r\n  protected children: Box[] = [];\r\n  protected readonly _parent:Box|undefined;\r\n  private _idMap: Map<string,Box> = new Map();\r\n\r\n  debugLayout = false;\r\n  \r\n  private _visible = true;\r\n  protected _ready = true;\r\n\r\n  takesSpaceWhenInvisible = false;\r\n  needsDrawing = true;\r\n  protected _needsLayout = true;\r\n\r\n  debugHue = randomHue();\r\n  readonly id: string;\r\n  \r\n  constructor(parent:Box|undefined, id:string) {\r\n    this.id = id;\r\n    this._parent = parent;\r\n\r\n    parent?.onChildAdded(this);\r\n  }\r\n\r\n  hasChild(box:Box):boolean {\r\n    const byRef = this.children.find(c=>c === box);\r\n    const byId = this.children.find( c => c.id === box.id);\r\n    return byRef !== undefined || byId !== undefined;\r\n  }\r\n\r\n  notify(msg:string, source:Box) {\r\n    this.onNotify(msg, source);\r\n    this.children.forEach(c => c.notify(msg, source));\r\n  }\r\n\r\n  protected onNotify(msg:string, source:Box) {\r\n  \r\n  }\r\n\r\n  protected onChildAdded(child:Box) {\r\n    if (child.hasChild(this)) throw new Error(`Recursive`);\r\n    if (child === this) throw new Error(`Cannot add self as child`);\r\n    if (this.hasChild(child)) throw new Error(`Child already present`);\r\n\r\n    this.children.push(child);\r\n    this._idMap.set(child.id, child)\r\n  }\r\n\r\n  setReady(ready:boolean, includeChildren:boolean = false) {\r\n    this._ready = ready;\r\n    if (includeChildren) {\r\n      this.children.forEach(c => c.setReady(ready, includeChildren));\r\n    }\r\n  }\r\n\r\n\r\n  get visible():boolean {\r\n    return this._visible;\r\n  }\r\n\r\n  set visible(v:boolean) {\r\n    if (this._visible === v) return;\r\n    this._visible = v;\r\n    this.onLayoutNeeded();\r\n  }\r\n\r\n  get desiredSize():BoxRect|undefined {\r\n    return this._desiredSize;\r\n  }\r\n\r\n  set desiredSize(v:BoxRect|undefined) {\r\n    if (boxRectIsEqual(v, this._desiredSize)) return;\r\n    this._desiredSize = v;\r\n    this.onLayoutNeeded();\r\n  }\r\n  \r\n  onLayoutNeeded() {\r\n    this.notifyChildLayoutNeeded();\r\n  }\r\n\r\n  private notifyChildLayoutNeeded() {\r\n    this._needsLayout = true;\r\n    this.needsDrawing = true;\r\n    if (this._parent !== undefined) {\r\n      this._parent.notifyChildLayoutNeeded();\r\n    } else {\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  get root():Box {\r\n    if (this._parent === undefined) return this;\r\n    return this._parent.root;\r\n  }\r\n\r\n  protected measurePreflight() {}\r\n\r\n  /**\r\n   * Applies measurement, returning true if size is different than before\r\n   * @param size \r\n   * @returns \r\n   */\r\n   measureApply(m:Measurement, force:boolean) {\r\n\r\n    let different = true;\r\n    this._needsLayout = false;\r\n    \r\n    if (Rects.isEqual(m.size, this.visual)) different = false;\r\n        \r\n    if (Rects.isPositioned(m.size)) {\r\n      this.visual = m.size;\r\n    } else {\r\n      this.visual = {\r\n        x: 0, y: 0,\r\n        width: m.size.width,\r\n        height: m.size.height\r\n      }\r\n    }\r\n\r\n    m.children.forEach(c => {\r\n      if (c !== undefined) c.ref.measureApply(c, force);\r\n    })\r\n    if (different || force) {\r\n      this.needsDrawing = true;\r\n      this.root.notify(`measureApplied`, this);\r\n    \r\n    }\r\n    return different;\r\n  }\r\n\r\n\r\n  debugLog(m:any) {\r\n    console.log(this.id, m);\r\n  }\r\n\r\n  measureStart(opts:MeasureState, force:boolean, parent?:Measurement):Measurement|undefined {\r\n    this.measurePreflight();\r\n\r\n    let m:Measurement = {\r\n      ref: this,\r\n      size:Rects.placeholder,\r\n      children:[]\r\n    };\r\n    opts.measurements.set(this.id, m);\r\n    \r\n    \r\n    if (!this._visible && !this.takesSpaceWhenInvisible) {\r\n      m.size = Rects.emptyPositioned;\r\n    } else {\r\n      let size = this._lastMeasure;\r\n      if (this._needsLayout || this._lastMeasure === undefined) {\r\n        size = this.measureSelf(opts, parent);\r\n        this.root.notify(`measured`, this);\r\n      }\r\n      if (size === undefined) return;\r\n      m.size = size;\r\n      this._lastMeasure = size;\r\n    }\r\n\r\n    m.children = this.children.map(c => c.measureStart(opts, force, m));\r\n    if (Arrays.without(m.children, undefined).length < this.children.length) {\r\n      return undefined; // One of the children did not resolve\r\n    }\r\n\r\n    return m;\r\n  }\r\n\r\n  protected measureSelf(opts:MeasureState, parent?:Measurement):Rects.RectPositioned | Rects.Rect|undefined {\r\n    let size = Rects.placeholderPositioned;\r\n    if (parent) {\r\n      // Use parent size\r\n      if (parent.size) {\r\n        size = {\r\n          x: 0, y: 0,\r\n          width: parent.size.width,\r\n          height: parent.size.height \r\n        }\r\n      }\r\n    } else {\r\n      // Use canvas size\r\n      size = {\r\n        x:0, y:0,\r\n        width: opts.bounds.width,\r\n        height: opts.bounds.height\r\n      }\r\n    }\r\n    if (Rects.isPlaceholder(size)) return;\r\n    return size;\r\n  }\r\n\r\n  /**\r\n   * Called when update() is called\r\n   * @param force \r\n   */\r\n  protected abstract updateBegin(force:boolean):MeasureState;\r\n  \r\n  protected updateDone(state:MeasureState, force:boolean):void {\r\n    this.onUpdateDone(state, force);\r\n    this.children.forEach(c=>c.updateDone(state, force));\r\n  }\r\n\r\n  abstract onUpdateDone(state:MeasureState, force:boolean):void;\r\n\r\n  update(force = false) {\r\n    const state = this.updateBegin(force);\r\n    let attempts = 5;\r\n    let applied = false;\r\n\r\n    while (attempts--) {\r\n      const m = this.measureStart(state, force);\r\n      if (m !== undefined) {\r\n        // Apply measurements\r\n        this.measureApply(m, force);\r\n        if (!this._ready) return;\r\n        applied = true;\r\n        //this.onMeasurementApplied(sizeChanged, force;\r\n        //return;\r\n      }\r\n    }\r\n\r\n    this.updateDone( state, force);\r\n    if (!applied) console.warn(`Ran out of measurement attempts`);\r\n  }\r\n}\r\n\r\nexport class CanvasMeasureState extends MeasureState {\r\n  readonly ctx:CanvasRenderingContext2D;\r\n  constructor(bounds:Rects.Rect, ctx:CanvasRenderingContext2D) {\r\n    super(bounds);\r\n    this.ctx = ctx;\r\n  }\r\n}\r\n\r\n\r\nexport class CanvasBox extends Box {\r\n  readonly canvasEl:HTMLCanvasElement;\r\n\r\n  constructor(parent:CanvasBox|undefined, canvasEl:HTMLCanvasElement, id:string) {\r\n    super(parent, id);\r\n    if (canvasEl === undefined) throw new Error(`canvasEl undefined`);\r\n    if (canvasEl === null) throw new Error(`canvasEl null`);\r\n    this.canvasEl = canvasEl;\r\n\r\n    if (parent === undefined) this.designateRoot();\r\n  }\r\n\r\n  private designateRoot() {\r\n    this.canvasEl.addEventListener(`pointermove`, evt => {\r\n      const p = {x:evt.offsetX, y:evt.offsetY};\r\n      this.notifyPointerMove(p);\r\n    });\r\n\r\n    this.canvasEl.addEventListener(`pointerleave`, evt => {\r\n      this.notifyPointerLeave();    \r\n    })\r\n\r\n    this.canvasEl.addEventListener(`click`, evt => {\r\n      const p = {x:evt.offsetX, y:evt.offsetY};\r\n      this.notifyClick(p);\r\n    })\r\n  }\r\n\r\n  protected onClick(p:Points.Point) {}\r\n\r\n  private notifyClick(p:Points.Point) {\r\n    if (Rects.isPlaceholder(this.visual)) return;\r\n    if (Rects.intersectsPoint(this.visual, p)) {\r\n      const pp = Points.subtract(p, this.visual.x, this.visual.y);\r\n      this.onClick(pp);\r\n      this.children.forEach(c=> (c as CanvasBox).notifyClick(pp));\r\n    }\r\n  }\r\n\r\n  private notifyPointerLeave() {\r\n    this.onPointerLeave();\r\n    this.children.forEach(c=>(c as CanvasBox).notifyPointerLeave());\r\n  }\r\n\r\n  private notifyPointerMove(p:Points.Point) {\r\n    if (Rects.isPlaceholder(this.visual)) return;\r\n    if (Rects.intersectsPoint(this.visual, p)) {\r\n      const pp = Points.subtract(p, this.visual.x, this.visual.y);\r\n      this.onPointerMove(pp);\r\n      this.children.forEach(c=> (c as CanvasBox).notifyPointerMove(pp));\r\n    }\r\n  };\r\n\r\n  protected onPointerLeave() {\r\n\r\n  }\r\n\r\n  protected onPointerMove(p:Points.Point) {\r\n\r\n  }\r\n\r\n  protected updateBegin():MeasureState {\r\n    const ctx = this.canvasEl.getContext(`2d`);\r\n    if (ctx === null) throw new Error(`Context unavailable`);\r\n\r\n    const s = this.canvasEl.getBoundingClientRect();\r\n\r\n    return new CanvasMeasureState({\r\n      width: s.width,\r\n      height: s.height\r\n    }, ctx);\r\n  }\r\n\r\n  override onUpdateDone(state: MeasureState, force: boolean) {\r\n    if (!this.needsDrawing && !force) return;\r\n    \r\n    const ctx = this.canvasEl.getContext(`2d`);\r\n    if (ctx === null) throw new Error(`Context unavailable`);\r\n\r\n    ctx.save();\r\n    ctx.translate(this.visual.x, this.visual.y);\r\n    \r\n    const v = this.visual;\r\n    \r\n    if (this.debugLayout) {\r\n      \r\n      //ctx.clearRect(0,0,v.width,v.height);\r\n      \r\n      ctx.lineWidth = 1;\r\n      ctx.strokeStyle = `hsl(${this.debugHue}, 100%, 50%)`;\r\n\r\n      //ctx.fillStyle = ctx.strokeStyle;\r\n      //ctx.fillRect(0,0,v.width,v.height);\r\n      \r\n      ctx.strokeRect(0, 0, v.width, v.height);\r\n\r\n      ctx.fillStyle = ctx.strokeStyle;\r\n      ctx.fillText(this.id, 10, 10, v.width);\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(0,0);\r\n      ctx.lineTo(v.width, v.height);\r\n      ctx.stroke();\r\n    }\r\n\r\n    this.drawSelf(ctx);\r\n\r\n    this.needsDrawing = false;\r\n    ctx.restore();\r\n  }\r\n\r\n  protected drawSelf(ctx:CanvasRenderingContext2D):void {\r\n\r\n  }\r\n}","/**\r\n * Manage a set of colours. Uses CSS variables as a fallback if colour is not added\r\n *\r\n */\r\nexport type Palette = {\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  setElementBase(el:Element):void\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  has(key:string):boolean\r\n\r\n  /**\r\n   * Returns a colour by name. \r\n   * \r\n   * If the colour is not found:\r\n   *  1. Try to use a CSS variable `--key`, or\r\n   *  2. The next fallback colour is used (array cycles)\r\n   *\r\n   * @param key\r\n   * @returns\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get(key:string, fallback?:string):string\r\n\r\n  /**\r\n   * Gets a colour by key, adding and returning fallback if not present\r\n   * @param key Key of colour\r\n   * @param fallback Fallback colour if key is not found\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  getOrAdd(key: string, fallback?:string):string\r\n\r\n  /**\r\n   * Adds a colour with a given key\r\n   *\r\n   * @param key\r\n   * @param colour\r\n   */\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  add(key:string, value:string):void\r\n\r\n  alias(from:string, to:string):void\r\n};\r\n\r\nexport const create = (fallbacks?:readonly string[]):Palette => new PaletteImpl(fallbacks);\r\n\r\nclass PaletteImpl {\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #store:Map<string, string> = new Map();\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #aliases:Map<string, string> = new Map();\r\n\r\n  readonly fallbacks:readonly string[];\r\n  #lastFallback = 0;\r\n\r\n  #elementBase:Element;\r\n\r\n  constructor(fallbacks?:readonly string[]) {\r\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\r\n    else this.fallbacks = [`red`, `blue`, `green`, `orange`];\r\n    this.#elementBase = document.body;\r\n  }\r\n\r\n  setElementBase(el:Element) {\r\n    this.#elementBase = el;\r\n  }\r\n\r\n  add(key:string, colour:string) {\r\n    this.#store.set(key, colour);\r\n  }\r\n\r\n  alias(from:string, to:string) {\r\n    this.#aliases.set(from, to);\r\n  }\r\n\r\n  get(key:string, fallback?:string):string {\r\n    const alias =  this.#aliases.get(key);\r\n    if (alias !== undefined) key = alias;\r\n  \r\n    const c = this.#store.get(key);\r\n    if (c !== undefined) return c;\r\n\r\n    const varName = `--` + key;\r\n    // eslint-disable-next-line functional/no-let\r\n    let fromCss = getComputedStyle(this.#elementBase).getPropertyValue(varName).trim();\r\n\r\n    // Not found\r\n    if (fromCss === undefined || fromCss.length === 0) {\r\n      if (fallback !== undefined) return fallback;\r\n      fromCss = this.fallbacks[this.#lastFallback];\r\n      this.#lastFallback++;\r\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\r\n    }\r\n    return fromCss;\r\n  }\r\n\r\n  getOrAdd(key:string, fallback?:string):string {\r\n    if (this.has(key)) return this.get(key);\r\n    const c = this.get(key, fallback);\r\n    this.add(key, c);\r\n    return c;\r\n  }\r\n\r\n  has(key:string):boolean {\r\n    return this.#store.has(key);\r\n  }\r\n}\r\n\r\n","/* eslint-disable @typescript-eslint/no-non-null-assertion,functional/immutable-data */\r\nimport {continuously, delayLoop } from \"../flow/index.js\";\r\n\r\n//eslint-disable-next-line functional/no-mixed-type\r\nexport type Capturer = {\r\n  start():void;\r\n  cancel():void;\r\n  readonly canvasEl:HTMLCanvasElement;\r\n}\r\n\r\n//eslint-disable-next-line functional/no-mixed-type\r\nexport type CaptureOpts = {\r\n  readonly maxIntervalMs?:number;\r\n  readonly showCanvas?:boolean;\r\n  readonly workerScript?:string;\r\n  readonly onFrame?:(pixels:ImageData) => void;\r\n};\r\n\r\n/**\r\n * Options for frames generator\r\n */\r\nexport type FramesOpts = {\r\n  /**\r\n   * Max frame rate (millis per frame), or 0 for animation speed\r\n   */\r\n  readonly maxIntervalMs?:number;\r\n  /**\r\n   * False by default, created canvas will be hidden\r\n   */\r\n  readonly showCanvas?:boolean;\r\n  /**\r\n   * If provided, this canvas will be used as the buffer rather than creating one.\r\n   */\r\n  readonly canvasEl?:HTMLCanvasElement;\r\n}\r\n\r\n/**\r\n * Generator that yields frames from a video element as ImageData.\r\n * ```\r\n * const ctx = canvasEl.getContext(`2d`); \r\n * for await (const frame of Video.frames(videoEl)) {\r\n *   // TODO: Some processing of pixels\r\n *\r\n *   // Draw image on to the visible canvas\r\n *   ctx.putImageData(frame, 0, 0);\r\n * }\r\n * ```\r\n * \r\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\r\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\r\n * \r\n * @param sourceVideoEl \r\n * @param opts \r\n */\r\n//eslint-disable-next-line func-style\r\nexport async function* frames(sourceVideoEl:HTMLVideoElement, opts:FramesOpts = {}):AsyncIterable<ImageData>  {\r\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\r\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\r\n\r\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\r\n  const showCanvas = opts.showCanvas ?? false;\r\n  //eslint-disable-next-line functional/no-let\r\n  let canvasEl = opts.canvasEl;\r\n  //eslint-disable-next-line functional/no-let\r\n  let w, h;\r\n  w = h = 0;\r\n\r\n  // Create & setup canvas\r\n  if (canvasEl === undefined) {\r\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\r\n    if (!showCanvas) {\r\n      canvasEl.style.display = `none`;\r\n    }\r\n    document.body.appendChild(canvasEl);\r\n  }\r\n  \r\n  // Update size of canvas based on video\r\n  const updateSize = () => {\r\n    if (canvasEl === undefined) return;\r\n    w = sourceVideoEl.videoWidth;\r\n    h = sourceVideoEl.videoHeight;\r\n    canvasEl.width = w;\r\n    canvasEl.height = h;\r\n  };\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let c:CanvasRenderingContext2D|null = null;\r\n\r\n  const looper = delayLoop(maxIntervalMs);\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  for await (const _ of looper) {\r\n    // If we don't yet have the size of video, get it\r\n    if (w === 0 || h === 0) updateSize();\r\n    \r\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\r\n    if (w === 0 || h === 0) continue;\r\n\r\n    // Draw current frame from video element to hidden canvas\r\n    if (c === null) c = canvasEl.getContext(`2d`);\r\n    if (c === null) return;\r\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\r\n\r\n    // Get pixels\r\n    const pixels = c.getImageData(\r\n      0, 0, w, h\r\n    );\r\n    yield pixels;\r\n  }\r\n}\r\n\r\n/**\r\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\r\n * \r\n * ```@example Using a function\r\n * capture(sourceVideoEl, {\r\n *  onFrame(imageData => {\r\n *    // Do something with pixels...\r\n *  });\r\n * });\r\n * ```\r\n * \r\n * ```@example Using a worker\r\n * capture(sourceVideoEl, {\r\n *  workerScript: `./frameProcessor.js`\r\n * });\r\n * \r\n * // In frameProcessor.js...\r\n * ```\r\n * \r\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\r\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\r\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\r\n * @param sourceVideoEl \r\n * @param opts \r\n * @returns \r\n */\r\nexport const capture = (sourceVideoEl: HTMLVideoElement, opts:CaptureOpts = {}):Capturer => {\r\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\r\n  const showCanvas = opts.showCanvas ?? false;\r\n  const onFrame = opts.onFrame;\r\n\r\n  // Ideally use OffscreenCanvas when it has support?\r\n  const w = sourceVideoEl.videoWidth;\r\n  const h = sourceVideoEl.videoHeight;\r\n\r\n  // Create canvas\r\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\r\n  if (!showCanvas) {\r\n    canvasEl.style.display = `none`;\r\n  }\r\n  canvasEl.width = w;\r\n  canvasEl.height = h;\r\n  //eslint-disable-next-line functional/no-let\r\n  let c:CanvasRenderingContext2D|null = null;\r\n  //eslint-disable-next-line functional/no-let\r\n  let worker:Worker|undefined;\r\n  if (opts.workerScript) {\r\n    worker = new Worker(opts.workerScript);\r\n  }\r\n\r\n  // Should we get image data?\r\n  const getPixels = worker || onFrame;\r\n  if (!getPixels && !showCanvas) {\r\n    console.warn(`Video will be captured to hidden element without any processing. Is this what you want?`);\r\n  }\r\n\r\n  const loop = continuously(() => {\r\n    // Draw current frame from video element to hidden canvas\r\n    if (c === null) c = canvasEl.getContext(`2d`);\r\n    if (c === null) return;\r\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\r\n    //eslint-disable-next-line functional/no-let\r\n    let pixels:ImageData|undefined;\r\n\r\n    if (getPixels) {\r\n      // ImageData necessary\r\n      pixels = c.getImageData(\r\n        0, 0, w, h\r\n      );\r\n    }\r\n\r\n    if (worker) {\r\n      // Send to worker\r\n      worker.postMessage({\r\n        pixels: pixels!.data.buffer,\r\n        width: w,\r\n        height: h,\r\n        channels: 4\r\n      }, [pixels!.data.buffer]); \r\n    }\r\n    if (onFrame) {\r\n      // Send to callback\r\n      try {\r\n        onFrame(pixels!);\r\n      } catch (e) {\r\n        console.error(e);\r\n      }\r\n    }\r\n  \r\n  }, maxIntervalMs);\r\n\r\n  return {\r\n    start: () => loop.start(),\r\n    cancel: () => loop.cancel(),\r\n    canvasEl\r\n  };\r\n};"],"mappings":"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","names":[]}