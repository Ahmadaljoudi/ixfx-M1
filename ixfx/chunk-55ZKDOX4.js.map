{"version":3,"sources":["../src/Text.ts"],"sourcesContent":["/**\r\n * Returns source text that is between `start` and `end` match strings.\r\n * @param source Source text \r\n * @param start Start match\r\n * @param end If undefined, `start` will be used instead\r\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\r\n * @returns \r\n */\r\nexport const between = (source: string, start: string, end?: string, lastEndMatch = true): string | undefined => {\r\n  const startPos = source.indexOf(start);\r\n  if (startPos < 0) return;\r\n\r\n  if (end === undefined) end = start;\r\n\r\n  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);\r\n  if (endPos < 0) return;\r\n\r\n  return source.substring(startPos+1, endPos);\r\n\r\n};\r\n\r\n/**\r\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\r\n * ```js\r\n * unwrap(\"'hello'\", \"'\");        // hello\r\n * unwrap(\"apple\", \"a\");          // apple\r\n * unwrap(\"wow\", \"w\");            // o\r\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\r\n * ```\r\n * @param source \r\n * @param wrappers \r\n * @returns \r\n */\r\nexport const unwrap = (source: string, ...wrappers: readonly string[]): string => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let matched = false;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    matched = false;\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const w of wrappers) {\r\n      if (source.startsWith(w) && source.endsWith(w)) {\r\n        source = source.substring(w.length, source.length - (w.length * 2) + 1);\r\n        matched = true;\r\n      }\r\n    }\r\n  } while (matched);\r\n\r\n  return source;\r\n};\r\n\r\n/**\r\n * A range\r\n */\r\nexport type Range = {\r\n  /**\r\n   * Text of range\r\n   */\r\n  readonly text: string\r\n  /**\r\n   * Start position, with respect to source text\r\n   */\r\n   readonly start: number\r\n  /**\r\n   * End position, with respect to source text\r\n   */\r\n   readonly end: number\r\n  /**\r\n   * Index of range. First range is 0\r\n   */\r\n   readonly index: number\r\n}\r\n\r\nexport type LineSpan = {\r\n  readonly start: number\r\n  readonly end: number\r\n  readonly length: number\r\n}\r\n\r\n/**\r\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\r\n * \r\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\r\n * \r\n * @param ranges Ranges\r\n * @param start Start character position, in source text reference\r\n * @param end End character position, in source text reference\r\n * @returns Span\r\n */\r\nexport const lineSpan = (ranges: readonly Range[], start: number, end: number): LineSpan => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let s = -1;\r\n  //eslint-disable-next-line functional/no-let\r\n  let e = -1;\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 0; i < ranges.length; i++) {\r\n    const r = ranges[i];\r\n    s = i;\r\n    if (r.text.length === 0) continue;\r\n    if (start < r.end) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = s; i < ranges.length; i++) {\r\n    const r = ranges[i];\r\n    e = i;\r\n    if (end === r.end) {\r\n      e = i + 1;\r\n      break;\r\n    }\r\n    if (end < r.end) {\r\n      break;\r\n    }\r\n  }\r\n  return {length: e - s, start: s, end: e};\r\n};\r\n\r\n/**\r\n * Splits a source string into ranges:\r\n * ```js\r\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\r\n * ```\r\n * \r\n * Each range consists of:\r\n * ```js\r\n * { \r\n *  text: string  - the text of range\r\n *  start: number - start pos of range, wrt to source\r\n *  end: number   - end pos of range, wrt to source\r\n *  index: number - index of range (starting at 0)\r\n * }\r\n * ```\r\n * @param source \r\n * @param split \r\n * @returns \r\n */\r\nexport const splitRanges = (source: string, split: string):readonly Range[] => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let start = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let text = ``;\r\n  const ranges: Range[] = [];\r\n  //eslint-disable-next-line functional/no-let\r\n  let index = 0;\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 0; i < source.length; i++) {\r\n    if (source.indexOf(split, i) === i) {\r\n      //eslint-disable-next-line functional/no-let\r\n      const end = i;\r\n      //eslint-disable-next-line functional/immutable-data\r\n      ranges.push({\r\n        text, start, end, index\r\n      });\r\n      start = end + 1;\r\n      text = ``;\r\n      index++;\r\n    } else {\r\n      text += source.charAt(i);\r\n    }\r\n  }\r\n  if (start < source.length) {\r\n    //eslint-disable-next-line functional/immutable-data\r\n    ranges.push({text, start, index, end: source.length});\r\n  }\r\n  return ranges;\r\n};\r\n\r\n/**\r\n * Counts the number of times one of `chars` appears at the front of\r\n * a string, contiguously.\r\n * \r\n * ```js\r\n * countCharsFromStart(`  hi`, ` `); // 2\r\n * countCharsFromStart(`hi  `, ` `); // 0\r\n * countCharsFromStart(`  hi  `, ` `); // 2\r\n * ```\r\n * @param source \r\n * @param chars \r\n * @returns \r\n */\r\nexport const countCharsFromStart = (source: string, ...chars: readonly string[]): number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let counted = 0;\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i = 0; i < source.length; i++) {\r\n    if (chars.includes(source.charAt(i))) {\r\n      counted++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  return counted;\r\n};\r\n\r\n/**\r\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\r\n * If _end_ is omitted, the the `start` value will be used.\r\n * \r\n * ```js\r\n * startsEnds(`This is a string`, `This`, `string`); // True\r\n * startsEnds(`This is a string`, `is`, `a`); // False\r\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\r\n * ```\r\n * @param source String to search within \r\n * @param start Start\r\n * @param end End (if omitted, start will be looked for at end as well)\r\n * @returns True if source starts and ends with provided values.\r\n */\r\nexport const startsEnds = (source:string, start:string, end:string = start):boolean => source.startsWith(start) && source.endsWith(end);\r\n"],"mappings":";;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQO,IAAM,UAAU,CAAC,QAAgB,OAAe,KAAc,eAAe,SAA6B;AAC/G,QAAM,WAAW,OAAO,QAAQ;AAChC,MAAI,WAAW;AAAG;AAElB,MAAI,QAAQ;AAAW,UAAM;AAE7B,QAAM,SAAS,eAAe,OAAO,YAAY,OAAO,OAAO,QAAQ,KAAK,WAAS;AACrF,MAAI,SAAS;AAAG;AAEhB,SAAO,OAAO,UAAU,WAAS,GAAG;AAAA;AAgB/B,IAAM,SAAS,CAAC,WAAmB,aAAwC;AAEhF,MAAI,UAAU;AAEd,KAAG;AACD,cAAU;AAEV,eAAW,KAAK,UAAU;AACxB,UAAI,OAAO,WAAW,MAAM,OAAO,SAAS,IAAI;AAC9C,iBAAS,OAAO,UAAU,EAAE,QAAQ,OAAO,SAAU,EAAE,SAAS,IAAK;AACrE,kBAAU;AAAA;AAAA;AAAA,WAGP;AAET,SAAO;AAAA;AAyCF,IAAM,WAAW,CAAC,QAA0B,OAAe,QAA0B;AAE1F,MAAI,IAAI;AAER,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,IAAI,OAAO;AACjB,QAAI;AACJ,QAAI,EAAE,KAAK,WAAW;AAAG;AACzB,QAAI,QAAQ,EAAE,KAAK;AACjB;AAAA;AAAA;AAKJ,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,IAAI,OAAO;AACjB,QAAI;AACJ,QAAI,QAAQ,EAAE,KAAK;AACjB,UAAI,IAAI;AACR;AAAA;AAEF,QAAI,MAAM,EAAE,KAAK;AACf;AAAA;AAAA;AAGJ,SAAO,EAAC,QAAQ,IAAI,GAAG,OAAO,GAAG,KAAK;AAAA;AAsBjC,IAAM,cAAc,CAAC,QAAgB,UAAmC;AAE7E,MAAI,QAAQ;AAEZ,MAAI,OAAO;AACX,QAAM,SAAkB;AAExB,MAAI,QAAQ;AAEZ,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,OAAO,QAAQ,OAAO,OAAO,GAAG;AAElC,YAAM,MAAM;AAEZ,aAAO,KAAK;AAAA,QACV;AAAA,QAAM;AAAA,QAAO;AAAA,QAAK;AAAA;AAEpB,cAAQ,MAAM;AACd,aAAO;AACP;AAAA,WACK;AACL,cAAQ,OAAO,OAAO;AAAA;AAAA;AAG1B,MAAI,QAAQ,OAAO,QAAQ;AAEzB,WAAO,KAAK,EAAC,MAAM,OAAO,OAAO,KAAK,OAAO;AAAA;AAE/C,SAAO;AAAA;AAgBF,IAAM,sBAAsB,CAAC,WAAmB,UAAqC;AAE1F,MAAI,UAAU;AAEd,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,MAAM,SAAS,OAAO,OAAO,KAAK;AACpC;AAAA,WACK;AACL;AAAA;AAAA;AAGJ,SAAO;AAAA;AAiBF,IAAM,aAAa,CAAC,QAAe,OAAc,MAAa,UAAkB,OAAO,WAAW,UAAU,OAAO,SAAS;","names":[]}