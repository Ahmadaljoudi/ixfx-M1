{"version":3,"sources":["../src/collections/SimpleMutableMapArray.ts","../src/Events.ts"],"sourcesContent":["/**\r\n * A simple mutable map of arrays, without events\r\n *\r\n * @export\r\n * @class SimpleMutableMapArray\r\n * @template V\r\n */\r\nexport class SimpleMutableMapArray<V> {\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #map: Map<string, ReadonlyArray<V>> = new Map();\r\n\r\n  add(key: string, ...values: ReadonlyArray<V>) {\r\n    const existing = this.#map.get(key);\r\n    if (existing === undefined) {\r\n      this.#map.set(key, values);\r\n    } else {\r\n      this.#map.set(key, [...existing, ...values]);\r\n    }\r\n  }\r\n\r\n  debugString(): string {\r\n    // eslint-disable-next-line functional/no-let\r\n    let r = ``;\r\n    const keys = Array.from(this.#map.keys());\r\n    keys.every(k => {\r\n      const v = this.#map.get(k);\r\n      if (v === undefined) return;\r\n      r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\r\n    });\r\n    return r;\r\n  }\r\n\r\n  get(key: string): ReadonlyArray<V> | undefined {\r\n    return this.#map.get(key);\r\n  }\r\n\r\n  delete(key: string, v: V): boolean {\r\n    const existing = this.#map.get(key);\r\n    if (existing === undefined) return false;\r\n    const without = existing.filter(i => i !== v);\r\n    this.#map.set(key, without);\r\n    return without.length < existing.length;\r\n  }\r\n\r\n  clear() {\r\n    this.#map.clear();\r\n  }\r\n}","import { SimpleMutableMapArray } from \"./collections/SimpleMutableMapArray.js\";\r\nexport type Listener<Events> = (ev: unknown, sender: SimpleEventEmitter<Events>) => void;\r\n\r\ntype FlowSource = {\r\n  name:string,\r\n  dispose():void,\r\n  input:FlowSink,\r\n};\r\n\r\ntype FlowHandler = (args?:any) => void;\r\n\r\ninterface FlowSink {\r\n [key:string]: FlowHandler;\r\n}\r\n\r\nexport type Debouncer = {\r\n  reset:()=>void\r\n  dispose:()=>void\r\n}\r\n\r\nconst sinkify = (handler:FlowHandler): FlowSink => ({ '*': handler });\r\n\r\nexport const debounceFactory = (sink:FlowSink, opts:{timeoutMs:number}): FlowSource => {\r\n  let timer:number|undefined;\r\n\r\n  const input = sinkify(() => {\r\n    //console.log(`debounce reset`);\r\n    if (timer) window.clearTimeout(timer);\r\n    timer = window.setTimeout(() => { sink[`*`](null); }, opts.timeoutMs);\r\n  });\r\n\r\n  const dispose = () => {\r\n    if (timer) window.clearTimeout(timer);\r\n    timer = undefined;\r\n  };\r\n\r\n  return { input, dispose, name:`debounce` };\r\n};\r\n\r\nexport const debounce = (triggered:()=>void, timeoutMs:number):Debouncer => {\r\n  const opts = { timeoutMs: timeoutMs};\r\n  \r\n  const sink:FlowSink = {\r\n    '*': () => {\r\n      triggered();\r\n    }\r\n  };\r\n  const source = debounceFactory(sink, opts);\r\n  const reset = () => {\r\n    source.input[`*`](null);\r\n  };\r\n  return {...source, reset};\r\n};\r\n\r\nexport class SimpleEventEmitter<Events> {\r\n  readonly #listeners = new SimpleMutableMapArray<Listener<Events>>();\r\n\r\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[K]) {\r\n    const listeners = this.#listeners.get(type as string);\r\n    if (listeners === undefined) return;\r\n    listeners.forEach(l => {\r\n      // eslint-disable-next-line functional/no-try-statement\r\n      try {\r\n        l(args, this);\r\n      } catch (err) {\r\n        console.debug(`Event listener error: `, err);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds event listener\r\n   *\r\n   * @template K\r\n   * @param {K} type\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  addEventListener<K extends keyof Events>(type: K, listener: (ev: Events[K], sender: SimpleEventEmitter<Events>) => void): void { // (this: any, ev: Events[K]) => any): void {\r\n    this.#listeners.add(type as string, listener as Listener<Events>);\r\n  }\r\n  //addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\r\n\r\n  /**\r\n   * Remove event listener\r\n   *\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  removeEventListener<K extends keyof Events>(type: K, listener: Listener<Events>): void {\r\n    this.#listeners.delete(type as string, listener);\r\n  }\r\n\r\n  /**\r\n   * Clear all event listeners\r\n   *\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  clearEventListeners() {\r\n    this.#listeners.clear();\r\n  }\r\n}\r\n\r\n// type TestEventMap = {\r\n//   readonly change: TestEvent\r\n//   readonly other: TestEvent2;\r\n// }\r\n\r\n// interface TestEvent2 {\r\n//   readonly something: string;\r\n// }\r\n// interface TestEvent {\r\n//   readonly blah: boolean;\r\n// }\r\n\r\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\r\n//   constructor() {\r\n//     super();\r\n//     this.addEventListener(`change`, (e) => {\r\n//       e.blah;\r\n//     });\r\n//   }\r\n// }\r\n\r\n/*\r\nexport class Event {\r\n  public target: any;\r\n  public type: string;\r\n  constructor(type: string, target: any) {\r\n    this.target = target;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class ErrorEvent extends Event {\r\n  public message: string;\r\n  public error: Error;\r\n  constructor(error: Error, target: any) {\r\n    super('error', target);\r\n    this.message = error.message;\r\n    this.error = error;\r\n  }\r\n}\r\n\r\nexport class CloseEvent extends Event {\r\n  public code: number;\r\n  public reason: string;\r\n  public wasClean = true;\r\n  constructor(code = 1000, reason = '', target: any) {\r\n    super('close', target);\r\n    this.code = code;\r\n    this.reason = reason;\r\n  }\r\n}\r\nexport interface WebSocketEventMap {\r\n  close: CloseEvent;\r\n  error: ErrorEvent;\r\n  message: MessageEvent;\r\n  open: Event;\r\n}\r\n\r\nexport interface WebSocketEventListenerMap {\r\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\r\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\r\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\r\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\r\n}\r\n*/"],"mappings":";;;;;;AAAA;AAOO,kCAA+B;AAAA,EAA/B,cAPP;AASW,6BAAsC,oBAAI;AAAA;AAAA,EAEnD,IAAI,QAAgB,QAA0B;AAC5C,UAAM,WAAW,mBAAK,MAAK,IAAI;AAC/B,QAAI,aAAa,QAAW;AAC1B,yBAAK,MAAK,IAAI,KAAK;AAAA,WACd;AACL,yBAAK,MAAK,IAAI,KAAK,CAAC,GAAG,UAAU,GAAG;AAAA;AAAA;AAAA,EAIxC,cAAsB;AAEpB,QAAI,IAAI;AACR,UAAM,OAAO,MAAM,KAAK,mBAAK,MAAK;AAClC,SAAK,MAAM,OAAK;AACd,YAAM,IAAI,mBAAK,MAAK,IAAI;AACxB,UAAI,MAAM;AAAW;AACrB,WAAK,IAAI,KAAK,EAAE,aAAa,KAAK,UAAU;AAAA;AAAA;AAE9C,WAAO;AAAA;AAAA,EAGT,IAAI,KAA2C;AAC7C,WAAO,mBAAK,MAAK,IAAI;AAAA;AAAA,EAGvB,OAAO,KAAa,GAAe;AACjC,UAAM,WAAW,mBAAK,MAAK,IAAI;AAC/B,QAAI,aAAa;AAAW,aAAO;AACnC,UAAM,UAAU,SAAS,OAAO,OAAK,MAAM;AAC3C,uBAAK,MAAK,IAAI,KAAK;AACnB,WAAO,QAAQ,SAAS,SAAS;AAAA;AAAA,EAGnC,QAAQ;AACN,uBAAK,MAAK;AAAA;AAAA;AApCH;;;ACTX;AAsDO,+BAAiC;AAAA,EAAjC,cAtDP;AAuDW,mCAAa,IAAI;AAAA;AAAA,EAEhB,UAAkC,MAAS,MAAiB;AACpE,UAAM,YAAY,mBAAK,YAAW,IAAI;AACtC,QAAI,cAAc;AAAW;AAC7B,cAAU,QAAQ,OAAK;AAErB,UAAI;AACF,UAAE,MAAM;AAAA,eACD,KAAP;AACA,gBAAQ,MAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA,EAa9C,iBAAyC,MAAS,UAA6E;AAC7H,uBAAK,YAAW,IAAI,MAAgB;AAAA;AAAA,EAUtC,oBAA4C,MAAS,UAAkC;AACrF,uBAAK,YAAW,OAAO,MAAgB;AAAA;AAAA,EAQzC,sBAAsB;AACpB,uBAAK,YAAW;AAAA;AAAA;AA5CT;","names":[]}