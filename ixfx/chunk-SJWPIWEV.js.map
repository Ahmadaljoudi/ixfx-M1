{"version":3,"sources":["../src/temporal/index.ts","../src/temporal/Normalise.ts","../src/temporal/FrequencyMutable.ts","../src/temporal/MovingAverage.ts","../src/temporal/PointTracker.ts"],"sourcesContent":["export * as Normalise from './Normalise.js';\r\nexport * from './FrequencyMutable.js';\r\nexport * from './MovingAverage.js';\r\nexport {tracker, intervalTracker} from './Tracker.js';\r\nexport {pointTracker} from './PointTracker.js';","import {minMaxAvg} from \"../collections/NumericArrays.js\";\r\nimport {clamp, scale} from \"../Util.js\";\r\n\r\n/**\r\n * Normalises numbers, adjusting min/max as new values are processed.\r\n * Normalised return values will be in the range of 0-1 (inclusive).\r\n * [Read more in the docs]{@link https://clinth.github.io/ixfx-docs/temporal/normalising/}\r\n * \r\n * @example\r\n * ```js\r\n * const s = stream();\r\n * s(2);    // 1 (because 2 is highest seen)\r\n * s(1);    // 0 (because 1 is the lowest so far)\r\n * s(1.5);  // 0.5 (50% of range 1-2)\r\n * s(0.5);  // 0 (because it's the new lowest)\r\n * ```\r\n * \r\n * Since normalisation is being adjusted as new min/max are encountered, it might\r\n * be that value normalised to 1 at one time is different to what normalises to 1\r\n * at a later time.\r\n * \r\n * If you already know what to expect of the number range, passingin `minDefault` \r\n * and `maxDefault` primes the normalisation.\r\n * ```js\r\n * const s = stream();\r\n * s(5); // 1, because it's the highest seen\r\n * \r\n * // With priming:\r\n * const s = stream(0, 10);\r\n * s(5); // 0.5, because we're expecting range 0-10\r\n * ```\r\n * \r\n * Note that if a value exceeds the default range, normalisation adjusts.\r\n * @returns \r\n */\r\nexport const stream = (minDefault?:number, maxDefault?:number) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\r\n  //eslint-disable-next-line functional/no-let\r\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\r\n\r\n  return (v:number):number => {\r\n    min = Math.min(min, v);\r\n    max = Math.max(max, v);\r\n    return scale(v, min, max);\r\n  };\r\n};\r\n\r\n/**\r\n * Normalises an array. By default uses the actual min/max of the array\r\n * as the normalisation range. [Read more in the docs]{@link https://clinth.github.io/ixfx-docs/temporal/normalising/}\r\n * \r\n * ```js\r\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\r\n * array([5,1,0,9,10]);\r\n * ```\r\n * \r\n * `minForced` and/or `maxForced` can\r\n * be provided to use an arbitrary range. \r\n * ```js\r\n * // Forced range 0-100\r\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\r\n * array([5,1,0,9,10], 0, 100);\r\n * ```\r\n * \r\n * Return values are clamped to always be 0-1, inclusive.\r\n * \r\n * @param values Values\r\n * @param minForced If provided, this will be min value used\r\n * @param maxForced If provided, this will be the max value used\r\n */\r\nexport const array = (values:readonly number[], minForced?:number, maxForced?:number) => {\r\n  if (!Array.isArray(values)) throw new Error(`values param should be an array`);\r\n  const mma = minMaxAvg(values);\r\n\r\n  const min = minForced ?? mma.min;\r\n  const max = maxForced ?? mma.max;\r\n\r\n  return values.map(v => clamp(scale(v, min, max)));\r\n};","/// âœ” Unit tested!\r\n\r\nimport { ToString } from \"../Util.js\";\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\nimport * as KeyValueUtil from '../KeyValue.js';\r\nimport {KeyValues} from \"../index.js\";\r\n\r\ntype FrequencyEventMap = {\r\n  readonly change:void;\r\n}\r\n\r\n/**\r\n * Frequency keeps track of how many times a particular value is seen, but\r\n * unlike a {@link Maps|Map} it does not store the data. By default compares\r\n * items by value (via JSON.stringify).\r\n * \r\n * Create with {@link frequencyMutable}.\r\n * \r\n * Fires `change` event when items are added or it is cleared.\r\n *\r\n * Overview\r\n * ```\r\n * const fh = frequencyMutable();\r\n * fh.add(value); // adds a value\r\n * fh.clear();    // clears all data\r\n * fh.keys() / .values() // returns an iterator for keys and values\r\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\r\n * ```\r\n * \r\n * Usage\r\n * ```\r\n * const fh = frequencyMutable();\r\n * fh.add(`apples`); // Count an occurence of `apples`\r\n * fh.add(`oranges)`;\r\n * fh.add(`apples`);\r\n * \r\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\r\n * fhData.forEach((d) => {\r\n *  const [key,freq] = d;\r\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\r\n * })\r\n * ```\r\n * \r\n * Custom key string\r\n * ```\r\n * const fh = frequencyMutable( person => person.name);\r\n * // All people with name `Samantha` will be counted in same group\r\n * fh.add({name:`Samantha`, city:`Brisbane`});\r\n * ```\r\n * @template V Type of items\r\n */\r\nexport class FrequencyMutable<V> extends SimpleEventEmitter<FrequencyEventMap> {\r\n  readonly #store:Map<string, number>;\r\n  readonly #keyString: ToString<V>;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param keyString Function to key items. Uses JSON.stringify by default\r\n   */\r\n  constructor(keyString: ToString<V> | undefined = undefined) {\r\n    super();\r\n    this.#store = new Map();\r\n\r\n    if (keyString === undefined) {\r\n      keyString = (a) => {\r\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\r\n        if (typeof a === `string`) { \r\n          return a;\r\n        } else { \r\n          return JSON.stringify(a);\r\n        }\r\n      };\r\n    }\r\n    this.#keyString = keyString;\r\n  }\r\n\r\n  /**\r\n   * Clear data. Fires `change` event\r\n   */\r\n  clear() {\r\n    this.#store.clear();\r\n    this.fireEvent(`change`, undefined);\r\n  }\r\n  \r\n  /**\r\n   * @returns Iterator over keys (ie. groups)\r\n   */\r\n  keys():IterableIterator<string> {\r\n    return this.#store.keys();\r\n  }\r\n\r\n  /**\r\n   * @returns Iterator over frequency counts\r\n   */\r\n  values():IterableIterator<number> {\r\n    return this.#store.values();\r\n  }\r\n\r\n  /**\r\n   * @returns Copy of entries as an array of `[key, count]`\r\n   */\r\n  toArray():[key:string, count:number][] {\r\n    return Array.from(this.#store.entries());\r\n  }\r\n  \r\n  /**\r\n   * Returns a string with keys and counts, useful for debugging.\r\n   * @returns \r\n   */\r\n  debugString():string {\r\n    //eslint-disable-next-line functional/no-let\r\n    let t = ``;\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const [key, count] of this.#store.entries()) {\r\n      t += `${key}: ${count}, `;\r\n    }\r\n    if (t.endsWith(`, `)) return t.substring(0, t.length-2);\r\n    return t;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param value Value to count\r\n   * @returns Frequency of value, or _undefined_ if it does not exist\r\n   */\r\n  frequencyOf(value:V|string):number|undefined {\r\n    if (typeof value === `string`) return this.#store.get(value);\r\n\r\n    const key = this.#keyString(value);\r\n    return this.#store.get(key);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param value Value to count\r\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\r\n   */\r\n  relativeFrequencyOf(value:V|string):number|undefined {\r\n    let freq:number|undefined;\r\n    if (typeof value === `string`) freq = this.#store.get(value);\r\n    else {\r\n      const key = this.#keyString(value);\r\n      freq = this.#store.get(key);\r\n    }\r\n    if (freq === undefined) return;\r\n\r\n    const mma = this.minMaxAvg();\r\n    return freq / mma.total;\r\n  }\r\n\r\n  /**\r\n   * @returns Copy of entries as an array \r\n   */\r\n  entries():Array<KeyValueUtil.KeyValue> {\r\n    return Array.from(this.#store.entries());\r\n  }\r\n  \r\n  /**\r\n   * \r\n   * @returns Returns `{min,max,avg,total}`\r\n   */\r\n  minMaxAvg() {\r\n    return KeyValues.minMaxAvg(this.entries());\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param sortStyle Sorting style (default: _value_, ie. count)\r\n   * @returns Sorted array of [key,frequency]\r\n   */\r\n  entriesSorted(sortStyle:`value` | `valueReverse` | `key` | `keyReverse` = `value`):ReadonlyArray<KeyValues.KeyValue> {\r\n    const s = KeyValueUtil.getSorter(sortStyle);\r\n    return s(this.entries());\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param values Values to add. Fires _change_ event after adding item(s)\r\n   */\r\n  add(...values:V[]) {\r\n    if (values === undefined) throw new Error(`value parameter is undefined`);\r\n    \r\n    const keys = values.map(this.#keyString);\r\n    \r\n    //const key = this.#keyString(value);\r\n    keys.forEach(key => {\r\n      const score = this.#store.get(key) ?? 0;\r\n      this.#store.set(key, score+1);  \r\n    });\r\n    this.fireEvent(`change`, undefined);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a FrequencyMutable\r\n * @inheritdoc FrequencyMutable\r\n * @template V Data type of items\r\n * @param keyString Function to generate keys for items. If not specified, uses JSON.stringify \r\n * @returns \r\n */\r\nexport const frequencyMutable = <V>(keyString?:ToString<V>|undefined) => new FrequencyMutable<V>(keyString);\r\n","import {Arrays, queueMutable} from '../collections/index.js';\r\nimport {integer as guardInteger} from '../Guards.js';\r\n\r\n/**\r\n * A moving average calculator (exponential weighted moving average) which does not keep track of\r\n * previous samples. Less accurate, but uses less system resources.\r\n * \r\n * The `scaling` parameter determines smoothing. A value of `1` means that\r\n * the latest value is used as the average - that is, no smoothing. Higher numbers\r\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\r\n * \r\n * `add()` adds a new value and returns the calculated average.\r\n * \r\n * ```\r\n * const ma = movingAverageLight(); // default scaling of 3\r\n * ma.add(50);  // 50\r\n * ma.add(100); // 75\r\n * ma.add(75);  // 75\r\n * ma.add(0);   // 50\r\n * ```\r\n * \r\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\r\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\r\n * \r\n * Use `clear()` to reset the moving average, or `compute()` to get the current value without adding.\r\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\r\n * @returns {@link MovingAverage} \r\n */\r\nexport const movingAverageLight = (scaling:number = 3):MovingAverage => {\r\n  guardInteger(scaling, `aboveZero`, `scaling`);\r\n  //eslint-disable-next-line functional/no-let\r\n  let average = 0;\r\n  //eslint-disable-next-line functional/no-let\r\n  let count = 0;\r\n\r\n  const ma:MovingAverage = {\r\n    add(v:number) {\r\n      count++;\r\n      average = average + (v - average) / Math.min(count, scaling);\r\n      return average;\r\n    },\r\n    clear() {\r\n      average = 0;\r\n      count = 0;\r\n    },\r\n    compute() {\r\n      return average;\r\n    }\r\n  };\r\n  return ma;\r\n};\r\n\r\n/**\r\n * Creates a moving average for a set number of `samples`.\r\n * \r\n * Moving average are useful for computing the average over a recent set of numbers.\r\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\r\n * A higher number of samples produces a smoother computed value which takes longer to respond to\r\n * changes in data.\r\n * \r\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\r\n * the rate at which new data is added to the moving average.\r\n * \r\n* `add` adds a number and returns the computed average. Call `compute` to \r\n * get the average without adding a new value.\r\n * \r\n * ```js\r\n * const ma = movingAverage(10);\r\n * ma.add(10); // 10\r\n * ma.add(5);  // 7.5\r\n * ```\r\n * \r\n * `clear` clears the average.\r\n * \r\n * A weighting function can be provided to shape how the average is\r\n * calculated - eg privileging the most recent data over older data.\r\n * It uses `Arrays.averageWeighted` under the hood.\r\n * \r\n * ```js\r\n * // Give more weight to data in middle of sampling window\r\n * const ma = movingAverage(100, Easings.gaussian());\r\n * ```\r\n * \r\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\r\n * @param samples Number of samples to compute average from\r\n * @param weightingFn Optional weighting function\r\n * @returns \r\n */\r\nexport const movingAverage = (samples = 100, weightingFn?:(v:number)=>number):MovingAverage => {\r\n  \r\n  //eslint-disable-next-line functional/no-let\r\n  let q = queueMutable<number>({\r\n    capacity: samples,\r\n    discardPolicy: `older`\r\n  });\r\n  \r\n  const clear = () => {\r\n    q = queueMutable<number>({\r\n      capacity: samples,\r\n      discardPolicy: `older`\r\n    });\r\n  };\r\n\r\n  const compute = () => {\r\n    if (weightingFn === undefined) {\r\n      return Arrays.average(...q.data);\r\n    } else {\r\n      return Arrays.averageWeighted(q.data, weightingFn);\r\n    }\r\n  };\r\n\r\n  const add = (v:number) => {\r\n    q.enqueue(v);\r\n    return compute();\r\n  };\r\n\r\n  return { add, compute, clear };\r\n};\r\n\r\n/**\r\n * Moving average.\r\n * Create via {@link movingAverage} or {@link movingAverageLight}.\r\n */\r\nexport type MovingAverage = {\r\n  /**\r\n   * Clear data\r\n   */\r\n  clear():void\r\n  /**\r\n   * Returns current average\r\n   */\r\n  compute():number\r\n  /**\r\n   * Adds a value, returning new average\r\n   * @param v Value to add\r\n   */\r\n  add(v:number):number\r\n}\r\n","import * as Points from \"../geometry/Point.js\";\r\nimport {getOrGenerate, GetOrGenerate} from \"../collections/Map.js\";\r\nimport * as Line from \"~/geometry/Line.js\";\r\n\r\nexport type SeenInfo = {\r\n  readonly distance:number\r\n  readonly centroid:Points.Point\r\n  readonly angle:number\r\n  readonly speed:number\r\n};\r\n\r\nexport type TimestampedPoint = Points.Point & {\r\n  readonly at:number\r\n};\r\n\r\n/**\r\n * A tracked point\r\n */\r\nexport class TrackedPoint {\r\n  relation;\r\n  points:TimestampedPoint[];\r\n  lastPoint:TimestampedPoint;\r\n\r\n  constructor(readonly id:string, start:Points.Point, readonly storePoints:boolean) {\r\n    const s = {...start, at:Date.now()};\r\n    this.relation = Points.relation(s);\r\n    this.lastPoint = {...start, at:Date.now()};\r\n    this.points = [s];\r\n  }\r\n\r\n  get x() {\r\n    return this.lastPoint.x;\r\n  }\r\n\r\n  get y() {\r\n    return this.lastPoint.y;\r\n  }\r\n\r\n  /**\r\n   * Returns number of saved points (including start)\r\n   */\r\n  get size() {\r\n    return this.points.length;\r\n  }\r\n\r\n  /**\r\n   * Tracks a point, returning information on the relation between it\r\n   * and the start point.\r\n   * \r\n   * If multiple points are given, it's relation to the last point that is returned.\r\n   * @param p Point\r\n   */\r\n  seen(...p:Points.Point[]|TimestampedPoint[]):SeenInfo {\r\n    // Make sure points have a timestamp\r\n    const ts = p.map(v => ((`at` in v) ? v : {\r\n      ...v,\r\n      at: Date.now()\r\n    }));\r\n\r\n    const last = ts[p.length-1];\r\n  \r\n    if (this.storePoints) this.points.push(...ts);\r\n  \r\n    // Get basic geometric relation from start to the last provided point\r\n    const rel = this.relation(last);\r\n    \r\n    const r = {\r\n      ...rel,\r\n      speed: Line.length(last, this.lastPoint) / (last.at - this.lastPoint.at)\r\n    };\r\n\r\n    this.lastPoint = last;\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Returns a polyline representation of stored points.\r\n   * Returns an empty array if points were not saved, or there's only one.\r\n   */\r\n  get line():Line.PolyLine {\r\n    if (this.points.length === 1) return [];\r\n    return Line.joinPointsToLines(...this.points);\r\n  }\r\n\r\n  /**\r\n   * Returns the total length of accumulated points.\r\n   * Returns 0 if points were not saved, or there's only one\r\n   */\r\n  get length():number {\r\n    if (this.points.length === 1) return 0;\r\n    const l = this.line;\r\n    return Line.length(l);\r\n  }\r\n\r\n  /**\r\n   * Returns the elapsed time, in milliseconds since the instance was created\r\n   */\r\n  get elapsed():number {\r\n    return Date.now() - this.points[0].at;\r\n  }\r\n}\r\n\r\n/**\r\n * Options for PointTracker\r\n */\r\nexport type Opts = {\r\n  /**\r\n   * If true, intermediate points are stored\r\n   */\r\n  readonly trackIntermediatePoints?:boolean\r\n}\r\n\r\nexport const pointTracker = (opts:Opts):PointTracker => new PointTracker(opts);\r\n\r\n/**\r\n * PointTracker. Mutable.\r\n */\r\nexport class PointTracker  {\r\n  store:Map<string, TrackedPoint>;\r\n  gog:GetOrGenerate<string, TrackedPoint, Points.Point>;\r\n\r\n  constructor(opts:Opts = {}) {\r\n    const trackIntermediatePoints = opts.trackIntermediatePoints ?? false;\r\n\r\n    this.store = new Map();\r\n    this.gog = getOrGenerate<string, TrackedPoint, Points.Point>(this.store, (key, start) => {\r\n      if (start === undefined) throw new Error(`Requires start point`);\r\n      return new TrackedPoint(key, start, trackIntermediatePoints);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return number of named points being tracked\r\n   */\r\n  get size() {\r\n    return this.store.size;\r\n  }\r\n\r\n  /**\r\n   * For a given id, note that we have seen one or more points.\r\n   * @param id Id\r\n   * @param points Point(s)\r\n   * @returns Information about start to last point\r\n   */\r\n  async seen(id:string, ...points:Points.Point[]) {\r\n    if (id === null) throw new Error(`id parameter cannot be null`);\r\n    if (id === undefined) throw new Error(`id parameter cannot be undefined`);\r\n\r\n    // Create or recall TrackedPoint by id\r\n    const trackedPoint = await this.gog(id, points[0]);\r\n\r\n    // Pass it over to the TrackedPoint\r\n    return trackedPoint.seen(...points);\r\n  }\r\n\r\n  /**\r\n   * Remove a tracked point by id.\r\n   * Use {@link reset} to clear them all.\r\n   * @param id\r\n   */\r\n  delete(id:string) {\r\n    this.store.delete(id);\r\n  }\r\n\r\n  /**\r\n   * Remove all tracked points.\r\n   * Use {@link delete} to remove a single point by id.\r\n   */\r\n  reset() {\r\n    this.store = new Map();\r\n  }\r\n\r\n  /**\r\n   * Enumerate ids\r\n   */\r\n  *ids() {\r\n    yield* this.store.keys();\r\n  }\r\n\r\n  /**\r\n   * Enumerate tracked points\r\n   */\r\n  *trackedPoints() {\r\n    yield* this.store.values();\r\n  }\r\n\r\n  /**\r\n   * Returns TrackedPoints ordered with oldest first\r\n   * @returns \r\n   */\r\n  getTrackedPointsByAge():readonly TrackedPoint[] {\r\n    const tp = Array.from(this.store.values());\r\n    tp.sort((a, b) => {\r\n      const aa =a.elapsed;\r\n      const bb = b.elapsed;\r\n      if (aa === bb) return 0;\r\n      if (aa > bb) return -1;\r\n      return 1;\r\n    });\r\n    return tp;\r\n  }\r\n\r\n  /**\r\n   * Enumerate last received points\r\n   * \r\n   * @example Calculate centroid of latest-received points\r\n   * ```js\r\n   * const c = Points.centroid(...Array.from(pointers.lastPoints()));\r\n   * ```\r\n   */\r\n  *lastPoints() {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const p of this.store.values()) {\r\n      yield p.lastPoint;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enumerate starting points\r\n   */\r\n  *startPoints() {\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const p of this.store.values()) {\r\n      yield p.points[0];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a tracked point by id, or undefined if not found\r\n   * @param id \r\n   * @returns \r\n   */\r\n  get(id:string):TrackedPoint|undefined {\r\n    return this.store.get(id);\r\n  }\r\n  \r\n}"],"mappings":"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","names":[]}