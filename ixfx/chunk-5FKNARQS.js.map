{"version":3,"sources":["../src/temporal/index.ts","../src/temporal/Normalise.ts","../src/temporal/FrequencyMutable.ts"],"sourcesContent":["export * as Normalise from './Normalise.js';\r\nexport * from './FrequencyMutable.js';","import {minMaxAvg} from \"../collections/NumericArrays.js\";\r\nimport {clamp, scale} from \"../Util.js\";\r\n\r\n/**\r\n * Normalises numbers, adjusting min/max as new values are processed.\r\n * Normalised return values will be in the range of 0-1 (inclusive).\r\n * \r\n * @example\r\n * ```js\r\n * const s = stream();\r\n * s(2);    // 1 (because 2 is highest seen)\r\n * s(1);    // 0 (because 1 is the lowest so far)\r\n * s(1.5);  // 0.5 (50% of range 1-2)\r\n * s(0.5);  // 0 (because it's the new lowest)\r\n * ```\r\n * \r\n * Since normalisation is being adjusted as new min/max are encountered, it might\r\n * be that value normalised to 1 at one time is different to what normalises to 1\r\n * at a later time.\r\n * \r\n * If you already know what to expect of the number range, passingin `minDefault` \r\n * and `maxDefault` primes the normalisation.\r\n * ```js\r\n * const s = stream();\r\n * s(5); // 1, because it's the highest seen\r\n * \r\n * // With priming:\r\n * const s = stream(0, 10);\r\n * s(5); // 0.5, because we're expecting range 0-10\r\n * ```\r\n * \r\n * Note that if a value exceeds the default range, normalisation adjusts.\r\n * @returns \r\n */\r\nexport const stream = (minDefault?:number, maxDefault?:number) => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\r\n  //eslint-disable-next-line functional/no-let\r\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\r\n\r\n  return (v:number):number => {\r\n    min = Math.min(min, v);\r\n    max = Math.max(max, v);\r\n    return scale(v, min, max);\r\n  };\r\n};\r\n\r\n/**\r\n * Normalises an array. By default uses the actual min/max of the array\r\n * as the normalisation range.\r\n * \r\n * ```js\r\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\r\n * array([5,1,0,9,10]);\r\n * ```\r\n * \r\n * `minForced` and/or `maxForced` can\r\n * be provided to use an arbitrary range. \r\n * ```js\r\n * // Forced range 0-100\r\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\r\n * array([5,1,0,9,10], 0, 100);\r\n * ```\r\n * \r\n * Return values are clamped to always be 0-1, inclusive.\r\n * \r\n * @param values Values\r\n * @param minForced If provided, this will be min value used\r\n * @param maxForced If provided, this will be the max value used\r\n */\r\nexport const array = (values:readonly number[], minForced?:number, maxForced?:number) => {\r\n  if (!Array.isArray(values)) throw new Error(`values param should be an array`);\r\n  const mma = minMaxAvg(values);\r\n\r\n  const min = minForced ?? mma.min;\r\n  const max = maxForced ?? mma.max;\r\n\r\n  return values.map(v => clamp(scale(v, min, max)));\r\n};","/// âœ” Unit tested!\r\n\r\nimport { ToString } from \"../Util.js\";\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\nimport * as KeyValueUtil from '../KeyValue.js';\r\nimport {KeyValues} from \"../index.js\";\r\n\r\ntype FrequencyEventMap = {\r\n  readonly change:void;\r\n}\r\n\r\n/**\r\n * Frequency keeps track of how many times a particular value is seen, but\r\n * unlike a {@link Maps|Map} it does not store the data. By default compares\r\n * items by value (via JSON.stringify).\r\n * \r\n * Create with {@link frequencyMutable}.\r\n * \r\n * Fires `change` event when items are added or it is cleared.\r\n *\r\n * Overview\r\n * ```\r\n * const fh = frequencyMutable();\r\n * fh.add(value); // adds a value\r\n * fh.clear();    // clears all data\r\n * fh.keys() / .values() // returns an iterator for keys and values\r\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\r\n * ```\r\n * \r\n * Usage\r\n * ```\r\n * const fh = frequencyMutable();\r\n * fh.add(`apples`); // Count an occurence of `apples`\r\n * fh.add(`oranges)`;\r\n * fh.add(`apples`);\r\n * \r\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\r\n * fhData.forEach((d) => {\r\n *  const [key,freq] = d;\r\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\r\n * })\r\n * ```\r\n * \r\n * Custom key string\r\n * ```\r\n * const fh = frequencyMutable( person => person.name);\r\n * // All people with name `Samantha` will be counted in same group\r\n * fh.add({name:`Samantha`, city:`Brisbane`});\r\n * ```\r\n * @template V Type of items\r\n */\r\nexport class FrequencyMutable<V> extends SimpleEventEmitter<FrequencyEventMap> {\r\n  readonly #store:Map<string, number>;\r\n  readonly #keyString: ToString<V>;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param keyString Function to key items. Uses JSON.stringify by default\r\n   */\r\n  constructor(keyString: ToString<V> | undefined = undefined) {\r\n    super();\r\n    this.#store = new Map();\r\n\r\n    if (keyString === undefined) {\r\n      keyString = (a) => {\r\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\r\n        if (typeof a === `string`) { \r\n          return a;\r\n        } else { \r\n          return JSON.stringify(a);\r\n        }\r\n      };\r\n    }\r\n    this.#keyString = keyString;\r\n  }\r\n\r\n  /**\r\n   * Clear data. Fires `change` event\r\n   */\r\n  clear() {\r\n    this.#store.clear();\r\n    this.fireEvent(`change`, undefined);\r\n  }\r\n  \r\n  /**\r\n   * @returns Iterator over keys (ie. groups)\r\n   */\r\n  keys():IterableIterator<string> {\r\n    return this.#store.keys();\r\n  }\r\n\r\n  /**\r\n   * @returns Iterator over frequency counts\r\n   */\r\n  values():IterableIterator<number> {\r\n    return this.#store.values();\r\n  }\r\n\r\n  /**\r\n   * @returns Copy of entries as an array of `[key, count]`\r\n   */\r\n  toArray():[key:string, count:number][] {\r\n    return Array.from(this.#store.entries());\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param value Value to count\r\n   * @returns Frequency of value, or _undefined_ if it does not exist\r\n   */\r\n  frequencyOf(value:V|string):number|undefined {\r\n    if (typeof value === `string`) return this.#store.get(value);\r\n\r\n    const key = this.#keyString(value);\r\n    return this.#store.get(key);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param value Value to count\r\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\r\n   */\r\n  relativeFrequencyOf(value:V|string):number|undefined {\r\n    if (typeof value === `string`) return this.#store.get(value);\r\n\r\n    const key = this.#keyString(value);\r\n    const freq = this.#store.get(key);\r\n    if (freq === undefined) return;\r\n\r\n    const mma = this.minMaxAvg();\r\n    return freq / mma.total;\r\n  }\r\n\r\n  /**\r\n   * @returns Copy of entries as an array \r\n   */\r\n  entries():Array<KeyValueUtil.KeyValue> {\r\n    return Array.from(this.#store.entries());\r\n  }\r\n  \r\n  /**\r\n   * \r\n   * @returns Returns `{min,max,avg,total}`\r\n   */\r\n  minMaxAvg() {\r\n    return KeyValues.minMaxAvg(this.entries());\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param sortStyle Sorting style (default: _value_, ie. count)\r\n   * @returns Sorted array of [key,frequency]\r\n   */\r\n  entriesSorted(sortStyle:`value` | `valueReverse` | `key` | `keyReverse` = `value`):ReadonlyArray<KeyValues.KeyValue> {\r\n    const s = KeyValueUtil.getSorter(sortStyle);\r\n    return s(this.entries());\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param values Values to add. Fires _change_ event after adding item(s)\r\n   */\r\n  add(...values:V[]) {\r\n    if (values === undefined) throw new Error(`value parameter is undefined`);\r\n    \r\n    const keys = values.map(this.#keyString);\r\n    \r\n    //const key = this.#keyString(value);\r\n    keys.forEach(key => {\r\n      const score = this.#store.get(key) ?? 0;\r\n      this.#store.set(key, score+1);  \r\n    });\r\n    this.fireEvent(`change`, undefined);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a FrequencyMutable\r\n * @inheritdoc FrequencyMutable\r\n * @template V Data type of items\r\n * @param keyString Function to generate keys for items. If not specified, uses JSON.stringify \r\n * @returns \r\n */\r\nexport const frequencyMutable = <V>(keyString?:ToString<V>|undefined) => new FrequencyMutable<V>(keyString);\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAkCO,IAAM,SAAS,CAAC,YAAoB,eAAuB;AAEhE,MAAI,MAAM,cAAc,OAAO;AAE/B,MAAI,MAAM,cAAc,OAAO;AAE/B,SAAO,CAAC,MAAoB;AAC1B,UAAM,KAAK,IAAI,KAAK;AACpB,UAAM,KAAK,IAAI,KAAK;AACpB,WAAO,MAAM,GAAG,KAAK;AAAA;AAAA;AA2BlB,IAAM,QAAQ,CAAC,QAA0B,WAAmB,cAAsB;AACvF,MAAI,CAAC,MAAM,QAAQ;AAAS,UAAM,IAAI,MAAM;AAC5C,QAAM,MAAM,UAAU;AAEtB,QAAM,MAAM,aAAa,IAAI;AAC7B,QAAM,MAAM,aAAa,IAAI;AAE7B,SAAO,OAAO,IAAI,OAAK,MAAM,MAAM,GAAG,KAAK;AAAA;;;AC7E7C;AAmDO,qCAAkC,mBAAsC;AAAA,EAQ7E,YAAY,YAAqC,QAAW;AAC1D;AARO;AACA;AAQP,uBAAK,QAAS,oBAAI;AAElB,QAAI,cAAc,QAAW;AAC3B,kBAAY,CAAC,MAAM;AACjB,YAAI,MAAM;AAAW,gBAAM,IAAI,MAAM;AACrC,YAAI,OAAO,MAAM,UAAU;AACzB,iBAAO;AAAA,eACF;AACL,iBAAO,KAAK,UAAU;AAAA;AAAA;AAAA;AAI5B,uBAAK,YAAa;AAAA;AAAA,EAMpB,QAAQ;AACN,uBAAK,QAAO;AACZ,SAAK,UAAU,UAAU;AAAA;AAAA,EAM3B,OAAgC;AAC9B,WAAO,mBAAK,QAAO;AAAA;AAAA,EAMrB,SAAkC;AAChC,WAAO,mBAAK,QAAO;AAAA;AAAA,EAMrB,UAAuC;AACrC,WAAO,MAAM,KAAK,mBAAK,QAAO;AAAA;AAAA,EAQhC,YAAY,OAAiC;AAC3C,QAAI,OAAO,UAAU;AAAU,aAAO,mBAAK,QAAO,IAAI;AAEtD,UAAM,MAAM,mBAAK,YAAL,WAAgB;AAC5B,WAAO,mBAAK,QAAO,IAAI;AAAA;AAAA,EAQzB,oBAAoB,OAAiC;AACnD,QAAI,OAAO,UAAU;AAAU,aAAO,mBAAK,QAAO,IAAI;AAEtD,UAAM,MAAM,mBAAK,YAAL,WAAgB;AAC5B,UAAM,OAAO,mBAAK,QAAO,IAAI;AAC7B,QAAI,SAAS;AAAW;AAExB,UAAM,MAAM,KAAK;AACjB,WAAO,OAAO,IAAI;AAAA;AAAA,EAMpB,UAAuC;AACrC,WAAO,MAAM,KAAK,mBAAK,QAAO;AAAA;AAAA,EAOhC,YAAY;AACV,WAAO,iBAAU,UAAU,KAAK;AAAA;AAAA,EAQlC,cAAc,YAA4D,SAA2C;AACnH,UAAM,IAAI,AAAa,UAAU;AACjC,WAAO,EAAE,KAAK;AAAA;AAAA,EAOhB,OAAO,QAAY;AACjB,QAAI,WAAW;AAAW,YAAM,IAAI,MAAM;AAE1C,UAAM,OAAO,OAAO,IAAI,mBAAK;AAG7B,SAAK,QAAQ,SAAO;AAClB,YAAM,QAAQ,mBAAK,QAAO,IAAI,QAAQ;AACtC,yBAAK,QAAO,IAAI,KAAK,QAAM;AAAA;AAE7B,SAAK,UAAU,UAAU;AAAA;AAAA;AAxHlB;AACA;AAkIJ,IAAM,mBAAmB,CAAI,cAAqC,IAAI,iBAAoB;","names":[]}